{
  "version": 3,
  "sources": ["matcher.ts"],
  "sourcesContent": ["import { Capture } from './capture';\n\n                                                                                                                            \nexport abstract class Matcher {\n                                                                                  \n  public static isMatcher(x: any): x is Matcher {\n    return x && x instanceof Matcher;\n  }\n\n                                                                                                                  \n  public abstract readonly name: string;\n\n                                                                                                                                                                                                                                                                                                                                              \n  public abstract test(actual: any): MatchResult;\n}\n\n                                \nexport interface MatchFailure {\n                                                 \n  readonly matcher: Matcher;\n\n                                                                                                                                                                                                                                                                                                    \n  readonly path: string[];\n\n                                \n  readonly message: string;\n}\n\n                                                          \nexport interface MatchCapture {\n                                                                                        \n  readonly capture: Capture;\n                                            \n  readonly value: any;\n}\n\n                                        \nexport class MatchResult {\n                                                                \n  public readonly target: any;\n  private readonly failures: MatchFailure[] = [];\n  private readonly captures: Map<Capture, any[]> = new Map();\n  private finalized: boolean = false;\n\n  constructor(target: any) {\n    this.target = target;\n  }\n\n                                                                \n  public push(matcher: Matcher, path: string[], message: string): this {\n    return this.recordFailure({ matcher, path, message });\n  }\n\n                                                                          \n  public recordFailure(failure: MatchFailure): this {\n    this.failures.push(failure);\n    return this;\n  }\n\n                                                                              \n  public hasFailed(): boolean {\n    return this.failures.length !== 0;\n  }\n\n                               \n  public get failCount(): number {\n    return this.failures.length;\n  }\n\n                                                                                                                \n  public compose(id: string, inner: MatchResult): this {\n    const innerF = inner.failures;\n    this.failures.push(...innerF.map(f => {\n      return { path: [id, ...f.path], message: f.message, matcher: f.matcher };\n    }));\n    inner.captures.forEach((vals, capture) => {\n      vals.forEach(value => this.recordCapture({ capture, value }));\n    });\n    return this;\n  }\n\n                                                                                                                    \n  public finished(): this {\n    if (this.finalized) {\n      return this;\n    }\n\n    if (this.failCount === 0) {\n      this.captures.forEach((vals, cap) => cap._captured.push(...vals));\n    }\n    this.finalized = true;\n    return this;\n  }\n\n                                                                   \n  public toHumanStrings(): string[] {\n    return this.failures.map(r => {\n      const loc = r.path.length === 0 ? '' : ` at ${r.path.join('')}`;\n      return '' + r.message + loc + ` (using ${r.matcher.name} matcher)`;\n    });\n  }\n\n                                                               \n  public recordCapture(options: MatchCapture): void {\n    let values = this.captures.get(options.capture);\n    if (values === undefined) {\n      values = [];\n    }\n    values.push(options.value);\n    this.captures.set(options.capture, values);\n  }\n}\n"],
  "mappings": "qOAGA,aAA6B,OAEb,WAAU,EAAM,CAC5B,MAAO,IAAK,YAAa,UAH7B,QAAA,QAAA,kGAkCA,iBAAwB,CAOtB,YAAY,OAAW,CAJN,KAAA,SAA2B,GAC3B,KAAA,SAAgC,GAAI,KAC7C,KAAA,UAAqB,GAG3B,KAAK,OAAS,OAIT,KAAK,QAAkB,KAAgB,QAAe,uKACpD,KAAK,cAAc,CAAE,QAAS,KAAM,UAItC,cAAc,QAAqB,6EACxC,KAAK,SAAS,KAAK,SACZ,KAIF,WAAS,CACd,MAAO,MAAK,SAAS,SAAW,KAIvB,YAAS,CAClB,MAAO,MAAK,SAAS,OAIhB,QAAQ,GAAY,MAAkB,mEAC3C,KAAM,QAAS,MAAM,SACrB,YAAK,SAAS,KAAK,GAAG,OAAO,IAAI,GACxB,EAAE,KAAM,CAAC,GAAI,GAAG,EAAE,MAAO,QAAS,EAAE,QAAS,QAAS,EAAE,YAEjE,MAAM,SAAS,QAAQ,CAAC,KAAM,UAAW,CACvC,KAAK,QAAQ,OAAS,KAAK,cAAc,CAAE,QAAS,WAE/C,KAIF,UAAQ,CACb,MAAI,MAAK,UACA,KAGL,MAAK,YAAc,GACrB,KAAK,SAAS,QAAQ,CAAC,KAAM,MAAQ,IAAI,UAAU,KAAK,GAAG,OAE7D,KAAK,UAAY,GACV,MAIF,gBAAc,CACnB,MAAO,MAAK,SAAS,IAAI,GAAI,CAC3B,KAAM,KAAM,EAAE,KAAK,SAAW,EAAI,GAAK,OAAO,EAAE,KAAK,KAAK,MAC1D,MAAO,GAAK,EAAE,QAAU,IAAM,WAAW,EAAE,QAAQ,kBAKhD,cAAc,QAAqB,sEACxC,GAAI,QAAS,KAAK,SAAS,IAAI,QAAQ,SACvC,AAAI,SAAW,QACb,QAAS,IAEX,OAAO,KAAK,QAAQ,OACpB,KAAK,SAAS,IAAI,QAAQ,QAAS,SAxEvC,QAAA,YAAA",
  "names": []
}
