{
  "version": 3,
  "sources": ["messages.ts"],
  "sourcesContent": ["import { MatchResult } from '../matcher';\nimport { Messages } from './message';\nimport { filterLogicalId, formatFailure, matchSection } from './section';\n\nexport function findMessage(messages: Messages, logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n  const section: { [key: string]: {} } = messages;\n  const result = matchSection(filterLogicalId(section, logicalId), props);\n\n  if (!result.match) {\n    return {};\n  }\n\n  return result.matches;\n}\n\nexport function hasMessage(messages: Messages, logicalId: string, props: any): string | void {\n  const section: { [key: string]: {} } = messages;\n  const result = matchSection(filterLogicalId(section, logicalId), props);\n\n  if (result.match) {\n    return;\n  }\n\n  if (result.closestResult === undefined) {\n    return 'No messages found in the stack';\n  }\n\n  return [\n    `Stack has ${result.analyzedCount} messages, but none match as expected.`,\n    formatFailure(formatMessage(result.closestResult)),\n  ].join('\\n');\n}\n\n// We redact the stack trace by default because it is unnecessarily long and unintelligible.\n// If there is a use case for rendering the trace, we can add it later.\nfunction formatMessage(match: MatchResult, renderTrace: boolean = false): MatchResult {\n  if (!renderTrace) {\n    match.target.entry.trace = 'redacted';\n  }\n  return match;\n}\n"],
  "mappings": "kHAEA,KAAA,WAAA,QAAA,aAEA,qBAA4B,SAAoB,UAAmB,MAAa,GAAE,CAChF,KAAM,SAAiC,SACjC,OAAS,UAAA,aAAa,UAAA,gBAAgB,QAAS,WAAY,OAEjE,MAAK,QAAO,MAIL,OAAO,QAHL,GALX,QAAA,YAAA,YAWA,oBAA2B,SAAoB,UAAmB,MAAU,CAC1E,KAAM,SAAiC,SACjC,OAAS,UAAA,aAAa,UAAA,gBAAgB,QAAS,WAAY,OAEjE,GAAI,QAAO,MAIX,MAAI,QAAO,gBAAkB,OACpB,iCAGF,CACL,aAAa,OAAO,sDACpB,UAAA,cAAc,cAAc,OAAO,iBACnC,KAAK;GAfT,QAAA,WAAA,WAoBA,uBAAuB,MAAoB,YAAuB,GAAK,CACrE,MAAK,cACH,OAAM,OAAO,MAAM,MAAQ,YAEtB",
  "names": []
}
