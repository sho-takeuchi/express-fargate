{
  "version": 3,
  "sources": ["template.ts"],
  "sourcesContent": ["import * as path from 'path';\nimport { Stack, Stage } from '../../core';\nimport * as fs from 'fs-extra';\nimport { Match } from './match';\nimport { Matcher } from './matcher';\nimport { findConditions, hasCondition } from './private/conditions';\nimport { checkTemplateForCyclicDependencies } from './private/cyclic';\nimport { findMappings, hasMapping } from './private/mappings';\nimport { findOutputs, hasOutput } from './private/outputs';\nimport { findParameters, hasParameter } from './private/parameters';\nimport { countResources, findResources, hasResource, hasResourceProperties } from './private/resources';\nimport { Template as TemplateType } from './private/template';\n\n                                                                                                                                                                                                        \nexport class Template {\n\n                                                                                                                                                       \n  public static fromStack(stack: Stack): Template {\n    return new Template(toTemplate(stack));\n  }\n\n                                                                                                                                                                                                                \n  public static fromJSON(template: { [key: string] : any }): Template {\n    return new Template(template);\n  }\n\n                                                                                                                                                                   \n  public static fromString(template: string): Template {\n    return new Template(JSON.parse(template));\n  }\n\n  private readonly template: TemplateType;\n\n  private constructor(template: { [key: string]: any }) {\n    this.template = template as TemplateType;\n    checkTemplateForCyclicDependencies(this.template);\n  }\n\n                                                                         \n  public toJSON(): { [key: string]: any } {\n    return this.template;\n  }\n\n                                                                                                                                                                                                                 \n  public resourceCountIs(type: string, count: number): void {\n    const counted = countResources(this.template, type);\n    if (counted !== count) {\n      throw new Error(`Expected ${count} resources of type ${type} but found ${counted}`);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \n  public hasResourceProperties(type: string, props: any): void {\n    const matchError = hasResourceProperties(this.template, type, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  public hasResource(type: string, props: any): void {\n    const matchError = hasResource(this.template, type, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                              \n  public findResources(type: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findResources(this.template, type, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  public hasParameter(logicalId: string, props: any): void {\n    const matchError = hasParameter(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  public findParameters(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findParameters(this.template, logicalId, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  public hasOutput(logicalId: string, props: any): void {\n    const matchError = hasOutput(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  public findOutputs(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findOutputs(this.template, logicalId, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  public hasMapping(logicalId: string, props: any): void {\n    const matchError = hasMapping(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  public findMappings(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findMappings(this.template, logicalId, props);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n  public hasCondition(logicalId: string, props: any): void {\n    const matchError = hasCondition(this.template, logicalId, props);\n    if (matchError) {\n      throw new Error(matchError);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  public findConditions(logicalId: string, props: any = {}): { [key: string]: { [key: string]: any } } {\n    return findConditions(this.template, logicalId, props);\n  }\n\n                                                                                                                                                              \n  public templateMatches(expected: any): void {\n    const matcher = Matcher.isMatcher(expected) ? expected : Match.objectLike(expected);\n    const result = matcher.test(this.template);\n\n    if (result.hasFailed()) {\n      throw new Error([\n        'Template did not match as expected. The following mismatches were found:',\n        ...result.toHumanStrings().map(s => `\\t${s}`),\n      ].join('\\n'));\n    }\n  }\n}\n\nfunction toTemplate(stack: Stack): any {\n  const root = stack.node.root;\n  if (!Stage.isStage(root)) {\n    throw new Error('unexpected: all stacks must be part of a Stage or an App');\n  }\n\n  const assembly = root.synth();\n  if (stack.nestedStackParent) {\n    // if this is a nested stack (it has a parent), then just read the template as a string\n    return JSON.parse(fs.readFileSync(path.join(assembly.directory, stack.templateFile)).toString('utf-8'));\n  }\n  return assembly.getStackArtifact(stack.artifactId).template;\n}"],
  "mappings": "+MAAA,KAAA,QAAA,QACA,OAAA,QAAA,cACA,GAAA,QAAA,YACA,QAAA,QAAA,WACA,UAAA,QAAA,aACA,aAAA,QAAA,wBACA,SAAA,QAAA,oBACA,WAAA,QAAA,sBACA,UAAA,QAAA,qBACA,aAAA,QAAA,wBACA,YAAA,QAAA,uBAIA,cAAqB,CAmBnB,YAAoB,SAAgC,CAClD,KAAK,SAAW,SAChB,SAAA,mCAAmC,KAAK,gBAlB5B,WAAU,MAAY,yDAC3B,GAAI,UAAS,WAAW,cAInB,UAAS,SAAiC,CACtD,MAAO,IAAI,UAAS,gBAIR,YAAW,SAAgB,CACvC,MAAO,IAAI,UAAS,KAAK,MAAM,WAW1B,QAAM,CACX,MAAO,MAAK,SAIP,gBAAgB,KAAc,MAAa,CAChD,KAAM,SAAU,YAAA,eAAe,KAAK,SAAU,MAC9C,GAAI,UAAY,MACd,KAAM,IAAI,OAAM,YAAY,2BAA2B,kBAAkB,WAKtE,sBAAsB,KAAc,MAAU,CACnD,KAAM,YAAa,YAAA,sBAAsB,KAAK,SAAU,KAAM,OAC9D,GAAI,WACF,KAAM,IAAI,OAAM,YAKb,YAAY,KAAc,MAAU,CACzC,KAAM,YAAa,YAAA,YAAY,KAAK,SAAU,KAAM,OACpD,GAAI,WACF,KAAM,IAAI,OAAM,YAKb,cAAc,KAAc,MAAa,GAAE,CAChD,MAAO,aAAA,cAAc,KAAK,SAAU,KAAM,OAIrC,aAAa,UAAmB,MAAU,CAC/C,KAAM,YAAa,aAAA,aAAa,KAAK,SAAU,UAAW,OAC1D,GAAI,WACF,KAAM,IAAI,OAAM,YAKb,eAAe,UAAmB,MAAa,GAAE,CACtD,MAAO,cAAA,eAAe,KAAK,SAAU,UAAW,OAI3C,UAAU,UAAmB,MAAU,CAC5C,KAAM,YAAa,UAAA,UAAU,KAAK,SAAU,UAAW,OACvD,GAAI,WACF,KAAM,IAAI,OAAM,YAKb,YAAY,UAAmB,MAAa,GAAE,CACnD,MAAO,WAAA,YAAY,KAAK,SAAU,UAAW,OAIxC,WAAW,UAAmB,MAAU,CAC7C,KAAM,YAAa,WAAA,WAAW,KAAK,SAAU,UAAW,OACxD,GAAI,WACF,KAAM,IAAI,OAAM,YAKb,aAAa,UAAmB,MAAa,GAAE,CACpD,MAAO,YAAA,aAAa,KAAK,SAAU,UAAW,OAIzC,aAAa,UAAmB,MAAU,CAC/C,KAAM,YAAa,aAAA,aAAa,KAAK,SAAU,UAAW,OAC1D,GAAI,WACF,KAAM,IAAI,OAAM,YAKb,eAAe,UAAmB,MAAa,GAAE,CACtD,MAAO,cAAA,eAAe,KAAK,SAAU,UAAW,OAI3C,gBAAgB,SAAa,CAElC,KAAM,QAAS,AADC,WAAA,QAAQ,UAAU,UAAY,SAAW,QAAA,MAAM,WAAW,WACnD,KAAK,KAAK,UAEjC,GAAI,OAAO,YACT,KAAM,IAAI,OAAM,CACd,2EACA,GAAG,OAAO,iBAAiB,IAAI,GAAK,IAAK,MACzC,KAAK;KAvHb,QAAA,SAAA,qGA4HA,oBAAoB,MAAY,CAC9B,KAAM,MAAO,MAAM,KAAK,KACxB,GAAI,CAAC,OAAA,MAAM,QAAQ,MACjB,KAAM,IAAI,OAAM,4DAGlB,KAAM,UAAW,KAAK,QACtB,MAAI,OAAM,kBAED,KAAK,MAAM,GAAG,aAAa,KAAK,KAAK,SAAS,UAAW,MAAM,eAAe,SAAS,UAEzF,SAAS,iBAAiB,MAAM,YAAY",
  "names": []
}
