{
  "version": 3,
  "sources": ["lambda.ts"],
  "sourcesContent": ["import * as iam from '../../../aws-iam';\nimport * as lambda from '../../../aws-lambda';\nimport { Arn, ArnFormat, Duration, Lazy, Names, Stack } from '../../../core';\nimport { Construct } from 'constructs';\nimport { CfnAuthorizer } from '../apigateway.generated';\nimport { Authorizer, IAuthorizer } from '../authorizer';\nimport { IRestApi } from '../restapi';\n\n                                                     \nexport interface LambdaAuthorizerProps {\n                                                                                                                                                                                   \n  readonly authorizerName?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n  readonly handler: lambda.IFunction;\n\n                                                                                                                                                            \n  readonly resultsCacheTtl?: Duration;\n\n                                                                                                                                                                                                                                                                                                              \n  readonly assumeRole?: iam.IRole;\n}\n\nabstract class LambdaAuthorizer extends Authorizer implements IAuthorizer {\n\n  /**\n   * The id of the authorizer.\n   * @attribute\n   */\n  public abstract readonly authorizerId: string;\n\n  /**\n   * The ARN of the authorizer to be used in permission policies, such as IAM and resource-based grants.\n   */\n  public abstract readonly authorizerArn: string;\n\n                                                                       \n  protected readonly handler: lambda.IFunction;\n\n                                                                                                      \n  protected readonly role?: iam.IRole;\n\n  protected restApiId?: string;\n\n  protected constructor(scope: Construct, id: string, props: LambdaAuthorizerProps) {\n    super(scope, id);\n\n    this.handler = props.handler;\n    this.role = props.assumeRole;\n\n    if (props.resultsCacheTtl && props.resultsCacheTtl?.toSeconds() > 3600) {\n      throw new Error('Lambda authorizer property \\'resultsCacheTtl\\' must not be greater than 3600 seconds (1 hour)');\n    }\n  }\n\n  /**\n   * Attaches this authorizer to a specific REST API.\n   * @internal\n   */\n  public _attachToApi(restApi: IRestApi) {\n    if (this.restApiId && this.restApiId !== restApi.restApiId) {\n      throw new Error('Cannot attach authorizer to two different rest APIs');\n    }\n\n    this.restApiId = restApi.restApiId;\n  }\n\n                                                                                                             \n  protected setupPermissions() {\n    if (!this.role) {\n      this.handler.addPermission(`${Names.uniqueId(this)}:Permissions`, {\n        principal: new iam.ServicePrincipal('apigateway.amazonaws.com'),\n        sourceArn: this.authorizerArn,\n      });\n    } else if (this.role instanceof iam.Role) { // i.e. not imported\n      this.role.attachInlinePolicy(new iam.Policy(this, 'authorizerInvokePolicy', {\n        statements: [\n          new iam.PolicyStatement({\n            resources: [this.handler.functionArn],\n            actions: ['lambda:InvokeFunction'],\n          }),\n        ],\n      }));\n    }\n  }\n\n                                                                                                                                                                                        \n  protected lazyRestApiId() {\n    return Lazy.string({\n      produce: () => {\n        if (!this.restApiId) {\n          throw new Error(`Authorizer (${this.node.path}) must be attached to a RestApi`);\n        }\n        return this.restApiId;\n      },\n    });\n  }\n}\n\n                                         \nexport interface TokenAuthorizerProps extends LambdaAuthorizerProps {\n                                                                                                                                                                                                                                                   \n  readonly validationRegex?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly identitySource?: string;\n}\n\n                                                                                                                                                                                                                                                                          \nexport class TokenAuthorizer extends LambdaAuthorizer {\n\n  public readonly authorizerId: string;\n\n  public readonly authorizerArn: string;\n\n  constructor(scope: Construct, id: string, props: TokenAuthorizerProps) {\n    super(scope, id, props);\n\n    const restApiId = this.lazyRestApiId();\n    const resource = new CfnAuthorizer(this, 'Resource', {\n      name: props.authorizerName ?? Names.uniqueId(this),\n      restApiId,\n      type: 'TOKEN',\n      authorizerUri: lambdaAuthorizerArn(props.handler),\n      authorizerCredentials: props.assumeRole?.roleArn,\n      authorizerResultTtlInSeconds: props.resultsCacheTtl?.toSeconds(),\n      identitySource: props.identitySource || 'method.request.header.Authorization',\n      identityValidationExpression: props.validationRegex,\n    });\n\n    this.authorizerId = resource.ref;\n    this.authorizerArn = Stack.of(this).formatArn({\n      service: 'execute-api',\n      resource: restApiId,\n      resourceName: `authorizers/${this.authorizerId}`,\n    });\n\n    this.setupPermissions();\n  }\n}\n\n                                           \nexport interface RequestAuthorizerProps extends LambdaAuthorizerProps {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \n  readonly identitySources: string[];\n}\n\n                                                                                                                                                                                                                                                                                                               \nexport class RequestAuthorizer extends LambdaAuthorizer {\n\n  public readonly authorizerId: string;\n\n  public readonly authorizerArn: string;\n\n  constructor(scope: Construct, id: string, props: RequestAuthorizerProps) {\n    super(scope, id, props);\n\n    if ((props.resultsCacheTtl === undefined || props.resultsCacheTtl.toSeconds() !== 0) && props.identitySources.length === 0) {\n      throw new Error('At least one Identity Source is required for a REQUEST-based Lambda authorizer if caching is enabled.');\n    }\n\n    const restApiId = this.lazyRestApiId();\n    const resource = new CfnAuthorizer(this, 'Resource', {\n      name: props.authorizerName ?? Names.uniqueId(this),\n      restApiId,\n      type: 'REQUEST',\n      authorizerUri: lambdaAuthorizerArn(props.handler),\n      authorizerCredentials: props.assumeRole?.roleArn,\n      authorizerResultTtlInSeconds: props.resultsCacheTtl?.toSeconds(),\n      identitySource: props.identitySources.map(is => is.toString()).join(','),\n    });\n\n    this.authorizerId = resource.ref;\n    this.authorizerArn = Stack.of(this).formatArn({\n      service: 'execute-api',\n      resource: restApiId,\n      resourceName: `authorizers/${this.authorizerId}`,\n    });\n\n    this.setupPermissions();\n  }\n}\n\n/**\n * constructs the authorizerURIArn.\n */\nfunction lambdaAuthorizerArn(handler: lambda.IFunction) {\n  const { region, partition } = Arn.split( handler.functionArn, ArnFormat.COLON_RESOURCE_NAME);\n  return `arn:${partition}:apigateway:${region}:lambda:path/2015-03-31/functions/${handler.functionArn}/invocations`;\n}\n"],
  "mappings": "sPAAA,IAAA,QAAA,oBAEA,OAAA,QAAA,iBAEA,uBAAA,QAAA,2BACA,aAAA,QAAA,iBAkBA,8BAAwC,cAAA,UAAU,CAqBhD,YAAsB,MAAkB,GAAY,MAA4B,QAC9E,MAAM,MAAO,IAKb,GAHA,KAAK,QAAU,MAAM,QACrB,KAAK,KAAO,MAAM,WAEd,MAAM,iBAAmB,KAAA,MAAM,mBAAe,MAAA,KAAA,OAAA,OAAA,GAAE,aAAc,KAChE,KAAM,IAAI,OAAM,+FAQb,aAAa,QAAiB,CACnC,GAAI,KAAK,WAAa,KAAK,YAAc,QAAQ,UAC/C,KAAM,IAAI,OAAM,uDAGlB,KAAK,UAAY,QAAQ,UAIjB,kBAAgB,CACxB,AAAK,KAAK,KAKC,KAAK,eAAgB,KAAI,MAClC,KAAK,KAAK,mBAAmB,GAAI,KAAI,OAAO,KAAM,yBAA0B,CAC1E,WAAY,CACV,GAAI,KAAI,gBAAgB,CACtB,UAAW,CAAC,KAAK,QAAQ,aACzB,QAAS,CAAC,+BAThB,KAAK,QAAQ,cAAc,GAAG,OAAA,MAAM,SAAS,oBAAqB,CAChE,UAAW,GAAI,KAAI,iBAAiB,4BACpC,UAAW,KAAK,gBAeZ,eAAa,CACrB,MAAO,QAAA,KAAK,OAAO,CACjB,QAAS,IAAK,CACZ,GAAI,CAAC,KAAK,UACR,KAAM,IAAI,OAAM,eAAe,KAAK,KAAK,uCAE3C,MAAO,MAAK,cAgBpB,6BAAqC,iBAAgB,CAMnD,YAAY,MAAkB,GAAY,MAA2B,cACnE,MAAM,MAAO,GAAI,sFAEjB,KAAM,WAAY,KAAK,gBACjB,SAAW,GAAI,wBAAA,cAAc,KAAM,WAAY,CACnD,KAAI,IAAE,MAAM,kBAAc,MAAA,KAAA,OAAA,GAAI,OAAA,MAAM,SAAS,MAC7C,UACA,KAAM,QACN,cAAe,oBAAoB,MAAM,SACzC,sBAAqB,IAAE,MAAM,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,QACzC,6BAA4B,IAAE,MAAM,mBAAe,MAAA,KAAA,OAAA,OAAA,GAAE,YACrD,eAAgB,MAAM,gBAAkB,sCACxC,6BAA8B,MAAM,kBAGtC,KAAK,aAAe,SAAS,IAC7B,KAAK,cAAgB,OAAA,MAAM,GAAG,MAAM,UAAU,CAC5C,QAAS,cACT,SAAU,UACV,aAAc,eAAe,KAAK,iBAGpC,KAAK,oBA5BT,QAAA,gBAAA,8HAuCA,+BAAuC,iBAAgB,CAMrD,YAAY,MAAkB,GAAY,MAA6B,cACrE,MAAM,MAAO,GAAI,OAEjB,oFAAK,OAAM,kBAAoB,QAAa,MAAM,gBAAgB,cAAgB,IAAM,MAAM,gBAAgB,SAAW,EACvH,KAAM,IAAI,OAAM,yGAGlB,KAAM,WAAY,KAAK,gBACjB,SAAW,GAAI,wBAAA,cAAc,KAAM,WAAY,CACnD,KAAI,IAAE,MAAM,kBAAc,MAAA,KAAA,OAAA,GAAI,OAAA,MAAM,SAAS,MAC7C,UACA,KAAM,UACN,cAAe,oBAAoB,MAAM,SACzC,sBAAqB,IAAE,MAAM,cAAU,MAAA,KAAA,OAAA,OAAA,GAAE,QACzC,6BAA4B,IAAE,MAAM,mBAAe,MAAA,KAAA,OAAA,OAAA,GAAE,YACrD,eAAgB,MAAM,gBAAgB,IAAI,IAAM,GAAG,YAAY,KAAK,OAGtE,KAAK,aAAe,SAAS,IAC7B,KAAK,cAAgB,OAAA,MAAM,GAAG,MAAM,UAAU,CAC5C,QAAS,cACT,SAAU,UACV,aAAc,eAAe,KAAK,iBAGpC,KAAK,oBA/BT,QAAA,kBAAA,oIAsCA,6BAA6B,QAAyB,CACpD,KAAM,CAAE,OAAQ,WAAc,OAAA,IAAI,MAAO,QAAQ,YAAa,OAAA,UAAU,qBACxE,MAAO,OAAO,wBAAwB,2CAA2C,QAAQ",
  "names": []
}
