{
  "version": 3,
  "sources": ["step-scaling-action.ts"],
  "sourcesContent": ["import { Duration, Lazy } from '../../core';\nimport { Construct } from 'constructs';\nimport { IAutoScalingGroup } from './auto-scaling-group';\nimport { CfnScalingPolicy } from './autoscaling.generated';\n\n                                          \nexport interface StepScalingActionProps {\n                                       \n  readonly autoScalingGroup: IAutoScalingGroup;\n\n                                                                                                                                                                       \n  readonly cooldown?: Duration;\n\n                                                                                                                                       \n  readonly estimatedInstanceWarmup?: Duration;\n\n                                                                                               \n  readonly adjustmentType?: AdjustmentType;\n\n                                                                                                                                                                                                                                                                              \n  readonly minAdjustmentMagnitude?: number;\n\n                                                                                            \n  readonly metricAggregationType?: MetricAggregationType;\n}\n\n                                                                                                                                                                                                                                                                                                                 \nexport class StepScalingAction extends Construct {\n                                          \n  public readonly scalingPolicyArn: string;\n\n  private readonly adjustments = new Array<CfnScalingPolicy.StepAdjustmentProperty>();\n\n  constructor(scope: Construct, id: string, props: StepScalingActionProps) {\n    super(scope, id);\n\n    const resource = new CfnScalingPolicy(this, 'Resource', {\n      policyType: 'StepScaling',\n      autoScalingGroupName: props.autoScalingGroup.autoScalingGroupName,\n      cooldown: props.cooldown && props.cooldown.toSeconds().toString(),\n      estimatedInstanceWarmup: props.estimatedInstanceWarmup && props.estimatedInstanceWarmup.toSeconds(),\n      adjustmentType: props.adjustmentType,\n      minAdjustmentMagnitude: props.minAdjustmentMagnitude,\n      metricAggregationType: props.metricAggregationType,\n      stepAdjustments: Lazy.any({ produce: () => this.adjustments }),\n    });\n\n    this.scalingPolicyArn = resource.ref;\n  }\n\n                                                               \n  public addAdjustment(adjustment: AdjustmentTier) {\n    if (adjustment.lowerBound === undefined && adjustment.upperBound === undefined) {\n      throw new Error('At least one of lowerBound or upperBound is required');\n    }\n    this.adjustments.push({\n      metricIntervalLowerBound: adjustment.lowerBound,\n      metricIntervalUpperBound: adjustment.upperBound,\n      scalingAdjustment: adjustment.adjustment,\n    });\n  }\n}\n\n                                                 \nexport enum AdjustmentType {\n                                                                                                                                                         \n  CHANGE_IN_CAPACITY = 'ChangeInCapacity',\n\n                                                                                                                                                                                                        \n  PERCENT_CHANGE_IN_CAPACITY = 'PercentChangeInCapacity',\n\n                                                                   \n  EXACT_CAPACITY = 'ExactCapacity',\n}\n\n                                                           \nexport enum MetricAggregationType {\n                        \n  AVERAGE = 'Average',\n\n                        \n  MINIMUM = 'Minimum',\n\n                        \n  MAXIMUM = 'Maximum'\n}\n\n                        \nexport interface AdjustmentTier {\n                                                                                                                                                                                                                                                                              \n  readonly adjustment: number;\n\n                                                                                                                                                                                                                                                                                                         \n  readonly lowerBound?: number;\n\n                                                                                                                                                                                                                              \n  readonly upperBound?: number;\n}\n"],
  "mappings": "6QAAA,OAAA,QAAA,cACA,aAAA,QAAA,cAEA,wBAAA,QAAA,2BAwBA,+BAAuC,cAAA,SAAS,CAM9C,YAAY,MAAkB,GAAY,MAA6B,CACrE,MAAM,MAAO,IAHE,KAAA,YAAc,GAAI,yFAKjC,KAAM,UAAW,GAAI,yBAAA,iBAAiB,KAAM,WAAY,CACtD,WAAY,cACZ,qBAAsB,MAAM,iBAAiB,qBAC7C,SAAU,MAAM,UAAY,MAAM,SAAS,YAAY,WACvD,wBAAyB,MAAM,yBAA2B,MAAM,wBAAwB,YACxF,eAAgB,MAAM,eACtB,uBAAwB,MAAM,uBAC9B,sBAAuB,MAAM,sBAC7B,gBAAiB,OAAA,KAAK,IAAI,CAAE,QAAS,IAAM,KAAK,gBAGlD,KAAK,iBAAmB,SAAS,IAI5B,cAAc,WAA0B,CAC7C,kFAAI,WAAW,aAAe,QAAa,WAAW,aAAe,OACnE,KAAM,IAAI,OAAM,wDAElB,KAAK,YAAY,KAAK,CACpB,yBAA0B,WAAW,WACrC,yBAA0B,WAAW,WACrC,kBAAmB,WAAW,cA/BpC,QAAA,kBAAA,qIAqCA,GAAY,gBAAZ,AAAA,UAAY,gBAAc,CAExB,gBAAA,mBAAA,mBAGA,gBAAA,2BAAA,0BAGA,gBAAA,eAAA,kBARU,eAAA,QAAA,gBAAA,SAAA,eAAc,KAY1B,GAAY,uBAAZ,AAAA,UAAY,uBAAqB,CAE/B,uBAAA,QAAA,UAGA,uBAAA,QAAA,UAGA,uBAAA,QAAA,YARU,sBAAA,QAAA,uBAAA,SAAA,sBAAqB",
  "names": []
}
