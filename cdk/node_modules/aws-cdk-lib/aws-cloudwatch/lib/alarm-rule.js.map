{
  "version": 3,
  "sources": ["alarm-rule.ts"],
  "sourcesContent": ["import { IAlarm, IAlarmRule } from './alarm-base';\n\n                                                                            \nexport enum AlarmState {\n\n                                                     \n  ALARM = 'ALARM',\n\n                                                         \n  OK = 'OK',\n\n                                                                                              \n  INSUFFICIENT_DATA = 'INSUFFICIENT_DATA',\n\n}\n\n/**\n * Enumeration of supported Composite Alarms operators.\n */\nenum Operator {\n\n  AND = 'AND',\n  OR = 'OR',\n  NOT = 'NOT',\n\n}\n\n                                                                               \nexport class AlarmRule {\n\n                                                                                                                                                  \n  public static allOf(...operands: IAlarmRule[]): IAlarmRule {\n    return this.concat(Operator.AND, ...operands);\n  }\n\n                                                                                                                                                \n  public static anyOf(...operands: IAlarmRule[]): IAlarmRule {\n    return this.concat(Operator.OR, ...operands);\n  }\n\n                                                                                                                                        \n  public static not(operand: IAlarmRule): IAlarmRule {\n    return new class implements IAlarmRule {\n      public renderAlarmRule(): string {\n        return `(NOT (${operand.renderAlarmRule()}))`;\n      }\n    };\n  }\n\n                                                                                                                                             \n  public static fromBoolean(value: boolean): IAlarmRule {\n    return new class implements IAlarmRule {\n      public renderAlarmRule(): string {\n        return `${String(value).toUpperCase()}`;\n      }\n    };\n  }\n\n                                                                                                                                                                                                                 \n  public static fromAlarm(alarm: IAlarm, alarmState: AlarmState): IAlarmRule {\n    return new class implements IAlarmRule {\n      public renderAlarmRule(): string {\n        return `${alarmState}(\"${alarm.alarmArn}\")`;\n      }\n    };\n  }\n\n                                                                                                                                                \n  public static fromString(alarmRule: string): IAlarmRule {\n    return new class implements IAlarmRule {\n      public renderAlarmRule(): string {\n        return alarmRule;\n      }\n    };\n  }\n\n  private static concat(operator: Operator, ...operands: IAlarmRule[]): IAlarmRule {\n    return new class implements IAlarmRule {\n      public renderAlarmRule(): string {\n        const expression = operands\n          .map(operand => `${operand.renderAlarmRule()}`)\n          .join(` ${operator} `);\n        return `(${expression})`;\n      }\n    };\n  }\n}\n"],
  "mappings": "mOAGA,GAAY,YAAZ,AAAA,UAAY,YAAU,CAGpB,YAAA,MAAA,QAGA,YAAA,GAAA,KAGA,YAAA,kBAAA,sBATU,WAAA,QAAA,YAAA,SAAA,WAAU,KAgBtB,GAAK,UAAL,AAAA,UAAK,UAAQ,CAEX,UAAA,IAAA,MACA,UAAA,GAAA,KACA,UAAA,IAAA,QAJG,UAAA,UAAQ,KASb,eAAsB,OAGN,UAAS,SAAsB,gFACpC,KAAK,OAAO,SAAS,IAAK,GAAG,gBAIxB,UAAS,SAAsB,gFACpC,KAAK,OAAO,SAAS,GAAI,GAAG,gBAIvB,KAAI,QAAmB,+EAC5B,GAAI,MAAA,CACF,iBAAe,CACpB,MAAO,SAAS,QAAQ,8BAMhB,aAAY,MAAc,CACtC,MAAO,IAAI,MAAA,CACF,iBAAe,CACpB,MAAO,GAAG,OAAO,OAAO,wBAMhB,WAAU,MAAe,WAAsB,mJACpD,GAAI,MAAA,CACF,iBAAe,CACpB,MAAO,GAAG,eAAe,MAAM,qBAMvB,YAAW,UAAiB,CACxC,MAAO,IAAI,MAAA,CACF,iBAAe,CACpB,MAAO,mBAKE,QAAO,YAAuB,SAAsB,CACjE,MAAO,IAAI,MAAA,CACF,iBAAe,CAIpB,MAAO,IAHY,SAChB,IAAI,SAAW,GAAG,QAAQ,qBAC1B,KAAK,IAAI,mBArDpB,QAAA,UAAA",
  "names": []
}
