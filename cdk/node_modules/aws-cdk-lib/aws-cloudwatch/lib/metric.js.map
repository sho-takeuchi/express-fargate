{
  "version": 3,
  "sources": ["metric.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport * as cdk from '../../core';\nimport { Construct, IConstruct } from 'constructs';\nimport { Alarm, ComparisonOperator, TreatMissingData } from './alarm';\nimport { Dimension, IMetric, MetricAlarmConfig, MetricConfig, MetricGraphConfig, Unit } from './metric-types';\nimport { dispatchMetric, metricKey } from './private/metric-util';\nimport { normalizeStatistic, parseStatistic } from './private/statistic';\n\nexport type DimensionHash = {[dim: string]: any};\n\nexport type DimensionsMap = { [dim: string]: string };\n\n                                                                  \nexport interface CommonMetricOptions {\n                                                                                                                 \n  readonly period?: cdk.Duration;\n\n                                                                                                                                                                                                                                                                       \n  readonly statistic?: string;\n\n                                                                                                                                \n  readonly dimensions?: DimensionHash;\n\n                                                                             \n  readonly dimensionsMap?: DimensionsMap;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly unit?: Unit;\n\n                                                                                                    \n  readonly label?: string;\n\n                                                                                                                                                                                                                                   \n  readonly color?: string;\n\n                                                                                               \n  readonly account?: string;\n\n                                                                                             \n  readonly region?: string;\n}\n\n                                  \nexport interface MetricProps extends CommonMetricOptions {\n                                         \n  readonly namespace: string;\n\n                                    \n  readonly metricName: string;\n}\n\n                                                     \nexport interface MetricOptions extends CommonMetricOptions {\n}\n\n                                                   \nexport interface MathExpressionOptions {\n                                                                                                                                  \n  readonly label?: string;\n\n                                                                                                                \n  readonly color?: string;\n\n                                                                                                                                                                                                                    \n  readonly period?: cdk.Duration;\n\n                                                                                                                                                                                                                                                 \n  readonly searchAccount?: string;\n\n                                                                                                                                                                                                                                                    \n  readonly searchRegion?: string;\n}\n\n                                          \nexport interface MathExpressionProps extends MathExpressionOptions {\n                                                                                                                                                     \n  readonly expression: string;\n\n                                                                                                                                                                                                                                      \n  readonly usingMetrics?: Record<string, IMetric>;\n}\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \nexport class Metric implements IMetric {\n                                                                                                                                            \n  public static grantPutMetricData(grantee: iam.IGrantable): iam.Grant {\n    return iam.Grant.addToPrincipal({\n      grantee,\n      actions: ['cloudwatch:PutMetricData'],\n      resourceArns: ['*'],\n    });\n  }\n\n                                  \n  public readonly dimensions?: DimensionHash;\n                                 \n  public readonly namespace: string;\n                            \n  public readonly metricName: string;\n                              \n  public readonly period: cdk.Duration;\n                                 \n  public readonly statistic: string;\n                                                                   \n  public readonly label?: string;\n                                                                         \n  public readonly color?: string;\n\n                            \n  public readonly unit?: Unit;\n\n                                             \n  public readonly account?: string;\n\n                                             \n  public readonly region?: string;\n\n  constructor(props: MetricProps) {\n    this.period = props.period || cdk.Duration.minutes(5);\n    const periodSec = this.period.toSeconds();\n    if (periodSec !== 1 && periodSec !== 5 && periodSec !== 10 && periodSec !== 30 && periodSec % 60 !== 0) {\n      throw new Error(`'period' must be 1, 5, 10, 30, or a multiple of 60 seconds, received ${periodSec}`);\n    }\n    this.dimensions = this.validateDimensions(props.dimensionsMap ?? props.dimensions);\n    this.namespace = props.namespace;\n    this.metricName = props.metricName;\n    // Try parsing, this will throw if it's not a valid stat\n    this.statistic = normalizeStatistic(props.statistic || 'Average');\n    this.label = props.label;\n    this.color = props.color;\n    this.unit = props.unit;\n    this.account = props.account;\n    this.region = props.region;\n  }\n\n                                                                                                                                                                                                    \n  public with(props: MetricOptions): Metric {\n    // Short-circuit creating a new object if there would be no effective change\n    if ((props.label === undefined || props.label === this.label)\n      && (props.color === undefined || props.color === this.color)\n      && (props.statistic === undefined || props.statistic === this.statistic)\n      && (props.unit === undefined || props.unit === this.unit)\n      && (props.account === undefined || props.account === this.account)\n      && (props.region === undefined || props.region === this.region)\n      // For these we're not going to do deep equality, misses some opportunity for optimization\n      // but that's okay.\n      && (props.dimensions === undefined)\n      && (props.dimensionsMap === undefined)\n      && (props.period === undefined || props.period.toSeconds() === this.period.toSeconds())) {\n      return this;\n    }\n\n    return new Metric({\n      dimensionsMap: props.dimensionsMap ?? props.dimensions ?? this.dimensions,\n      namespace: this.namespace,\n      metricName: this.metricName,\n      period: ifUndefined(props.period, this.period),\n      statistic: ifUndefined(props.statistic, this.statistic),\n      unit: ifUndefined(props.unit, this.unit),\n      label: ifUndefined(props.label, this.label),\n      color: ifUndefined(props.color, this.color),\n      account: ifUndefined(props.account, this.account),\n      region: ifUndefined(props.region, this.region),\n    });\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  public attachTo(scope: IConstruct): Metric {\n    const stack = cdk.Stack.of(scope);\n\n    return this.with({\n      region: cdk.Token.isUnresolved(stack.region) ? undefined : stack.region,\n      account: cdk.Token.isUnresolved(stack.account) ? undefined : stack.account,\n    });\n  }\n\n  public toMetricConfig(): MetricConfig {\n    const dims = this.dimensionsAsList();\n    return {\n      metricStat: {\n        dimensions: dims.length > 0 ? dims : undefined,\n        namespace: this.namespace,\n        metricName: this.metricName,\n        period: this.period,\n        statistic: this.statistic,\n        unitFilter: this.unit,\n        account: this.account,\n        region: this.region,\n      },\n      renderingProperties: {\n        color: this.color,\n        label: this.label,\n      },\n    };\n  }\n\n                                         \n  public toAlarmConfig(): MetricAlarmConfig {\n    const metricConfig = this.toMetricConfig();\n    if (metricConfig.metricStat === undefined) {\n      throw new Error('Using a math expression is not supported here. Pass a \\'Metric\\' object instead');\n    }\n\n    const stat = parseStatistic(metricConfig.metricStat.statistic);\n    return {\n      dimensions: metricConfig.metricStat.dimensions,\n      namespace: metricConfig.metricStat.namespace,\n      metricName: metricConfig.metricStat.metricName,\n      period: metricConfig.metricStat.period.toSeconds(),\n      statistic: stat.type === 'simple' ? stat.statistic : undefined,\n      extendedStatistic: stat.type === 'percentile' ? 'p' + stat.percentile : undefined,\n      unit: this.unit,\n    };\n  }\n\n                                                 \n  public toGraphConfig(): MetricGraphConfig {\n    const metricConfig = this.toMetricConfig();\n    if (metricConfig.metricStat === undefined) {\n      throw new Error('Using a math expression is not supported here. Pass a \\'Metric\\' object instead');\n    }\n\n    return {\n      dimensions: metricConfig.metricStat.dimensions,\n      namespace: metricConfig.metricStat.namespace,\n      metricName: metricConfig.metricStat.metricName,\n      renderingProperties: {\n        period: metricConfig.metricStat.period.toSeconds(),\n        stat: metricConfig.metricStat.statistic,\n        color: asString(metricConfig.renderingProperties?.color),\n        label: asString(metricConfig.renderingProperties?.label),\n      },\n      // deprecated properties for backwards compatibility\n      period: metricConfig.metricStat.period.toSeconds(),\n      statistic: metricConfig.metricStat.statistic,\n      color: asString(metricConfig.renderingProperties?.color),\n      label: asString(metricConfig.renderingProperties?.label),\n      unit: this.unit,\n    };\n  }\n\n                                                                                                                                                               \n  public createAlarm(scope: Construct, id: string, props: CreateAlarmOptions): Alarm {\n    return new Alarm(scope, id, {\n      metric: this.with({\n        statistic: props.statistic,\n        period: props.period,\n      }),\n      alarmName: props.alarmName,\n      alarmDescription: props.alarmDescription,\n      comparisonOperator: props.comparisonOperator,\n      datapointsToAlarm: props.datapointsToAlarm,\n      threshold: props.threshold,\n      evaluationPeriods: props.evaluationPeriods,\n      evaluateLowSampleCountPercentile: props.evaluateLowSampleCountPercentile,\n      treatMissingData: props.treatMissingData,\n      actionsEnabled: props.actionsEnabled,\n    });\n  }\n\n  public toString() {\n    return this.label || this.metricName;\n  }\n\n  /**\n   * Return the dimensions of this Metric as a list of Dimension.\n   */\n  private dimensionsAsList(): Dimension[] {\n    const dims = this.dimensions;\n\n    if (dims === undefined) {\n      return [];\n    }\n\n    const list = Object.keys(dims).sort().map(key => ({ name: key, value: dims[key] }));\n\n    return list;\n  }\n\n  private validateDimensions(dims?: DimensionHash): DimensionHash | undefined {\n    if (!dims) {\n      return dims;\n    }\n\n    var dimsArray = Object.keys(dims);\n    if (dimsArray?.length > 10) {\n      throw new Error(`The maximum number of dimensions is 10, received ${dimsArray.length}`);\n    }\n\n    dimsArray.map(key => {\n      if (dims[key] === undefined || dims[key] === null) {\n        throw new Error(`Dimension value of '${dims[key]}' is invalid`);\n      };\n      if (key.length < 1 || key.length > 255) {\n        throw new Error(`Dimension name must be at least 1 and no more than 255 characters; received ${key}`);\n      };\n\n      if (dims[key].length < 1 || dims[key].length > 255) {\n        throw new Error(`Dimension value must be at least 1 and no more than 255 characters; received ${dims[key]}`);\n      };\n    });\n\n    return dims;\n  }\n}\n\nfunction asString(x?: unknown): string | undefined {\n  if (x === undefined) { return undefined; }\n  if (typeof x !== 'string') {\n    throw new Error(`Expected string, got ${x}`);\n  }\n  return x;\n}\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \nexport class MathExpression implements IMetric {\n                                                    \n  public readonly expression: string;\n\n                                                                                 \n  public readonly usingMetrics: Record<string, IMetric>;\n\n                                                             \n  public readonly label?: string;\n\n                                                                                                                                                                                                   \n  public readonly color?: string;\n\n                                                  \n  public readonly period: cdk.Duration;\n\n                                                               \n  public readonly searchAccount?: string;\n\n                                                              \n  public readonly searchRegion?: string;\n\n  constructor(props: MathExpressionProps) {\n    this.period = props.period || cdk.Duration.minutes(5);\n    this.expression = props.expression;\n    this.usingMetrics = changeAllPeriods(props.usingMetrics ?? {}, this.period);\n    this.label = props.label;\n    this.color = props.color;\n    this.searchAccount = props.searchAccount;\n    this.searchRegion = props.searchRegion;\n\n    const invalidVariableNames = Object.keys(this.usingMetrics).filter(x => !validVariableName(x));\n    if (invalidVariableNames.length > 0) {\n      throw new Error(`Invalid variable names in expression: ${invalidVariableNames}. Must start with lowercase letter and only contain alphanumerics.`);\n    }\n\n    this.validateNoIdConflicts();\n  }\n\n                                                                                                                                                                                                  \n  public with(props: MathExpressionOptions): MathExpression {\n    // Short-circuit creating a new object if there would be no effective change\n    if ((props.label === undefined || props.label === this.label)\n      && (props.color === undefined || props.color === this.color)\n      && (props.period === undefined || props.period.toSeconds() === this.period.toSeconds())\n      && (props.searchAccount === undefined || props.searchAccount === this.searchAccount)\n      && (props.searchRegion === undefined || props.searchRegion === this.searchRegion)) {\n      return this;\n    }\n\n    return new MathExpression({\n      expression: this.expression,\n      usingMetrics: this.usingMetrics,\n      label: ifUndefined(props.label, this.label),\n      color: ifUndefined(props.color, this.color),\n      period: ifUndefined(props.period, this.period),\n      searchAccount: ifUndefined(props.searchAccount, this.searchAccount),\n      searchRegion: ifUndefined(props.searchRegion, this.searchRegion),\n    });\n  }\n\n                                                 \n  public toAlarmConfig(): MetricAlarmConfig {\n    throw new Error('Using a math expression is not supported here. Pass a \\'Metric\\' object instead');\n  }\n\n                                                 \n  public toGraphConfig(): MetricGraphConfig {\n    throw new Error('Using a math expression is not supported here. Pass a \\'Metric\\' object instead');\n  }\n\n  public toMetricConfig(): MetricConfig {\n    return {\n      mathExpression: {\n        period: this.period.toSeconds(),\n        expression: this.expression,\n        usingMetrics: this.usingMetrics,\n        searchAccount: this.searchAccount,\n        searchRegion: this.searchRegion,\n      },\n      renderingProperties: {\n        label: this.label,\n        color: this.color,\n      },\n    };\n  }\n\n                                                                                                                                                               \n  public createAlarm(scope: Construct, id: string, props: CreateAlarmOptions): Alarm {\n    return new Alarm(scope, id, {\n      metric: this.with({\n        period: props.period,\n      }),\n      alarmName: props.alarmName,\n      alarmDescription: props.alarmDescription,\n      comparisonOperator: props.comparisonOperator,\n      datapointsToAlarm: props.datapointsToAlarm,\n      threshold: props.threshold,\n      evaluationPeriods: props.evaluationPeriods,\n      evaluateLowSampleCountPercentile: props.evaluateLowSampleCountPercentile,\n      treatMissingData: props.treatMissingData,\n      actionsEnabled: props.actionsEnabled,\n    });\n  }\n\n  public toString() {\n    return this.label || this.expression;\n  }\n\n  private validateNoIdConflicts() {\n    const seen = new Map<string, IMetric>();\n    visit(this);\n\n    function visit(metric: IMetric) {\n      dispatchMetric(metric, {\n        withStat() {\n          // Nothing\n        },\n        withExpression(expr) {\n          for (const [id, subMetric] of Object.entries(expr.usingMetrics)) {\n            const existing = seen.get(id);\n            if (existing && metricKey(existing) !== metricKey(subMetric)) {\n              throw new Error(`The ID '${id}' used for two metrics in the expression: '${subMetric}' and '${existing}'. Rename one.`);\n            }\n            seen.set(id, subMetric);\n            visit(subMetric);\n          }\n        },\n      });\n    }\n  }\n\n}\n\nconst VALID_VARIABLE = new RegExp('^[a-z][a-zA-Z0-9_]*$');\n\nfunction validVariableName(x: string) {\n  return VALID_VARIABLE.test(x);\n}\n\n                                                           \nexport interface CreateAlarmOptions {\n                                                                                                                                                                                                                                                                                  \n  readonly period?: cdk.Duration;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly statistic?: string;\n\n                                                                                  \n  readonly alarmName?: string;\n\n                                                                            \n  readonly alarmDescription?: string;\n\n                                                                                                                   \n  readonly comparisonOperator?: ComparisonOperator;\n\n                                                                             \n  readonly threshold: number;\n\n                                                                                              \n  readonly evaluationPeriods: number;\n\n                                                                                                                                                                                                                                                                   \n  readonly evaluateLowSampleCountPercentile?: string;\n\n                                                                                                                  \n  readonly treatMissingData?: TreatMissingData;\n\n                                                                                       \n  readonly actionsEnabled?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly datapointsToAlarm?: number;\n}\n\nfunction ifUndefined<T>(x: T | undefined, def: T | undefined): T | undefined {\n  if (x !== undefined) {\n    return x;\n  }\n  return def;\n}\n\n/**\n * Change periods of all metrics in the map\n */\nfunction changeAllPeriods(metrics: Record<string, IMetric>, period: cdk.Duration): Record<string, IMetric> {\n  const ret: Record<string, IMetric> = {};\n  for (const [id, metric] of Object.entries(metrics)) {\n    ret[id] = changePeriod(metric, period);\n  }\n  return ret;\n}\n\n/**\n * Return a new metric object which is the same type as the input object, but with the period changed\n *\n * Relies on the fact that implementations of `IMetric` are also supposed to have\n * an implementation of `with` that accepts an argument called `period`. See `IModifiableMetric`.\n */\nfunction changePeriod(metric: IMetric, period: cdk.Duration): IMetric {\n  if (isModifiableMetric(metric)) {\n    return metric.with({ period });\n  }\n\n  throw new Error(`Metric object should also implement 'with': ${metric}`);\n}\n\n/**\n * Private protocol for metrics\n *\n * Metric types used in a MathExpression need to implement at least this:\n * a `with` method that takes at least a `period` and returns a modified copy\n * of the metric object.\n *\n * We put it here instead of on `IMetric` because there is no way to type\n * it in jsii in a way that concrete implementations `Metric` and `MathExpression`\n * can be statically typable about the fields that are changeable: all\n * `with` methods would need to take the same argument type, but not all\n * classes have the same `with`-able properties.\n *\n * This class exists to prevent having to use `instanceof` in the `changePeriod`\n * function, so that we have a system where in principle new implementations\n * of `IMetric` can be added. Because it will be rare, the mechanism doesn't have\n * to be exposed very well, just has to be possible.\n */\ninterface IModifiableMetric {\n  with(options: { period?: cdk.Duration }): IMetric;\n}\n\nfunction isModifiableMetric(m: any): m is IModifiableMetric {\n  return typeof m === 'object' && m !== null && !!m.with;\n}\n"],
  "mappings": "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",
  "names": []
}
