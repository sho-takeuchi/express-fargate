{
  "version": 3,
  "sources": ["volume.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\n\nimport { AccountRootPrincipal, Grant, IGrantable } from '../../aws-iam';\nimport { IKey, ViaServicePrincipal } from '../../aws-kms';\nimport { IResource, Resource, Size, SizeRoundingBehavior, Stack, Token, Tags, Names, RemovalPolicy } from '../../core';\nimport { Construct } from 'constructs';\nimport { CfnVolume } from './ec2.generated';\nimport { IInstance } from './instance';\n\n                       \nexport interface BlockDevice {\n                                                                                                                                                                                                          \n  readonly deviceName: string;\n\n                                                                                                                                                                                                                            \n  readonly volume: BlockDeviceVolume;\n\n                                                                                                                                                                                                                                                                                                                                \n  readonly mappingEnabled?: boolean;\n}\n\n                                                      \nexport interface EbsDeviceOptionsBase {\n                                                                                                                                                                          \n  readonly deleteOnTermination?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  readonly iops?: number;\n\n                                                                                                                                                                         \n  readonly volumeType?: EbsDeviceVolumeType;\n}\n\n                                                 \nexport interface EbsDeviceOptions extends EbsDeviceOptionsBase {\n                                                                                                                                                                                                                                                                                                                \n  readonly encrypted?: boolean;\n}\n\n                                                                         \nexport interface EbsDeviceSnapshotOptions extends EbsDeviceOptionsBase {\n                                                                                                                                                                                           \n  readonly volumeSize?: number;\n}\n\n                                            \nexport interface EbsDeviceProps extends EbsDeviceSnapshotOptions {\n                                                                                                   \n  readonly snapshotId?: string;\n}\n\n                                                                                      \nexport class BlockDeviceVolume {\n                                                                                                                                                                         \n  public static ebs(volumeSize: number, options: EbsDeviceOptions = {}): BlockDeviceVolume {\n    return new this({ ...options, volumeSize });\n  }\n\n                                                                                                                                                                                                    \n  public static ebsFromSnapshot(snapshotId: string, options: EbsDeviceSnapshotOptions = {}): BlockDeviceVolume {\n    return new this({ ...options, snapshotId });\n  }\n\n                                                                                                                                                                                              \n  public static ephemeral(volumeIndex: number) {\n    if (volumeIndex < 0) {\n      throw new Error(`volumeIndex must be a number starting from 0, got \"${volumeIndex}\"`);\n    }\n\n    return new this(undefined, `ephemeral${volumeIndex}`);\n  }\n\n                                                                                             \n  protected constructor(public readonly ebsDevice?: EbsDeviceProps, public readonly virtualName?: string) {\n  }\n}\n\n                                                      \nexport enum EbsDeviceVolumeType {\n                         \n  STANDARD = 'standard',\n\n                                            \n  IO1 = 'io1',\n\n                                            \n  IO2 = 'io2',\n\n                                          \n  GP2 = 'gp2',\n\n                                          \n  GP3 = 'gp3',\n\n                                         \n  ST1 = 'st1',\n\n                         \n  SC1 = 'sc1',\n\n  /**\n   * General purpose SSD volume (GP2) that balances price and performance for a wide variety of workloads.\n   */\n  GENERAL_PURPOSE_SSD = GP2,\n\n  /**\n   * General purpose SSD volume (GP3) that balances price and performance for a wide variety of workloads.\n   */\n  GENERAL_PURPOSE_SSD_GP3 = GP3,\n\n  /**\n   * Highest-performance SSD volume (IO1) for mission-critical low-latency or high-throughput workloads.\n   */\n  PROVISIONED_IOPS_SSD = IO1,\n\n  /**\n   * Highest-performance SSD volume (IO2) for mission-critical low-latency or high-throughput workloads.\n   */\n  PROVISIONED_IOPS_SSD_IO2 = IO2,\n\n  /**\n   * Low-cost HDD volume designed for frequently accessed, throughput-intensive workloads.\n   */\n  THROUGHPUT_OPTIMIZED_HDD = ST1,\n\n  /**\n   * Lowest cost HDD volume designed for less frequently accessed workloads.\n   */\n  COLD_HDD = SC1,\n\n  /**\n   * Magnetic volumes are backed by magnetic drives and are suited for workloads where data is accessed infrequently, and scenarios where low-cost\n   * storage for small volume sizes is important.\n   */\n  MAGNETIC = STANDARD,\n}\n\n                                    \nexport interface IVolume extends IResource {\n                                                         \n  readonly volumeId: string;\n\n                                                                                               \n  readonly availabilityZone: string;\n\n                                                                                                             \n  readonly encryptionKey?: IKey;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n  grantAttachVolume(grantee: IGrantable, instances?: IInstance[]): Grant;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  grantAttachVolumeByResourceTag(grantee: IGrantable, constructs: Construct[], tagKeySuffix?: string): Grant;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  grantDetachVolume(grantee: IGrantable, instances?: IInstance[]): Grant;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n  grantDetachVolumeByResourceTag(grantee: IGrantable, constructs: Construct[], tagKeySuffix?: string): Grant;\n}\n\n                                      \nexport interface VolumeProps {\n                                                                                                                                                                     \n  readonly volumeName?: string;\n\n                                                                     \n  readonly availabilityZone: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                \n  readonly size?: Size;\n\n                                                                                                                                                                                        \n  readonly snapshotId?: string;\n\n                                                                                                                                                                                                                                                                                   \n  readonly enableMultiAttach?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \n  readonly encrypted?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly encryptionKey?: IKey;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly autoEnableIo?: boolean;\n\n                                                                                                                                                               \n  readonly volumeType?: EbsDeviceVolumeType;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            \n  readonly iops?: number;\n\n                                                                                                                  \n  readonly removalPolicy?: RemovalPolicy;\n}\n\n                                                                               \nexport interface VolumeAttributes {\n                                    \n  readonly volumeId: string;\n\n                                                                                               \n  readonly availabilityZone: string;\n\n                                                                                                                                                                                          \n  readonly encryptionKey?: IKey;\n}\n\n/**\n * Common behavior of Volumes. Users should not use this class directly, and instead use ``Volume``.\n */\nabstract class VolumeBase extends Resource implements IVolume {\n  public abstract readonly volumeId: string;\n  public abstract readonly availabilityZone: string;\n  public abstract readonly encryptionKey?: IKey;\n\n  public grantAttachVolume(grantee: IGrantable, instances?: IInstance[]): Grant {\n    const result = Grant.addToPrincipal({\n      grantee,\n      actions: ['ec2:AttachVolume'],\n      resourceArns: this.collectGrantResourceArns(instances),\n    });\n\n    if (this.encryptionKey) {\n      // When attaching a volume, the EC2 Service will need to grant to itself permission\n      // to be able to decrypt the encryption key. We restrict the CreateGrant for principle\n      // of least privilege, in accordance with best practices.\n      // See: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#ebs-encryption-permissions\n      const kmsGrant: Grant = this.encryptionKey.grant(grantee, 'kms:CreateGrant');\n      kmsGrant.principalStatement!.addConditions(\n        {\n          Bool: { 'kms:GrantIsForAWSResource': true },\n          StringEquals: {\n            'kms:ViaService': `ec2.${Stack.of(this).region}.amazonaws.com`,\n            'kms:GrantConstraintType': 'EncryptionContextSubset',\n          },\n        },\n      );\n    }\n\n    return result;\n  }\n\n  public grantAttachVolumeByResourceTag(grantee: IGrantable, constructs: Construct[], tagKeySuffix?: string): Grant {\n    const tagValue = this.calculateResourceTagValue([this, ...constructs]);\n    const tagKey = `VolumeGrantAttach-${tagKeySuffix ?? tagValue.slice(0, 10).toUpperCase()}`;\n    const grantCondition: { [key: string]: string } = {};\n    grantCondition[`ec2:ResourceTag/${tagKey}`] = tagValue;\n\n    const result = this.grantAttachVolume(grantee);\n    result.principalStatement!.addCondition(\n      'ForAnyValue:StringEquals', grantCondition,\n    );\n\n    // The ResourceTag condition requires that all resources involved in the operation have\n    // the given tag, so we tag this and all constructs given.\n    Tags.of(this).add(tagKey, tagValue);\n    constructs.forEach(construct => Tags.of(construct).add(tagKey, tagValue));\n\n    return result;\n  }\n\n  public grantDetachVolume(grantee: IGrantable, instances?: IInstance[]): Grant {\n    const result = Grant.addToPrincipal({\n      grantee,\n      actions: ['ec2:DetachVolume'],\n      resourceArns: this.collectGrantResourceArns(instances),\n    });\n    // Note: No encryption key permissions are required to detach an encrypted volume.\n    return result;\n  }\n\n  public grantDetachVolumeByResourceTag(grantee: IGrantable, constructs: Construct[], tagKeySuffix?: string): Grant {\n    const tagValue = this.calculateResourceTagValue([this, ...constructs]);\n    const tagKey = `VolumeGrantDetach-${tagKeySuffix ?? tagValue.slice(0, 10).toUpperCase()}`;\n    const grantCondition: { [key: string]: string } = {};\n    grantCondition[`ec2:ResourceTag/${tagKey}`] = tagValue;\n\n    const result = this.grantDetachVolume(grantee);\n    result.principalStatement!.addCondition(\n      'ForAnyValue:StringEquals', grantCondition,\n    );\n\n    // The ResourceTag condition requires that all resources involved in the operation have\n    // the given tag, so we tag this and all constructs given.\n    Tags.of(this).add(tagKey, tagValue);\n    constructs.forEach(construct => Tags.of(construct).add(tagKey, tagValue));\n\n    return result;\n  }\n\n  private collectGrantResourceArns(instances?: IInstance[]): string[] {\n    const stack = Stack.of(this);\n    const resourceArns: string[] = [\n      `arn:${stack.partition}:ec2:${stack.region}:${stack.account}:volume/${this.volumeId}`,\n    ];\n    const instanceArnPrefix = `arn:${stack.partition}:ec2:${stack.region}:${stack.account}:instance`;\n    if (instances) {\n      instances.forEach(instance => resourceArns.push(`${instanceArnPrefix}/${instance?.instanceId}`));\n    } else {\n      resourceArns.push(`${instanceArnPrefix}/*`);\n    }\n    return resourceArns;\n  }\n\n  private calculateResourceTagValue(constructs: Construct[]): string {\n    const md5 = crypto.createHash('md5');\n    constructs.forEach(construct => md5.update(Names.uniqueId(construct)));\n    return md5.digest('hex');\n  }\n}\n\n                                               \nexport class Volume extends VolumeBase {\n                                                                                                                                                                                                                                             \n  public static fromVolumeAttributes(scope: Construct, id: string, attrs: VolumeAttributes): IVolume {\n    class Import extends VolumeBase {\n      public readonly volumeId = attrs.volumeId;\n      public readonly availabilityZone = attrs.availabilityZone;\n      public readonly encryptionKey = attrs.encryptionKey;\n    }\n    // Check that the provided volumeId looks like it could be valid.\n    if (!Token.isUnresolved(attrs.volumeId) && !/^vol-[0-9a-fA-F]+$/.test(attrs.volumeId)) {\n      throw new Error('`volumeId` does not match expected pattern. Expected `vol-<hexadecmial value>` (ex: `vol-05abe246af`) or a Token');\n    }\n    return new Import(scope, id);\n  }\n\n  public readonly volumeId: string;\n  public readonly availabilityZone: string;\n  public readonly encryptionKey?: IKey;\n\n  constructor(scope: Construct, id: string, props: VolumeProps) {\n    super(scope, id, {\n      physicalName: props.volumeName,\n    });\n\n    this.validateProps(props);\n\n    const resource = new CfnVolume(this, 'Resource', {\n      availabilityZone: props.availabilityZone,\n      autoEnableIo: props.autoEnableIo,\n      encrypted: props.encrypted,\n      kmsKeyId: props.encryptionKey?.keyArn,\n      iops: props.iops,\n      multiAttachEnabled: props.enableMultiAttach ?? false,\n      size: props.size?.toGibibytes({ rounding: SizeRoundingBehavior.FAIL }),\n      snapshotId: props.snapshotId,\n      volumeType: props.volumeType ?? EbsDeviceVolumeType.GENERAL_PURPOSE_SSD,\n    });\n    resource.applyRemovalPolicy(props.removalPolicy);\n\n    if (props.volumeName) Tags.of(resource).add('Name', props.volumeName);\n\n    this.volumeId = resource.ref;\n    this.availabilityZone = props.availabilityZone;\n    this.encryptionKey = props.encryptionKey;\n\n    if (this.encryptionKey) {\n      // Per: https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#ebs-encryption-requirements\n      const principal =\n        new ViaServicePrincipal(`ec2.${Stack.of(this).region}.amazonaws.com`, new AccountRootPrincipal()).withConditions({\n          StringEquals: {\n            'kms:CallerAccount': Stack.of(this).account,\n          },\n        });\n      const grant = this.encryptionKey.grant(principal,\n        // Describe & Generate are required to be able to create the CMK-encrypted Volume.\n        'kms:DescribeKey',\n        'kms:GenerateDataKeyWithoutPlainText',\n      );\n      if (props.snapshotId) {\n        // ReEncrypt is required for when re-encrypting from an encrypted snapshot.\n        grant.principalStatement?.addActions('kms:ReEncrypt*');\n      }\n    }\n  }\n\n  protected validateProps(props: VolumeProps) {\n    if (!(props.size || props.snapshotId)) {\n      throw new Error('Must provide at least one of `size` or `snapshotId`');\n    }\n\n    if (props.snapshotId && !Token.isUnresolved(props.snapshotId) && !/^snap-[0-9a-fA-F]+$/.test(props.snapshotId)) {\n      throw new Error('`snapshotId` does match expected pattern. Expected `snap-<hexadecmial value>` (ex: `snap-05abe246af`) or Token');\n    }\n\n    if (props.encryptionKey && !props.encrypted) {\n      throw new Error('`encrypted` must be true when providing an `encryptionKey`.');\n    }\n\n    if (\n      props.volumeType &&\n      [\n        EbsDeviceVolumeType.PROVISIONED_IOPS_SSD,\n        EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2,\n      ].includes(props.volumeType) &&\n      !props.iops\n    ) {\n      throw new Error(\n        '`iops` must be specified if the `volumeType` is `PROVISIONED_IOPS_SSD` or `PROVISIONED_IOPS_SSD_IO2`.',\n      );\n    }\n\n    if (props.iops) {\n      const volumeType = props.volumeType ?? EbsDeviceVolumeType.GENERAL_PURPOSE_SSD;\n      if (\n        ![\n          EbsDeviceVolumeType.PROVISIONED_IOPS_SSD,\n          EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2,\n          EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3,\n        ].includes(volumeType)\n      ) {\n        throw new Error(\n          '`iops` may only be specified if the `volumeType` is `PROVISIONED_IOPS_SSD`, `PROVISIONED_IOPS_SSD_IO2` or `GENERAL_PURPOSE_SSD_GP3`.',\n        );\n      }\n      // Enforce minimum & maximum IOPS:\n      // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html\n      const iopsRanges: { [key: string]: { Min: number, Max: number } } = {};\n      iopsRanges[EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3] = { Min: 3000, Max: 16000 };\n      iopsRanges[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD] = { Min: 100, Max: 64000 };\n      iopsRanges[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2] = { Min: 100, Max: 64000 };\n      const { Min, Max } = iopsRanges[volumeType];\n      if (props.iops < Min || props.iops > Max) {\n        throw new Error(`\\`${volumeType}\\` volumes iops must be between ${Min} and ${Max}.`);\n      }\n\n      // Enforce maximum ratio of IOPS/GiB:\n      // https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-volume-types.html\n      const maximumRatios: { [key: string]: number } = {};\n      maximumRatios[EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3] = 500;\n      maximumRatios[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD] = 50;\n      maximumRatios[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2] = 500;\n      const maximumRatio = maximumRatios[volumeType];\n      if (props.size && (props.iops > maximumRatio * props.size.toGibibytes({ rounding: SizeRoundingBehavior.FAIL }))) {\n        throw new Error(`\\`${volumeType}\\` volumes iops has a maximum ratio of ${maximumRatio} IOPS/GiB.`);\n      }\n    }\n\n    if (props.enableMultiAttach) {\n      const volumeType = props.volumeType ?? EbsDeviceVolumeType.GENERAL_PURPOSE_SSD;\n      if (\n        ![\n          EbsDeviceVolumeType.PROVISIONED_IOPS_SSD,\n          EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2,\n        ].includes(volumeType)\n      ) {\n        throw new Error('multi-attach is supported exclusively on `PROVISIONED_IOPS_SSD` and `PROVISIONED_IOPS_SSD_IO2` volumes.');\n      }\n    }\n\n    if (props.size) {\n      const size = props.size.toGibibytes({ rounding: SizeRoundingBehavior.FAIL });\n      // Enforce minimum & maximum volume size:\n      // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-ebs-volume.html\n      const sizeRanges: { [key: string]: { Min: number, Max: number } } = {};\n      sizeRanges[EbsDeviceVolumeType.GENERAL_PURPOSE_SSD] = { Min: 1, Max: 16384 };\n      sizeRanges[EbsDeviceVolumeType.GENERAL_PURPOSE_SSD_GP3] = { Min: 1, Max: 16384 };\n      sizeRanges[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD] = { Min: 4, Max: 16384 };\n      sizeRanges[EbsDeviceVolumeType.PROVISIONED_IOPS_SSD_IO2] = { Min: 4, Max: 16384 };\n      sizeRanges[EbsDeviceVolumeType.THROUGHPUT_OPTIMIZED_HDD] = { Min: 125, Max: 16384 };\n      sizeRanges[EbsDeviceVolumeType.COLD_HDD] = { Min: 125, Max: 16384 };\n      sizeRanges[EbsDeviceVolumeType.MAGNETIC] = { Min: 1, Max: 1024 };\n      const volumeType = props.volumeType ?? EbsDeviceVolumeType.GENERAL_PURPOSE_SSD;\n      const { Min, Max } = sizeRanges[volumeType];\n      if (size < Min || size > Max) {\n        throw new Error(`\\`${volumeType}\\` volumes must be between ${Min} GiB and ${Max} GiB in size.`);\n      }\n    }\n  }\n}\n"],
  "mappings": "sQAAA,OAAA,QAAA,UAEA,UAAA,QAAA,iBACA,UAAA,QAAA,iBACA,OAAA,QAAA,cAEA,gBAAA,QAAA,mBA8CA,uBAA8B,CAqB5B,YAAsC,UAA4C,YAAoB,CAAhE,KAAA,UAAA,UAA4C,KAAA,YAAA,wFAnBpE,KAAI,WAAoB,QAA4B,GAAE,8EAC3D,GAAI,MAAK,IAAK,QAAS,mBAIlB,iBAAgB,WAAoB,QAAoC,GAAE,sFAC/E,GAAI,MAAK,IAAK,QAAS,mBAIlB,WAAU,YAAmB,CACzC,GAAI,YAAc,EAChB,KAAM,IAAI,OAAM,sDAAsD,gBAGxE,MAAO,IAAI,MAAK,OAAW,YAAY,gBAjB3C,QAAA,kBAAA,6HA0BA,GAAY,qBAAZ,AAAA,UAAY,qBAAmB,CAE7B,qBAAA,SAAA,WAGA,qBAAA,IAAA,MAGA,qBAAA,IAAA,MAGA,qBAAA,IAAA,MAGA,qBAAA,IAAA,MAGA,qBAAA,IAAA,MAGA,qBAAA,IAAA,MAKA,qBAAA,oBAAA,MAKA,qBAAA,wBAAA,MAKA,qBAAA,qBAAA,MAKA,qBAAA,yBAAA,MAKA,qBAAA,yBAAA,MAKA,qBAAA,SAAA,MAMA,qBAAA,SAAA,aAxDU,oBAAA,QAAA,qBAAA,SAAA,oBAAmB,KAsI/B,wBAAkC,QAAA,QAAQ,CAKjC,kBAAkB,QAAqB,UAAuB,CACnE,KAAM,QAAS,UAAA,MAAM,eAAe,CAClC,QACA,QAAS,CAAC,oBACV,aAAc,KAAK,yBAAyB,aAG9C,MAAI,MAAK,eAMP,AADwB,KAAK,cAAc,MAAM,QAAS,mBACjD,mBAAoB,cAC3B,CACE,KAAM,CAAE,4BAA6B,IACrC,aAAc,CACZ,iBAAkB,OAAO,OAAA,MAAM,GAAG,MAAM,uBACxC,0BAA2B,6BAM5B,OAGF,+BAA+B,QAAqB,WAAyB,aAAqB,CACvG,KAAM,UAAW,KAAK,0BAA0B,CAAC,KAAM,GAAG,aACpD,OAAS,qBAAqB,cAAY,KAAZ,aAAgB,SAAS,MAAM,EAAG,IAAI,gBACpE,eAA4C,GAClD,eAAe,mBAAmB,UAAY,SAE9C,KAAM,QAAS,KAAK,kBAAkB,SACtC,cAAO,mBAAoB,aACzB,2BAA4B,gBAK9B,OAAA,KAAK,GAAG,MAAM,IAAI,OAAQ,UAC1B,WAAW,QAAQ,WAAa,OAAA,KAAK,GAAG,WAAW,IAAI,OAAQ,WAExD,OAGF,kBAAkB,QAAqB,UAAuB,CAOnE,MANe,WAAA,MAAM,eAAe,CAClC,QACA,QAAS,CAAC,oBACV,aAAc,KAAK,yBAAyB,aAMzC,+BAA+B,QAAqB,WAAyB,aAAqB,CACvG,KAAM,UAAW,KAAK,0BAA0B,CAAC,KAAM,GAAG,aACpD,OAAS,qBAAqB,cAAY,KAAZ,aAAgB,SAAS,MAAM,EAAG,IAAI,gBACpE,eAA4C,GAClD,eAAe,mBAAmB,UAAY,SAE9C,KAAM,QAAS,KAAK,kBAAkB,SACtC,cAAO,mBAAoB,aACzB,2BAA4B,gBAK9B,OAAA,KAAK,GAAG,MAAM,IAAI,OAAQ,UAC1B,WAAW,QAAQ,WAAa,OAAA,KAAK,GAAG,WAAW,IAAI,OAAQ,WAExD,OAGD,yBAAyB,UAAuB,CACtD,KAAM,OAAQ,OAAA,MAAM,GAAG,MACjB,aAAyB,CAC7B,OAAO,MAAM,iBAAiB,MAAM,UAAU,MAAM,kBAAkB,KAAK,YAEvE,kBAAoB,OAAO,MAAM,iBAAiB,MAAM,UAAU,MAAM,mBAC9E,MAAI,WACF,UAAU,QAAQ,UAAY,aAAa,KAAK,GAAG,qBAAqB,UAAQ,KAAA,OAAR,SAAU,eAElF,aAAa,KAAK,GAAG,uBAEhB,aAGD,0BAA0B,WAAuB,CACvD,KAAM,KAAM,OAAO,WAAW,OAC9B,kBAAW,QAAQ,WAAa,IAAI,OAAO,OAAA,MAAM,SAAS,aACnD,IAAI,OAAO,QAKtB,oBAA4B,WAAU,CAmBpC,YAAY,MAAkB,GAAY,MAAkB,oBAC1D,MAAM,MAAO,GAAI,CACf,aAAc,MAAM,4EAGtB,KAAK,cAAc,OAEnB,KAAM,UAAW,GAAI,iBAAA,UAAU,KAAM,WAAY,CAC/C,iBAAkB,MAAM,iBACxB,aAAc,MAAM,aACpB,UAAW,MAAM,UACjB,SAAQ,IAAE,MAAM,iBAAa,MAAA,KAAA,OAAA,OAAA,GAAE,OAC/B,KAAM,MAAM,KACZ,mBAAkB,IAAE,MAAM,qBAAiB,MAAA,KAAA,OAAA,GAAI,GAC/C,KAAI,IAAE,MAAM,QAAI,MAAA,KAAA,OAAA,OAAA,GAAE,YAAY,CAAE,SAAU,OAAA,qBAAqB,OAC/D,WAAY,MAAM,WAClB,WAAU,IAAE,MAAM,cAAU,MAAA,KAAA,OAAA,GAAI,oBAAoB,sBAUtD,GARA,SAAS,mBAAmB,MAAM,eAE9B,MAAM,YAAY,OAAA,KAAK,GAAG,UAAU,IAAI,OAAQ,MAAM,YAE1D,KAAK,SAAW,SAAS,IACzB,KAAK,iBAAmB,MAAM,iBAC9B,KAAK,cAAgB,MAAM,cAEvB,KAAK,cAAe,CAEtB,KAAM,WACJ,GAAI,WAAA,oBAAoB,OAAO,OAAA,MAAM,GAAG,MAAM,uBAAwB,GAAI,WAAA,sBAAwB,eAAe,CAC/G,aAAc,CACZ,oBAAqB,OAAA,MAAM,GAAG,MAAM,WAGpC,MAAQ,KAAK,cAAc,MAAM,UAErC,kBACA,uCAEF,AAAI,MAAM,YAER,KAAA,MAAM,sBAAkB,MAAA,KAAA,QAAA,GAAE,WAAW,0BA1D7B,sBAAqB,MAAkB,GAAY,MAAuB,qEACtF,oBAAqB,WAAU,CAA/B,aAAA,qBACkB,KAAA,SAAW,MAAM,SACjB,KAAA,iBAAmB,MAAM,iBACzB,KAAA,cAAgB,MAAM,eAGxC,GAAI,CAAC,OAAA,MAAM,aAAa,MAAM,WAAa,CAAC,qBAAqB,KAAK,MAAM,UAC1E,KAAM,IAAI,OAAM,oHAElB,MAAO,IAAI,QAAO,MAAO,IAqDjB,cAAc,MAAkB,cACxC,kEAAI,CAAE,OAAM,MAAQ,MAAM,YACxB,KAAM,IAAI,OAAM,uDAGlB,GAAI,MAAM,YAAc,CAAC,OAAA,MAAM,aAAa,MAAM,aAAe,CAAC,sBAAsB,KAAK,MAAM,YACjG,KAAM,IAAI,OAAM,kHAGlB,GAAI,MAAM,eAAiB,CAAC,MAAM,UAChC,KAAM,IAAI,OAAM,+DAGlB,GACE,MAAM,YACN,CACE,oBAAoB,qBACpB,oBAAoB,0BACpB,SAAS,MAAM,aACjB,CAAC,MAAM,KAEP,KAAM,IAAI,OACR,yGAIJ,GAAI,MAAM,KAAM,CACd,KAAM,YAAU,IAAG,MAAM,cAAU,MAAA,KAAA,OAAA,GAAI,oBAAoB,oBAC3D,GACE,CAAC,CACC,oBAAoB,qBACpB,oBAAoB,yBACpB,oBAAoB,yBACpB,SAAS,YAEX,KAAM,IAAI,OACR,wIAKJ,KAAM,YAA8D,GACpE,WAAW,oBAAoB,yBAA2B,CAAE,IAAK,IAAM,IAAK,MAC5E,WAAW,oBAAoB,sBAAwB,CAAE,IAAK,IAAK,IAAK,MACxE,WAAW,oBAAoB,0BAA4B,CAAE,IAAK,IAAK,IAAK,MAC5E,KAAM,CAAE,IAAK,KAAQ,WAAW,YAChC,GAAI,MAAM,KAAO,KAAO,MAAM,KAAO,IACnC,KAAM,IAAI,OAAM,KAAK,6CAA6C,WAAW,QAK/E,KAAM,eAA2C,GACjD,cAAc,oBAAoB,yBAA2B,IAC7D,cAAc,oBAAoB,sBAAwB,GAC1D,cAAc,oBAAoB,0BAA4B,IAC9D,KAAM,cAAe,cAAc,YACnC,GAAI,MAAM,MAAS,MAAM,KAAO,aAAe,MAAM,KAAK,YAAY,CAAE,SAAU,OAAA,qBAAqB,OACrG,KAAM,IAAI,OAAM,KAAK,oDAAoD,0BAI7E,GAAI,MAAM,kBAAmB,CAC3B,KAAM,YAAU,IAAG,MAAM,cAAU,MAAA,KAAA,OAAA,GAAI,oBAAoB,oBAC3D,GACE,CAAC,CACC,oBAAoB,qBACpB,oBAAoB,0BACpB,SAAS,YAEX,KAAM,IAAI,OAAM,2GAIpB,GAAI,MAAM,KAAM,CACd,KAAM,MAAO,MAAM,KAAK,YAAY,CAAE,SAAU,OAAA,qBAAqB,OAG/D,WAA8D,GACpE,WAAW,oBAAoB,qBAAuB,CAAE,IAAK,EAAG,IAAK,OACrE,WAAW,oBAAoB,yBAA2B,CAAE,IAAK,EAAG,IAAK,OACzE,WAAW,oBAAoB,sBAAwB,CAAE,IAAK,EAAG,IAAK,OACtE,WAAW,oBAAoB,0BAA4B,CAAE,IAAK,EAAG,IAAK,OAC1E,WAAW,oBAAoB,0BAA4B,CAAE,IAAK,IAAK,IAAK,OAC5E,WAAW,oBAAoB,UAAY,CAAE,IAAK,IAAK,IAAK,OAC5D,WAAW,oBAAoB,UAAY,CAAE,IAAK,EAAG,IAAK,MAC1D,KAAM,YAAU,IAAG,MAAM,cAAU,MAAA,KAAA,OAAA,GAAI,oBAAoB,oBACrD,CAAE,IAAK,KAAQ,WAAW,YAChC,GAAI,KAAO,KAAO,KAAO,IACvB,KAAM,IAAI,OAAM,KAAK,wCAAwC,eAAe,sBA1JpF,QAAA,OAAA",
  "names": []
}
