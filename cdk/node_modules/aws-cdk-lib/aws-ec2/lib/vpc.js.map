{
  "version": 3,
  "sources": ["vpc.ts"],
  "sourcesContent": ["import * as cxschema from '../../cloud-assembly-schema';\nimport {\n  Arn, Annotations, ContextProvider,\n  IResource, Lazy, Resource, Stack, Token, Tags, Names,\n} from '../../core';\nimport * as cxapi from '../../cx-api';\nimport { Construct, Dependable, DependencyGroup, IConstruct, IDependable, Node } from 'constructs';\nimport { ClientVpnEndpoint, ClientVpnEndpointOptions } from './client-vpn-endpoint';\nimport {\n  CfnEIP, CfnInternetGateway, CfnNatGateway, CfnRoute, CfnRouteTable, CfnSubnet,\n  CfnSubnetRouteTableAssociation, CfnVPC, CfnVPCGatewayAttachment, CfnVPNGatewayRoutePropagation,\n} from './ec2.generated';\nimport { NatProvider } from './nat';\nimport { INetworkAcl, NetworkAcl, SubnetNetworkAclAssociation } from './network-acl';\nimport { NetworkBuilder } from './network-util';\nimport { SubnetFilter } from './subnet';\nimport { allRouteTableIds, defaultSubnetName, flatten, ImportSubnetGroup, subnetGroupNameFromConstructId, subnetId } from './util';\nimport { GatewayVpcEndpoint, GatewayVpcEndpointAwsService, GatewayVpcEndpointOptions, InterfaceVpcEndpoint, InterfaceVpcEndpointOptions } from './vpc-endpoint';\nimport { FlowLog, FlowLogOptions, FlowLogResourceType } from './vpc-flow-logs';\nimport { VpcLookupOptions } from './vpc-lookup';\nimport { EnableVpnGatewayOptions, VpnConnection, VpnConnectionOptions, VpnConnectionType, VpnGateway } from './vpn';\n\nconst VPC_SUBNET_SYMBOL = Symbol.for('@aws-cdk/aws-ec2.VpcSubnet');\n\nexport interface ISubnet extends IResource {\n                                                               \n  readonly availabilityZone: string;\n\n                                                                        \n  readonly subnetId: string;\n\n                                                                                                           \n  readonly internetConnectivityEstablished: IDependable;\n\n                                                    \n  readonly ipv4CidrBlock: string;\n\n                                                \n  readonly routeTable: IRouteTable;\n\n                                                                                                           \n  associateNetworkAcl(id: string, acl: INetworkAcl): void;\n}\n\n                                  \nexport interface IRouteTable {\n                               \n  readonly routeTableId: string;\n}\n\nexport interface IVpc extends IResource {\n                                                        \n  readonly vpcId: string;\n\n                                                 \n  readonly vpcArn: string;\n\n                                                             \n  readonly vpcCidrBlock: string;\n\n                                                   \n  readonly publicSubnets: ISubnet[];\n\n                                                    \n  readonly privateSubnets: ISubnet[];\n\n                                                     \n  readonly isolatedSubnets: ISubnet[];\n\n                                 \n  readonly availabilityZones: string[];\n\n                                               \n  readonly vpnGatewayId?: string;\n\n                                                                                                           \n  readonly internetConnectivityEstablished: IDependable;\n\n                                                                                                                                                                                                          \n  selectSubnets(selection?: SubnetSelection): SelectedSubnets;\n\n                                               \n  enableVpnGateway(options: EnableVpnGatewayOptions): void;\n\n                                                      \n  addVpnConnection(id: string, options: VpnConnectionOptions): VpnConnection;\n\n                                                           \n  addClientVpnEndpoint(id: string, options: ClientVpnEndpointOptions): ClientVpnEndpoint;\n\n                                                        \n  addGatewayEndpoint(id: string, options: GatewayVpcEndpointOptions): GatewayVpcEndpoint\n\n                                                          \n  addInterfaceEndpoint(id: string, options: InterfaceVpcEndpointOptions): InterfaceVpcEndpoint\n\n                                                \n  addFlowLog(id: string, options?: FlowLogOptions): FlowLog\n}\n\n                             \nexport enum SubnetType {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  PRIVATE_ISOLATED = 'Isolated',\n\n  /**\n   * Isolated Subnets do not route traffic to the Internet (in this VPC),\n   * and as such, do not require NAT gateways.\n   *\n   * Isolated subnets can only connect to or be connected to from other\n   * instances in the same VPC. A default VPC configuration will not include\n   * isolated subnets.\n   *\n   * This can be good for subnets with RDS or Elasticache instances,\n   * or which route Internet traffic through a peer VPC.\n   *\n   * @deprecated use `SubnetType.PRIVATE_ISOLATED`\n   */\n  ISOLATED = 'Isolated',\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  PRIVATE_WITH_NAT = 'Private',\n\n  /**\n   * Subnet that routes to the internet, but not vice versa.\n   *\n   * Instances in a private subnet can connect to the Internet, but will not\n   * allow connections to be initiated from the Internet. NAT Gateway(s) are\n   * required with this subnet type to route the Internet traffic through.\n   * If a NAT Gateway is not required or desired, use `SubnetType.PRIVATE_ISOLATED` instead.\n   *\n   * By default, a NAT gateway is created in every public subnet for maximum availability.\n   * Be aware that you will be charged for NAT gateways.\n   *\n   * Normally a Private subnet will use a NAT gateway in the same AZ, but\n   * if `natGateways` is used to reduce the number of NAT gateways, a NAT\n   * gateway from another AZ will be used instead.\n   *\n   * @deprecated use `PRIVATE_WITH_NAT`\n   */\n  PRIVATE = 'Private',\n\n                                                                                                                                                                                                                                                                                                                                                                                   \n  PUBLIC = 'Public'\n}\n\n                                                                                                                                                                                                                                                                \nexport interface SubnetSelection {\n                                                                                                                                                                                                                                                  \n  readonly subnetType?: SubnetType;\n\n                                                                                                     \n  readonly availabilityZones?: string[];\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  readonly subnetGroupName?: string;\n\n                                                                                                                                                                                                                                                                                          \n  readonly subnetName?: string;\n\n                                                                                   \n  readonly onePerAz?: boolean;\n\n                                                                           \n  readonly subnetFilters?: SubnetFilter[];\n\n                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly subnets?: ISubnet[]\n}\n\n                                                             \nexport interface SelectedSubnets {\n                               \n  readonly subnetIds: string[];\n\n                                                  \n  readonly availabilityZones: string[];\n\n                                                                                \n  readonly internetConnectivityEstablished: IDependable;\n\n                                        \n  readonly subnets: ISubnet[];\n\n                                                                                    \n  readonly hasPublic: boolean;\n\n                                                                                                                                                                                                                                                                                                         \n  readonly isPendingLookup?: boolean;\n}\n\n/**\n * A new or imported VPC\n */\nabstract class VpcBase extends Resource implements IVpc {\n\n  /**\n   * Identifier for this VPC\n   */\n  public abstract readonly vpcId: string;\n\n  /**\n   * Arn of this VPC\n   */\n  public abstract readonly vpcArn: string;\n\n  /**\n   * CIDR range for this VPC\n   */\n  public abstract readonly vpcCidrBlock: string;\n\n  /**\n   * List of public subnets in this VPC\n   */\n  public abstract readonly publicSubnets: ISubnet[];\n\n  /**\n   * List of private subnets in this VPC\n   */\n  public abstract readonly privateSubnets: ISubnet[];\n\n  /**\n   * List of isolated subnets in this VPC\n   */\n  public abstract readonly isolatedSubnets: ISubnet[];\n\n  /**\n   * AZs for this VPC\n   */\n  public abstract readonly availabilityZones: string[];\n\n  /**\n   * Dependencies for internet connectivity\n   */\n  public abstract readonly internetConnectivityEstablished: IDependable;\n\n                                                                                                        \n  protected readonly natDependencies = new Array<IConstruct>();\n\n                                                                                    \n  protected incompleteSubnetDefinition: boolean = false;\n\n  /**\n   * Mutable private field for the vpnGatewayId\n   *\n   * @internal\n   */\n  protected _vpnGatewayId?: string;\n\n                                                \n  public selectSubnets(selection: SubnetSelection = {}): SelectedSubnets {\n    const subnets = this.selectSubnetObjects(selection);\n    const pubs = new Set(this.publicSubnets);\n\n    return {\n      subnetIds: subnets.map(s => s.subnetId),\n      get availabilityZones(): string[] { return subnets.map(s => s.availabilityZone); },\n      internetConnectivityEstablished: tap(new CompositeDependable(), d => subnets.forEach(s => d.add(s.internetConnectivityEstablished))),\n      subnets,\n      hasPublic: subnets.some(s => pubs.has(s)),\n      isPendingLookup: this.incompleteSubnetDefinition,\n    };\n  }\n\n                                               \n  public enableVpnGateway(options: EnableVpnGatewayOptions): void {\n    if (this.vpnGatewayId) {\n      throw new Error('The VPN Gateway has already been enabled.');\n    }\n\n    const vpnGateway = new VpnGateway(this, 'VpnGateway', {\n      amazonSideAsn: options.amazonSideAsn,\n      type: VpnConnectionType.IPSEC_1,\n    });\n\n    this._vpnGatewayId = vpnGateway.gatewayId;\n\n    const attachment = new CfnVPCGatewayAttachment(this, 'VPCVPNGW', {\n      vpcId: this.vpcId,\n      vpnGatewayId: this._vpnGatewayId,\n    });\n\n    // Propagate routes on route tables associated with the right subnets\n    const vpnRoutePropagation = options.vpnRoutePropagation ?? [{}];\n    const routeTableIds = allRouteTableIds(flatten(vpnRoutePropagation.map(s => this.selectSubnets(s).subnets)));\n\n    if (routeTableIds.length === 0) {\n      Annotations.of(this).addError(`enableVpnGateway: no subnets matching selection: '${JSON.stringify(vpnRoutePropagation)}'. Select other subnets to add routes to.`);\n    }\n\n    const routePropagation = new CfnVPNGatewayRoutePropagation(this, 'RoutePropagation', {\n      routeTableIds,\n      vpnGatewayId: this._vpnGatewayId,\n    });\n    // The AWS::EC2::VPNGatewayRoutePropagation resource cannot use the VPN gateway\n    // until it has successfully attached to the VPC.\n    // See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-vpn-gatewayrouteprop.html\n    routePropagation.node.addDependency(attachment);\n  }\n\n                                                      \n  public addVpnConnection(id: string, options: VpnConnectionOptions): VpnConnection {\n    return new VpnConnection(this, id, {\n      vpc: this,\n      ...options,\n    });\n  }\n\n                                                           \n  public addClientVpnEndpoint(id: string, options: ClientVpnEndpointOptions): ClientVpnEndpoint {\n    return new ClientVpnEndpoint(this, id, {\n      ...options,\n      vpc: this,\n    });\n  }\n\n                                                          \n  public addInterfaceEndpoint(id: string, options: InterfaceVpcEndpointOptions): InterfaceVpcEndpoint {\n    return new InterfaceVpcEndpoint(this, id, {\n      vpc: this,\n      ...options,\n    });\n  }\n\n                                                        \n  public addGatewayEndpoint(id: string, options: GatewayVpcEndpointOptions): GatewayVpcEndpoint {\n    return new GatewayVpcEndpoint(this, id, {\n      vpc: this,\n      ...options,\n    });\n  }\n\n                                                \n  public addFlowLog(id: string, options?: FlowLogOptions): FlowLog {\n    return new FlowLog(this, id, {\n      resourceType: FlowLogResourceType.fromVpc(this),\n      ...options,\n    });\n  }\n\n                                                               \n  public get vpnGatewayId(): string | undefined {\n    return this._vpnGatewayId;\n  }\n\n                                                                          \n  protected selectSubnetObjects(selection: SubnetSelection = {}): ISubnet[] {\n    selection = this.reifySelectionDefaults(selection);\n\n    if (selection.subnets !== undefined) {\n      return selection.subnets;\n    }\n\n    let subnets;\n\n    if (selection.subnetGroupName !== undefined) { // Select by name\n      subnets = this.selectSubnetObjectsByName(selection.subnetGroupName);\n\n    } else { // Or specify by type\n      const type = selection.subnetType || SubnetType.PRIVATE_WITH_NAT;\n      subnets = this.selectSubnetObjectsByType(type);\n    }\n\n    // Apply all the filters\n    subnets = this.applySubnetFilters(subnets, selection.subnetFilters ?? []);\n\n    return subnets;\n  }\n\n  private applySubnetFilters(subnets: ISubnet[], filters: SubnetFilter[]): ISubnet[] {\n    let filtered = subnets;\n    // Apply each filter in sequence\n    for (const filter of filters) {\n      filtered = filter.selectSubnets(filtered);\n    }\n    return filtered;\n  }\n\n  private selectSubnetObjectsByName(groupName: string) {\n    const allSubnets = [...this.publicSubnets, ...this.privateSubnets, ...this.isolatedSubnets];\n    const subnets = allSubnets.filter(s => subnetGroupNameFromConstructId(s) === groupName);\n\n    if (subnets.length === 0 && !this.incompleteSubnetDefinition) {\n      const names = Array.from(new Set(allSubnets.map(subnetGroupNameFromConstructId)));\n      throw new Error(`There are no subnet groups with name '${groupName}' in this VPC. Available names: ${names}`);\n    }\n\n    return subnets;\n  }\n\n  private selectSubnetObjectsByType(subnetType: SubnetType) {\n    const allSubnets = {\n      [SubnetType.PRIVATE_ISOLATED]: this.isolatedSubnets,\n      [SubnetType.PRIVATE_WITH_NAT]: this.privateSubnets,\n      [SubnetType.PUBLIC]: this.publicSubnets,\n    };\n\n    const subnets = allSubnets[subnetType];\n\n    // Force merge conflict here with https://github.com/aws/aws-cdk/pull/4089\n    // see ImportedVpc\n\n    if (subnets.length === 0 && !this.incompleteSubnetDefinition) {\n      const availableTypes = Object.entries(allSubnets).filter(([_, subs]) => subs.length > 0).map(([typeName, _]) => typeName);\n      throw new Error(`There are no '${subnetType}' subnet groups in this VPC. Available types: ${availableTypes}`);\n    }\n\n    return subnets;\n  }\n\n  /**\n   * Validate the fields in a SubnetSelection object, and reify defaults if necessary\n   *\n   * In case of default selection, select the first type of PRIVATE, ISOLATED,\n   * PUBLIC (in that order) that has any subnets.\n   */\n  private reifySelectionDefaults(placement: SubnetSelection): SubnetSelection {\n\n    if (placement.subnetName !== undefined) {\n      if (placement.subnetGroupName !== undefined) {\n        throw new Error('Please use only \\'subnetGroupName\\' (\\'subnetName\\' is deprecated and has the same behavior)');\n      } else {\n        Annotations.of(this).addWarning('Usage of \\'subnetName\\' in SubnetSelection is deprecated, use \\'subnetGroupName\\' instead');\n      }\n      placement = { ...placement, subnetGroupName: placement.subnetName };\n    }\n\n    const exclusiveSelections: Array<keyof SubnetSelection> = ['subnets', 'subnetType', 'subnetGroupName'];\n    const providedSelections = exclusiveSelections.filter(key => placement[key] !== undefined);\n    if (providedSelections.length > 1) {\n      throw new Error(`Only one of '${providedSelections}' can be supplied to subnet selection.`);\n    }\n\n    if (placement.subnetType === undefined && placement.subnetGroupName === undefined && placement.subnets === undefined) {\n      // Return default subnet type based on subnets that actually exist\n      let subnetType = this.privateSubnets.length\n        ? SubnetType.PRIVATE_WITH_NAT : this.isolatedSubnets.length ? SubnetType.PRIVATE_ISOLATED : SubnetType.PUBLIC;\n      placement = { ...placement, subnetType: subnetType };\n    }\n\n    // Establish which subnet filters are going to be used\n    let subnetFilters = placement.subnetFilters ?? [];\n\n    // Backwards compatibility with existing `availabilityZones` and `onePerAz` functionality\n    if (placement.availabilityZones !== undefined) { // Filter by AZs, if specified\n      subnetFilters.push(SubnetFilter.availabilityZones(placement.availabilityZones));\n    }\n    if (!!placement.onePerAz) { // Ensure one per AZ if specified\n      subnetFilters.push(SubnetFilter.onePerAz());\n    }\n\n    // Overwrite the provided placement filters and remove the availabilityZones and onePerAz properties\n    placement = { ...placement, subnetFilters: subnetFilters, availabilityZones: undefined, onePerAz: undefined };\n    const { availabilityZones, onePerAz, ...rest } = placement;\n\n    return rest;\n  }\n}\n\n                                                    \nexport interface VpcAttributes {\n                                 \n  readonly vpcId: string;\n\n                                                                                                 \n  readonly vpcCidrBlock?: string;\n\n                                                                        \n  readonly availabilityZones: string[];\n\n                                                                                                                           \n  readonly publicSubnetIds?: string[];\n\n                                                                                                                               \n  readonly publicSubnetNames?: string[];\n\n                                                                                                                                                \n  readonly publicSubnetRouteTableIds?: string[];\n\n                                                                                                                            \n  readonly privateSubnetIds?: string[];\n\n                                                                                                                                 \n  readonly privateSubnetNames?: string[];\n\n                                                                                                                                                  \n  readonly privateSubnetRouteTableIds?: string[];\n\n                                                                                                                             \n  readonly isolatedSubnetIds?: string[];\n\n                                                                                                                                   \n  readonly isolatedSubnetNames?: string[];\n\n                                                                                                                                                    \n  readonly isolatedSubnetRouteTableIds?: string[];\n\n                                         \n  readonly vpnGatewayId?: string;\n}\n\nexport interface SubnetAttributes {\n\n                                                                                                                                        \n  readonly availabilityZone?: string;\n\n                                                                                                                                         \n  readonly ipv4CidrBlock?: string;\n\n                                                                                                                                                  \n  readonly routeTableId?: string;\n\n                                                        \n  readonly subnetId: string;\n}\n\n/**\n * Name tag constant\n */\nconst NAME_TAG: string = 'Name';\n\n                                \nexport interface VpcProps {\n\n                                                                                                                                                                                                                                                      \n  readonly cidr?: string;\n\n                                                                                                                                                                                                                                                                               \n  readonly enableDnsHostnames?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  readonly enableDnsSupport?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly defaultInstanceTenancy?: DefaultInstanceTenancy;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n  readonly maxAzs?: number;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  readonly natGateways?: number;\n\n                                                                                                                                                                                                                                                                                                                                \n  readonly natGatewaySubnets?: SubnetSelection;\n\n                                                                                                                                                                                                                  \n  readonly natGatewayProvider?: NatProvider;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  readonly subnetConfiguration?: SubnetConfiguration[];\n\n                                                                                                                                                                        \n  readonly vpnGateway?: boolean;\n\n                                                                                                                         \n  readonly vpnGatewayAsn?: number;\n\n                                                                                  \n  readonly vpnConnections?: { [id: string]: VpnConnectionOptions }\n\n                                                                                                                                                                                                                                                    \n  readonly vpnRoutePropagation?: SubnetSelection[]\n\n                                                                                 \n  readonly gatewayEndpoints?: { [id: string]: GatewayVpcEndpointOptions }\n\n                                                                                 \n  readonly flowLogs?: { [id: string]: FlowLogOptions }\n\n                                                                \n  readonly vpcName?: string;\n}\n\n                                                                  \nexport enum DefaultInstanceTenancy {\n                                                            \n  DEFAULT = 'default',\n\n                                                                                                                                       \n  DEDICATED = 'dedicated'\n}\n\n                                                                               \nexport interface SubnetConfiguration {\n                                                                                                                                                                                                                                                                                                            \n  readonly cidrMask?: number;\n\n                                                                                                                                               \n  readonly subnetType: SubnetType;\n\n                                                                                                                                                                                    \n  readonly name: string;\n\n                                                                                                                                                                                                                                                                                                                                              \n  readonly reserved?: boolean;\n\n                                                                                                                                                                     \n  readonly mapPublicIpOnLaunch?: boolean;\n}\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \nexport class Vpc extends VpcBase {\n                                                                                                                                                                                                             \n  public static readonly DEFAULT_CIDR_RANGE: string = '10.0.0.0/16';\n\n                                                                                                             \n  public static readonly DEFAULT_SUBNETS: SubnetConfiguration[] = [\n    {\n      subnetType: SubnetType.PUBLIC,\n      name: defaultSubnetName(SubnetType.PUBLIC),\n    },\n    {\n      subnetType: SubnetType.PRIVATE_WITH_NAT,\n      name: defaultSubnetName(SubnetType.PRIVATE_WITH_NAT),\n    },\n  ];\n\n                                                                                                                                               \n  public static readonly DEFAULT_SUBNETS_NO_NAT: SubnetConfiguration[] = [\n    {\n      subnetType: SubnetType.PUBLIC,\n      name: defaultSubnetName(SubnetType.PUBLIC),\n    },\n    {\n      subnetType: SubnetType.PRIVATE_ISOLATED,\n      name: defaultSubnetName(SubnetType.PRIVATE_ISOLATED),\n    },\n  ];\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n  public static fromVpcAttributes(scope: Construct, id: string, attrs: VpcAttributes): IVpc {\n    return new ImportedVpc(scope, id, attrs, false);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  public static fromLookup(scope: Construct, id: string, options: VpcLookupOptions): IVpc {\n    if (Token.isUnresolved(options.vpcId)\n      || Token.isUnresolved(options.vpcName)\n      || Object.values(options.tags || {}).some(Token.isUnresolved)\n      || Object.keys(options.tags || {}).some(Token.isUnresolved)) {\n      throw new Error('All arguments to Vpc.fromLookup() must be concrete (no Tokens)');\n    }\n\n    const filter: {[key: string]: string} = makeTagFilter(options.tags);\n\n    // We give special treatment to some tags\n    if (options.vpcId) { filter['vpc-id'] = options.vpcId; }\n    if (options.vpcName) { filter['tag:Name'] = options.vpcName; }\n    if (options.isDefault !== undefined) {\n      filter.isDefault = options.isDefault ? 'true' : 'false';\n    }\n\n    const overrides: {[key: string]: string} = {};\n    if (options.region) {\n      overrides.region = options.region;\n    }\n\n    const attributes: cxapi.VpcContextResponse = ContextProvider.getValue(scope, {\n      provider: cxschema.ContextProvider.VPC_PROVIDER,\n      props: {\n        ...overrides,\n        filter,\n        returnAsymmetricSubnets: true,\n        subnetGroupNameTag: options.subnetGroupNameTag,\n      } as cxschema.VpcContextQuery,\n      dummyValue: undefined,\n    }).value;\n\n    return new LookedUpVpc(scope, id, attributes || DUMMY_VPC_PROPS, attributes === undefined);\n\n    /**\n     * Prefixes all keys in the argument with `tag:`.`\n     */\n    function makeTagFilter(tags: { [name: string]: string } | undefined): { [name: string]: string } {\n      const result: { [name: string]: string } = {};\n      for (const [name, value] of Object.entries(tags || {})) {\n        result[`tag:${name}`] = value;\n      }\n      return result;\n    }\n  }\n\n                                        \n  public readonly vpcId: string;\n\n                           \n  public readonly vpcArn: string;\n\n                           \n  public readonly vpcCidrBlock: string;\n\n                           \n  public readonly vpcDefaultNetworkAcl: string;\n\n                           \n  public readonly vpcCidrBlockAssociations: string[];\n\n                           \n  public readonly vpcDefaultSecurityGroup: string;\n\n                           \n  public readonly vpcIpv6CidrBlocks: string[];\n\n                                                   \n  public readonly publicSubnets: ISubnet[] = [];\n\n                                                    \n  public readonly privateSubnets: ISubnet[] = [];\n\n                                                     \n  public readonly isolatedSubnets: ISubnet[] = [];\n\n                                 \n  public readonly availabilityZones: string[];\n\n                                                                                                                                                           \n  public readonly internetGatewayId?: string;\n\n  public readonly internetConnectivityEstablished: IDependable;\n\n                                                                                            \n  public readonly dnsHostnamesEnabled: boolean;\n\n                                                                  \n  public readonly dnsSupportEnabled: boolean;\n\n  /**\n   * The VPC resource\n   */\n  private readonly resource: CfnVPC;\n\n  /**\n   * The NetworkBuilder\n   */\n  private networkBuilder: NetworkBuilder;\n\n  /**\n   * Subnet configurations for this VPC\n   */\n  private subnetConfiguration: SubnetConfiguration[] = [];\n\n  private readonly _internetConnectivityEstablished = new DependencyGroup();\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  constructor(scope: Construct, id: string, props: VpcProps = {}) {\n    super(scope, id);\n\n    const stack = Stack.of(this);\n\n    // Can't have enabledDnsHostnames without enableDnsSupport\n    if (props.enableDnsHostnames && !props.enableDnsSupport) {\n      throw new Error('To use DNS Hostnames, DNS Support must be enabled, however, it was explicitly disabled.');\n    }\n\n    const cidrBlock = ifUndefined(props.cidr, Vpc.DEFAULT_CIDR_RANGE);\n    if (Token.isUnresolved(cidrBlock)) {\n      throw new Error('\\'cidr\\' property must be a concrete CIDR string, got a Token (we need to parse it for automatic subdivision)');\n    }\n\n    this.networkBuilder = new NetworkBuilder(cidrBlock);\n\n    this.dnsHostnamesEnabled = props.enableDnsHostnames == null ? true : props.enableDnsHostnames;\n    this.dnsSupportEnabled = props.enableDnsSupport == null ? true : props.enableDnsSupport;\n    const instanceTenancy = props.defaultInstanceTenancy || 'default';\n    this.internetConnectivityEstablished = this._internetConnectivityEstablished;\n\n    // Define a VPC using the provided CIDR range\n    this.resource = new CfnVPC(this, 'Resource', {\n      cidrBlock,\n      enableDnsHostnames: this.dnsHostnamesEnabled,\n      enableDnsSupport: this.dnsSupportEnabled,\n      instanceTenancy,\n    });\n\n    this.vpcDefaultNetworkAcl = this.resource.attrDefaultNetworkAcl;\n    this.vpcCidrBlockAssociations = this.resource.attrCidrBlockAssociations;\n    this.vpcCidrBlock = this.resource.attrCidrBlock;\n    this.vpcDefaultSecurityGroup = this.resource.attrDefaultSecurityGroup;\n    this.vpcIpv6CidrBlocks = this.resource.attrIpv6CidrBlocks;\n\n    Tags.of(this).add(NAME_TAG, props.vpcName || this.node.path);\n\n    this.availabilityZones = stack.availabilityZones;\n\n    const maxAZs = props.maxAzs ?? 3;\n    this.availabilityZones = this.availabilityZones.slice(0, maxAZs);\n\n    this.vpcId = this.resource.ref;\n    this.vpcArn = Arn.format({\n      service: 'ec2',\n      resource: 'vpc',\n      resourceName: this.vpcId,\n    }, stack);\n\n    const defaultSubnet = props.natGateways === 0 ? Vpc.DEFAULT_SUBNETS_NO_NAT : Vpc.DEFAULT_SUBNETS;\n    this.subnetConfiguration = ifUndefined(props.subnetConfiguration, defaultSubnet);\n\n    const natGatewayPlacement = props.natGatewaySubnets || { subnetType: SubnetType.PUBLIC };\n    const natGatewayCount = determineNatGatewayCount(props.natGateways, this.subnetConfiguration, this.availabilityZones.length);\n\n    // subnetConfiguration must be set before calling createSubnets\n    this.createSubnets();\n\n    const allowOutbound = this.subnetConfiguration.filter(\n      subnet => (subnet.subnetType !== SubnetType.PRIVATE_ISOLATED)).length > 0;\n\n    // Create an Internet Gateway and attach it if necessary\n    if (allowOutbound) {\n      const igw = new CfnInternetGateway(this, 'IGW', {\n      });\n\n      this.internetGatewayId = igw.ref;\n\n      this._internetConnectivityEstablished.add(igw);\n      const att = new CfnVPCGatewayAttachment(this, 'VPCGW', {\n        internetGatewayId: igw.ref,\n        vpcId: this.resource.ref,\n      });\n\n      (this.publicSubnets as PublicSubnet[]).forEach(publicSubnet => {\n        publicSubnet.addDefaultInternetRoute(igw.ref, att);\n      });\n\n      // if gateways are needed create them\n      if (natGatewayCount > 0) {\n        const provider = props.natGatewayProvider || NatProvider.gateway();\n        this.createNatGateways(provider, natGatewayCount, natGatewayPlacement);\n      }\n    }\n\n    if (props.vpnGateway && this.publicSubnets.length === 0 && this.privateSubnets.length === 0 && this.isolatedSubnets.length === 0) {\n      throw new Error('Can not enable the VPN gateway while the VPC has no subnets at all');\n    }\n\n    if ((props.vpnConnections || props.vpnGatewayAsn) && props.vpnGateway === false) {\n      throw new Error('Cannot specify `vpnConnections` or `vpnGatewayAsn` when `vpnGateway` is set to false.');\n    }\n\n    if (props.vpnGateway || props.vpnConnections || props.vpnGatewayAsn) {\n      this.enableVpnGateway({\n        amazonSideAsn: props.vpnGatewayAsn,\n        type: VpnConnectionType.IPSEC_1,\n        vpnRoutePropagation: props.vpnRoutePropagation,\n      });\n\n      const vpnConnections = props.vpnConnections || {};\n      for (const [connectionId, connection] of Object.entries(vpnConnections)) {\n        this.addVpnConnection(connectionId, connection);\n      }\n    }\n\n    // Allow creation of gateway endpoints on VPC instantiation as those can be\n    // immediately functional without further configuration. This is not the case\n    // for interface endpoints where the security group must be configured.\n    if (props.gatewayEndpoints) {\n      const gatewayEndpoints = props.gatewayEndpoints || {};\n      for (const [endpointId, endpoint] of Object.entries(gatewayEndpoints)) {\n        this.addGatewayEndpoint(endpointId, endpoint);\n      }\n    }\n\n    // Add flow logs to the VPC\n    if (props.flowLogs) {\n      const flowLogs = props.flowLogs || {};\n      for (const [flowLogId, flowLog] of Object.entries(flowLogs)) {\n        this.addFlowLog(flowLogId, flowLog);\n      }\n    }\n  }\n\n                                                                                                                    \n  public addS3Endpoint(id: string, subnets?: SubnetSelection[]): GatewayVpcEndpoint {\n    return new GatewayVpcEndpoint(this, id, {\n      service: GatewayVpcEndpointAwsService.S3,\n      vpc: this,\n      subnets,\n    });\n  }\n\n                                                                                                                          \n  public addDynamoDbEndpoint(id: string, subnets?: SubnetSelection[]): GatewayVpcEndpoint {\n    return new GatewayVpcEndpoint(this, id, {\n      service: GatewayVpcEndpointAwsService.DYNAMODB,\n      vpc: this,\n      subnets,\n    });\n  }\n\n  private createNatGateways(provider: NatProvider, natCount: number, placement: SubnetSelection): void {\n    const natSubnets: PublicSubnet[] = this.selectSubnetObjects(placement) as PublicSubnet[];\n    for (const sub of natSubnets) {\n      if (this.publicSubnets.indexOf(sub) === -1) {\n        throw new Error(`natGatewayPlacement ${placement} contains non public subnet ${sub}`);\n      }\n    }\n\n    provider.configureNat({\n      vpc: this,\n      natSubnets: natSubnets.slice(0, natCount),\n      privateSubnets: this.privateSubnets as PrivateSubnet[],\n    });\n  }\n\n  /**\n   * createSubnets creates the subnets specified by the subnet configuration\n   * array or creates the `DEFAULT_SUBNETS` configuration\n   */\n  private createSubnets() {\n    const remainingSpaceSubnets: SubnetConfiguration[] = [];\n\n    for (const subnet of this.subnetConfiguration) {\n      if (subnet.cidrMask === undefined) {\n        remainingSpaceSubnets.push(subnet);\n        continue;\n      }\n      this.createSubnetResources(subnet, subnet.cidrMask);\n    }\n\n    const totalRemaining = remainingSpaceSubnets.length * this.availabilityZones.length;\n    const cidrMaskForRemaining = this.networkBuilder.maskForRemainingSubnets(totalRemaining);\n    for (const subnet of remainingSpaceSubnets) {\n      this.createSubnetResources(subnet, cidrMaskForRemaining);\n    }\n  }\n\n  private createSubnetResources(subnetConfig: SubnetConfiguration, cidrMask: number) {\n    this.availabilityZones.forEach((zone, index) => {\n      if (subnetConfig.reserved === true) {\n        // For reserved subnets, just allocate ip space but do not create any resources\n        this.networkBuilder.addSubnet(cidrMask);\n        return;\n      }\n\n      // mapPublicIpOnLaunch true in Subnet.Public, false in Subnet.Private or Subnet.Isolated.\n      let mapPublicIpOnLaunch = false;\n      if (subnetConfig.subnetType !== SubnetType.PUBLIC && subnetConfig.mapPublicIpOnLaunch !== undefined) {\n        throw new Error(`${subnetConfig.subnetType} subnet cannot include mapPublicIpOnLaunch parameter`);\n      }\n      if (subnetConfig.subnetType === SubnetType.PUBLIC) {\n        mapPublicIpOnLaunch = (subnetConfig.mapPublicIpOnLaunch !== undefined)\n          ? subnetConfig.mapPublicIpOnLaunch\n          : true;\n      }\n\n      const name = subnetId(subnetConfig.name, index);\n      const subnetProps: SubnetProps = {\n        availabilityZone: zone,\n        vpcId: this.vpcId,\n        cidrBlock: this.networkBuilder.addSubnet(cidrMask),\n        mapPublicIpOnLaunch: mapPublicIpOnLaunch,\n      };\n\n      let subnet: Subnet;\n      switch (subnetConfig.subnetType) {\n        case SubnetType.PUBLIC:\n          const publicSubnet = new PublicSubnet(this, name, subnetProps);\n          this.publicSubnets.push(publicSubnet);\n          subnet = publicSubnet;\n          break;\n        case SubnetType.PRIVATE_WITH_NAT:\n          const privateSubnet = new PrivateSubnet(this, name, subnetProps);\n          this.privateSubnets.push(privateSubnet);\n          subnet = privateSubnet;\n          break;\n        case SubnetType.PRIVATE_ISOLATED:\n          const isolatedSubnet = new PrivateSubnet(this, name, subnetProps);\n          this.isolatedSubnets.push(isolatedSubnet);\n          subnet = isolatedSubnet;\n          break;\n        default:\n          throw new Error(`Unrecognized subnet type: ${subnetConfig.subnetType}`);\n      }\n\n      // These values will be used to recover the config upon provider import\n      const includeResourceTypes = [CfnSubnet.CFN_RESOURCE_TYPE_NAME];\n      Tags.of(subnet).add(SUBNETNAME_TAG, subnetConfig.name, { includeResourceTypes });\n      Tags.of(subnet).add(SUBNETTYPE_TAG, subnetTypeTagValue(subnetConfig.subnetType), { includeResourceTypes });\n    });\n  }\n}\n\nconst SUBNETTYPE_TAG = 'aws-cdk:subnet-type';\nconst SUBNETNAME_TAG = 'aws-cdk:subnet-name';\n\nfunction subnetTypeTagValue(type: SubnetType) {\n  switch (type) {\n    case SubnetType.PUBLIC: return 'Public';\n    case SubnetType.PRIVATE_WITH_NAT: return 'Private';\n    case SubnetType.PRIVATE_ISOLATED: return 'Isolated';\n  }\n}\n\n                                                            \nexport interface SubnetProps {\n\n                                                     \n  readonly availabilityZone: string;\n\n                                                     \n  readonly vpcId: string;\n\n                                                  \n  readonly cidrBlock: string;\n\n                                                                                                                                                                     \n  readonly mapPublicIpOnLaunch?: boolean;\n}\n\n                                                                                \nexport class Subnet extends Resource implements ISubnet {\n\n  public static isVpcSubnet(x: any): x is Subnet {\n    return VPC_SUBNET_SYMBOL in x;\n  }\n\n  public static fromSubnetAttributes(scope: Construct, id: string, attrs: SubnetAttributes): ISubnet {\n    return new ImportedSubnet(scope, id, attrs);\n  }\n\n                                                \n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  public static fromSubnetId(scope: Construct, id: string, subnetId: string): ISubnet {\n    return this.fromSubnetAttributes(scope, id, { subnetId });\n  }\n\n                                                               \n  public readonly availabilityZone: string;\n\n                           \n  public readonly ipv4CidrBlock: string;\n\n                                                        \n  public readonly subnetId: string;\n\n                           \n  public readonly subnetVpcId: string;\n\n                           \n  public readonly subnetAvailabilityZone: string;\n\n                           \n  public readonly subnetIpv6CidrBlocks: string[];\n\n                                                                                                               \n  public readonly subnetOutpostArn: string;\n\n                           \n  public readonly subnetNetworkAclAssociationId: string;\n\n                                         \n  public readonly dependencyElements: IDependable[] = [];\n\n                                                          \n  public readonly routeTable: IRouteTable;\n\n  public readonly internetConnectivityEstablished: IDependable;\n\n  private readonly _internetConnectivityEstablished = new DependencyGroup();\n\n  private _networkAcl: INetworkAcl;\n\n  constructor(scope: Construct, id: string, props: SubnetProps) {\n    super(scope, id);\n\n    Object.defineProperty(this, VPC_SUBNET_SYMBOL, { value: true });\n\n    Tags.of(this).add(NAME_TAG, this.node.path);\n\n    this.availabilityZone = props.availabilityZone;\n    this.ipv4CidrBlock = props.cidrBlock;\n    const subnet = new CfnSubnet(this, 'Subnet', {\n      vpcId: props.vpcId,\n      cidrBlock: props.cidrBlock,\n      availabilityZone: props.availabilityZone,\n      mapPublicIpOnLaunch: props.mapPublicIpOnLaunch,\n    });\n    this.subnetId = subnet.ref;\n    this.subnetVpcId = subnet.attrVpcId;\n    this.subnetAvailabilityZone = subnet.attrAvailabilityZone;\n    this.subnetIpv6CidrBlocks = subnet.attrIpv6CidrBlocks;\n    this.subnetOutpostArn = subnet.attrOutpostArn;\n\n    // subnet.attrNetworkAclAssociationId is the default ACL after the subnet\n    // was just created. However, the ACL can be replaced at a later time.\n    this._networkAcl = NetworkAcl.fromNetworkAclId(this, 'Acl', subnet.attrNetworkAclAssociationId);\n    this.subnetNetworkAclAssociationId = Lazy.string({ produce: () => this._networkAcl.networkAclId });\n    this.node.defaultChild = subnet;\n\n    const table = new CfnRouteTable(this, 'RouteTable', {\n      vpcId: props.vpcId,\n    });\n    this.routeTable = { routeTableId: table.ref };\n\n    // Associate the public route table for this subnet, to this subnet\n    new CfnSubnetRouteTableAssociation(this, 'RouteTableAssociation', {\n      subnetId: this.subnetId,\n      routeTableId: table.ref,\n    });\n\n    this.internetConnectivityEstablished = this._internetConnectivityEstablished;\n  }\n\n                                                                                                                                                                                                                                                                                                              \n  public addDefaultInternetRoute(gatewayId: string, gatewayAttachment: IDependable) {\n    const route = new CfnRoute(this, 'DefaultRoute', {\n      routeTableId: this.routeTable.routeTableId,\n      destinationCidrBlock: '0.0.0.0/0',\n      gatewayId,\n    });\n    route.node.addDependency(gatewayAttachment);\n\n    // Since the 'route' depends on the gateway attachment, just\n    // depending on the route is enough.\n    this._internetConnectivityEstablished.add(route);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                           \n  public get networkAcl(): INetworkAcl {\n    return this._networkAcl;\n  }\n\n                                                                                                                                                    \n  public addDefaultNatRoute(natGatewayId: string) {\n    this.addRoute('DefaultRoute', {\n      routerType: RouterType.NAT_GATEWAY,\n      routerId: natGatewayId,\n      enablesInternetConnectivity: true,\n    });\n  }\n\n                                                          \n  public addRoute(id: string, options: AddRouteOptions) {\n    if (options.destinationCidrBlock && options.destinationIpv6CidrBlock) {\n      throw new Error('Cannot specify both \\'destinationCidrBlock\\' and \\'destinationIpv6CidrBlock\\'');\n    }\n\n    const route = new CfnRoute(this, id, {\n      routeTableId: this.routeTable.routeTableId,\n      destinationCidrBlock: options.destinationCidrBlock || (options.destinationIpv6CidrBlock === undefined ? '0.0.0.0/0' : undefined),\n      destinationIpv6CidrBlock: options.destinationIpv6CidrBlock,\n      [routerTypeToPropName(options.routerType)]: options.routerId,\n    });\n\n    if (options.enablesInternetConnectivity) {\n      this._internetConnectivityEstablished.add(route);\n    }\n  }\n\n  public associateNetworkAcl(id: string, networkAcl: INetworkAcl) {\n    this._networkAcl = networkAcl;\n\n    const scope = networkAcl instanceof Construct ? networkAcl : this;\n    const other = networkAcl instanceof Construct ? this : networkAcl;\n    new SubnetNetworkAclAssociation(scope, id + Names.nodeUniqueId(other.node), {\n      networkAcl,\n      subnet: this,\n    });\n  }\n}\n\n                                                     \nexport interface AddRouteOptions {\n                                                                                \n  readonly destinationCidrBlock?: string;\n\n                                                                                \n  readonly destinationIpv6CidrBlock?: string;\n\n                                                             \n  readonly routerType: RouterType;\n\n                                                                                                                     \n  readonly routerId: string;\n\n                                                                                                                                                                                                                                         \n  readonly enablesInternetConnectivity?: boolean;\n}\n\n                                       \nexport enum RouterType {\n                                             \n  EGRESS_ONLY_INTERNET_GATEWAY = 'EgressOnlyInternetGateway',\n\n                                 \n  GATEWAY = 'Gateway',\n\n                         \n  INSTANCE = 'Instance',\n\n                            \n  NAT_GATEWAY = 'NatGateway',\n\n                                  \n  NETWORK_INTERFACE = 'NetworkInterface',\n\n                                       \n  VPC_PEERING_CONNECTION = 'VpcPeeringConnection',\n}\n\nfunction routerTypeToPropName(routerType: RouterType) {\n  return ({\n    [RouterType.EGRESS_ONLY_INTERNET_GATEWAY]: 'egressOnlyInternetGatewayId',\n    [RouterType.GATEWAY]: 'gatewayId',\n    [RouterType.INSTANCE]: 'instanceId',\n    [RouterType.NAT_GATEWAY]: 'natGatewayId',\n    [RouterType.NETWORK_INTERFACE]: 'networkInterfaceId',\n    [RouterType.VPC_PEERING_CONNECTION]: 'vpcPeeringConnectionId',\n  })[routerType];\n}\n\nexport interface PublicSubnetProps extends SubnetProps {\n\n}\n\nexport interface IPublicSubnet extends ISubnet { }\n\nexport interface PublicSubnetAttributes extends SubnetAttributes { }\n\n                                                  \nexport class PublicSubnet extends Subnet implements IPublicSubnet {\n\n  public static fromPublicSubnetAttributes(scope: Construct, id: string, attrs: PublicSubnetAttributes): IPublicSubnet {\n    return new ImportedSubnet(scope, id, attrs);\n  }\n\n  constructor(scope: Construct, id: string, props: PublicSubnetProps) {\n    super(scope, id, props);\n  }\n\n                                                                                                                                                                            \n  public addNatGateway(eipAllocationId?: string) {\n    // Create a NAT Gateway in this public subnet\n    const ngw = new CfnNatGateway(this, 'NATGateway', {\n      subnetId: this.subnetId,\n      allocationId: eipAllocationId ?? new CfnEIP(this, 'EIP', {\n        domain: 'vpc',\n      }).attrAllocationId,\n    });\n    return ngw;\n  }\n}\n\nexport interface PrivateSubnetProps extends SubnetProps {\n\n}\n\nexport interface IPrivateSubnet extends ISubnet { }\n\nexport interface PrivateSubnetAttributes extends SubnetAttributes { }\n\n                                                   \nexport class PrivateSubnet extends Subnet implements IPrivateSubnet {\n\n  public static fromPrivateSubnetAttributes(scope: Construct, id: string, attrs: PrivateSubnetAttributes): IPrivateSubnet {\n    return new ImportedSubnet(scope, id, attrs);\n  }\n\n  constructor(scope: Construct, id: string, props: PrivateSubnetProps) {\n    super(scope, id, props);\n  }\n}\n\nfunction ifUndefined<T>(value: T | undefined, defaultValue: T): T {\n  return value ?? defaultValue;\n}\n\nclass ImportedVpc extends VpcBase {\n  public readonly vpcId: string;\n  public readonly vpcArn: string;\n  public readonly publicSubnets: ISubnet[];\n  public readonly privateSubnets: ISubnet[];\n  public readonly isolatedSubnets: ISubnet[];\n  public readonly availabilityZones: string[];\n  public readonly internetConnectivityEstablished: IDependable = new DependencyGroup();\n  private readonly cidr?: string | undefined;\n\n  constructor(scope: Construct, id: string, props: VpcAttributes, isIncomplete: boolean) {\n    super(scope, id);\n\n    this.vpcId = props.vpcId;\n    this.vpcArn = Arn.format({\n      service: 'ec2',\n      resource: 'vpc',\n      resourceName: this.vpcId,\n    }, Stack.of(this));\n    this.cidr = props.vpcCidrBlock;\n    this.availabilityZones = props.availabilityZones;\n    this._vpnGatewayId = props.vpnGatewayId;\n    this.incompleteSubnetDefinition = isIncomplete;\n\n    // None of the values may be unresolved list tokens\n    for (const k of Object.keys(props) as Array<keyof VpcAttributes>) {\n      if (Array.isArray(props[k]) && Token.isUnresolved(props[k])) {\n        Annotations.of(this).addWarning(`fromVpcAttributes: '${k}' is a list token: the imported VPC will not work with constructs that require a list of subnets at synthesis time. Use 'Vpc.fromLookup()' or 'Fn.importListValue' instead.`);\n      }\n    }\n\n    /* eslint-disable max-len */\n    const pub = new ImportSubnetGroup(props.publicSubnetIds, props.publicSubnetNames, props.publicSubnetRouteTableIds, SubnetType.PUBLIC, this.availabilityZones, 'publicSubnetIds', 'publicSubnetNames', 'publicSubnetRouteTableIds');\n    const priv = new ImportSubnetGroup(props.privateSubnetIds, props.privateSubnetNames, props.privateSubnetRouteTableIds, SubnetType.PRIVATE_WITH_NAT, this.availabilityZones, 'privateSubnetIds', 'privateSubnetNames', 'privateSubnetRouteTableIds');\n    const iso = new ImportSubnetGroup(props.isolatedSubnetIds, props.isolatedSubnetNames, props.isolatedSubnetRouteTableIds, SubnetType.PRIVATE_ISOLATED, this.availabilityZones, 'isolatedSubnetIds', 'isolatedSubnetNames', 'isolatedSubnetRouteTableIds');\n    /* eslint-enable max-len */\n\n    this.publicSubnets = pub.import(this);\n    this.privateSubnets = priv.import(this);\n    this.isolatedSubnets = iso.import(this);\n  }\n\n  public get vpcCidrBlock(): string {\n    if (this.cidr === undefined) {\n      throw new Error('Cannot perform this operation: \\'vpcCidrBlock\\' was not supplied when creating this VPC');\n    }\n    return this.cidr;\n  }\n}\n\nclass LookedUpVpc extends VpcBase {\n  public readonly vpcId: string;\n  public readonly vpcArn: string;\n  public readonly internetConnectivityEstablished: IDependable = new DependencyGroup();\n  public readonly availabilityZones: string[];\n  public readonly publicSubnets: ISubnet[];\n  public readonly privateSubnets: ISubnet[];\n  public readonly isolatedSubnets: ISubnet[];\n  private readonly cidr?: string | undefined;\n\n  constructor(scope: Construct, id: string, props: cxapi.VpcContextResponse, isIncomplete: boolean) {\n    super(scope, id);\n\n    this.vpcId = props.vpcId;\n    this.vpcArn = Arn.format({\n      service: 'ec2',\n      resource: 'vpc',\n      resourceName: this.vpcId,\n    }, Stack.of(this));\n    this.cidr = props.vpcCidrBlock;\n    this._vpnGatewayId = props.vpnGatewayId;\n    this.incompleteSubnetDefinition = isIncomplete;\n\n    const subnetGroups = props.subnetGroups || [];\n    const availabilityZones = Array.from(new Set<string>(flatMap(subnetGroups, subnetGroup => {\n      return subnetGroup.subnets.map(subnet => subnet.availabilityZone);\n    })));\n    availabilityZones.sort((az1, az2) => az1.localeCompare(az2));\n    this.availabilityZones = availabilityZones;\n\n    this.publicSubnets = this.extractSubnetsOfType(subnetGroups, cxapi.VpcSubnetGroupType.PUBLIC);\n    this.privateSubnets = this.extractSubnetsOfType(subnetGroups, cxapi.VpcSubnetGroupType.PRIVATE);\n    this.isolatedSubnets = this.extractSubnetsOfType(subnetGroups, cxapi.VpcSubnetGroupType.ISOLATED);\n  }\n\n  public get vpcCidrBlock(): string {\n    if (this.cidr === undefined) {\n      // Value might be cached from an old CLI version, so bumping the CX API protocol to\n      // force the value to exist would not have helped.\n      throw new Error('Cannot perform this operation: \\'vpcCidrBlock\\' was not found when looking up this VPC. Use a newer version of the CDK CLI and clear the old context value.');\n    }\n    return this.cidr;\n  }\n\n  private extractSubnetsOfType(subnetGroups: cxapi.VpcSubnetGroup[], subnetGroupType: cxapi.VpcSubnetGroupType): ISubnet[] {\n    return flatMap(subnetGroups.filter(subnetGroup => subnetGroup.type === subnetGroupType),\n      subnetGroup => this.subnetGroupToSubnets(subnetGroup));\n  }\n\n  private subnetGroupToSubnets(subnetGroup: cxapi.VpcSubnetGroup): ISubnet[] {\n    const ret = new Array<ISubnet>();\n    for (let i = 0; i < subnetGroup.subnets.length; i++) {\n      const vpcSubnet = subnetGroup.subnets[i];\n      ret.push(Subnet.fromSubnetAttributes(this, `${subnetGroup.name}Subnet${i + 1}`, {\n        availabilityZone: vpcSubnet.availabilityZone,\n        subnetId: vpcSubnet.subnetId,\n        routeTableId: vpcSubnet.routeTableId,\n        ipv4CidrBlock: vpcSubnet.cidr,\n      }));\n    }\n    return ret;\n  }\n}\n\nfunction flatMap<T, U>(xs: T[], fn: (x: T) => U[]): U[] {\n  const ret = new Array<U>();\n  for (const x of xs) {\n    ret.push(...fn(x));\n  }\n  return ret;\n}\n\nclass CompositeDependable implements IDependable {\n  private readonly dependables = new Array<IDependable>();\n\n  constructor() {\n    const self = this;\n    Dependable.implement(this, {\n      get dependencyRoots() {\n        const ret = new Array<IConstruct>();\n        for (const dep of self.dependables) {\n          ret.push(...Dependable.of(dep).dependencyRoots);\n        }\n        return ret;\n      },\n    });\n  }\n\n  /**\n   * Add a construct to the dependency roots\n   */\n  public add(dep: IDependable) {\n    this.dependables.push(dep);\n  }\n}\n\n/**\n * Invoke a function on a value (for its side effect) and return the value\n */\nfunction tap<T>(x: T, fn: (x: T) => void): T {\n  fn(x);\n  return x;\n}\n\nclass ImportedSubnet extends Resource implements ISubnet, IPublicSubnet, IPrivateSubnet {\n  public readonly internetConnectivityEstablished: IDependable = new DependencyGroup();\n  public readonly subnetId: string;\n  public readonly routeTable: IRouteTable;\n  private readonly _availabilityZone?: string;\n  private readonly _ipv4CidrBlock?: string;\n\n  constructor(scope: Construct, id: string, attrs: SubnetAttributes) {\n    super(scope, id);\n\n    if (!attrs.routeTableId) {\n      // The following looks a little weird, but comes down to:\n      //\n      // * Is the subnetId itself unresolved ({ Ref: Subnet }); or\n      // * Was it the accidentally extracted first element of a list-encoded\n      //   token? ({ Fn::ImportValue: Subnets } => ['#{Token[1234]}'] =>\n      //   '#{Token[1234]}'\n      //\n      // There's no other API to test for the second case than to the string back into\n      // a list and see if the combination is Unresolved.\n      //\n      // In both cases we can't output the subnetId literally into the metadata (because it'll\n      // be useless). In the 2nd case even, if we output it to metadata, the `resolve()` call\n      // that gets done on the metadata will even `throw`, because the '#{Token}' value will\n      // occur in an illegal position (not in a list context).\n      const ref = Token.isUnresolved(attrs.subnetId) || Token.isUnresolved([attrs.subnetId])\n        ? `at '${Node.of(scope).path}/${id}'`\n        : `'${attrs.subnetId}'`;\n      // eslint-disable-next-line max-len\n      Annotations.of(this).addWarning(`No routeTableId was provided to the subnet ${ref}. Attempting to read its .routeTable.routeTableId will return null/undefined. (More info: https://github.com/aws/aws-cdk/pull/3171)`);\n    }\n\n    this._ipv4CidrBlock = attrs.ipv4CidrBlock;\n    this._availabilityZone = attrs.availabilityZone;\n    this.subnetId = attrs.subnetId;\n    this.routeTable = {\n      // Forcing routeTableId to pretend non-null to maintain backwards-compatibility. See https://github.com/aws/aws-cdk/pull/3171\n      routeTableId: attrs.routeTableId!,\n    };\n  }\n\n  public get availabilityZone(): string {\n    if (!this._availabilityZone) {\n      // eslint-disable-next-line max-len\n      throw new Error('You cannot reference a Subnet\\'s availability zone if it was not supplied. Add the availabilityZone when importing using Subnet.fromSubnetAttributes()');\n    }\n    return this._availabilityZone;\n  }\n\n  public get ipv4CidrBlock(): string {\n    if (!this._ipv4CidrBlock) {\n      // tslint:disable-next-line: max-line-length\n      throw new Error('You cannot reference an imported Subnet\\'s IPv4 CIDR if it was not supplied. Add the ipv4CidrBlock when importing using Subnet.fromSubnetAttributes()');\n    }\n    return this._ipv4CidrBlock;\n  }\n\n  public associateNetworkAcl(id: string, networkAcl: INetworkAcl): void {\n    const scope = networkAcl instanceof Construct ? networkAcl : this;\n    const other = networkAcl instanceof Construct ? this : networkAcl;\n    new SubnetNetworkAclAssociation(scope, id + Names.nodeUniqueId(other.node), {\n      networkAcl,\n      subnet: this,\n    });\n  }\n}\n\n/**\n * Determine (and validate) the NAT gateway count w.r.t. the rest of the subnet configuration\n *\n * We have the following requirements:\n *\n * - NatGatewayCount = 0 ==> there are no private subnets\n * - NatGatewayCount > 0 ==> there must be public subnets\n *\n * Do we want to require that there are private subnets if there are NatGateways?\n * They seem pointless but I see no reason to prevent it.\n */\nfunction determineNatGatewayCount(requestedCount: number | undefined, subnetConfig: SubnetConfiguration[], azCount: number) {\n  const hasPrivateSubnets = subnetConfig.some(c => c.subnetType === SubnetType.PRIVATE_WITH_NAT && !c.reserved);\n  const hasPublicSubnets = subnetConfig.some(c => c.subnetType === SubnetType.PUBLIC);\n\n  const count = requestedCount !== undefined ? Math.min(requestedCount, azCount) : (hasPrivateSubnets ? azCount : 0);\n\n  if (count === 0 && hasPrivateSubnets) {\n    // eslint-disable-next-line max-len\n    throw new Error('If you do not want NAT gateways (natGateways=0), make sure you don\\'t configure any PRIVATE subnets in \\'subnetConfiguration\\' (make them PUBLIC or ISOLATED instead)');\n  }\n\n  if (count > 0 && !hasPublicSubnets) {\n    // eslint-disable-next-line max-len\n    throw new Error(`If you configure PRIVATE subnets in 'subnetConfiguration', you must also configure PUBLIC subnets to put the NAT gateways into (got ${JSON.stringify(subnetConfig)}.`);\n  }\n\n  return count;\n}\n\n/**\n * There are returned when the provider has not supplied props yet\n *\n * It's only used for testing and on the first run-through.\n */\nconst DUMMY_VPC_PROPS: cxapi.VpcContextResponse = {\n  availabilityZones: [],\n  vpcCidrBlock: '1.2.3.4/5',\n  isolatedSubnetIds: undefined,\n  isolatedSubnetNames: undefined,\n  isolatedSubnetRouteTableIds: undefined,\n  privateSubnetIds: undefined,\n  privateSubnetNames: undefined,\n  privateSubnetRouteTableIds: undefined,\n  publicSubnetIds: undefined,\n  publicSubnetNames: undefined,\n  publicSubnetRouteTableIds: undefined,\n  subnetGroups: [\n    {\n      name: 'Public',\n      type: cxapi.VpcSubnetGroupType.PUBLIC,\n      subnets: [\n        {\n          availabilityZone: 'dummy1a',\n          subnetId: 's-12345',\n          routeTableId: 'rtb-12345s',\n          cidr: '1.2.3.4/5',\n        },\n        {\n          availabilityZone: 'dummy1b',\n          subnetId: 's-67890',\n          routeTableId: 'rtb-67890s',\n          cidr: '1.2.3.4/5',\n        },\n      ],\n    },\n    {\n      name: 'Private',\n      type: cxapi.VpcSubnetGroupType.PRIVATE,\n      subnets: [\n        {\n          availabilityZone: 'dummy1a',\n          subnetId: 'p-12345',\n          routeTableId: 'rtb-12345p',\n          cidr: '1.2.3.4/5',\n        },\n        {\n          availabilityZone: 'dummy1b',\n          subnetId: 'p-67890',\n          routeTableId: 'rtb-57890p',\n          cidr: '1.2.3.4/5',\n        },\n      ],\n    },\n  ],\n  vpcId: 'vpc-12345',\n};\n"],
  "mappings": "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",
  "names": []
}
