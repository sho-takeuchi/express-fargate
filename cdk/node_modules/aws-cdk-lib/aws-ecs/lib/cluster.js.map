{
  "version": 3,
  "sources": ["cluster.ts"],
  "sourcesContent": ["import * as autoscaling from '../../aws-autoscaling';\nimport * as cloudwatch from '../../aws-cloudwatch';\nimport * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as logs from '../../aws-logs';\nimport * as s3 from '../../aws-s3';\nimport * as cloudmap from '../../aws-servicediscovery';\nimport { Duration, Lazy, IResource, Resource, Stack, Aspects, IAspect, ArnFormat } from '../../core';\nimport { Construct, IConstruct } from 'constructs';\nimport { BottleRocketImage, EcsOptimizedAmi } from './amis';\nimport { InstanceDrainHook } from './drain-hook/instance-drain-hook';\nimport { ECSMetrics } from './ecs-canned-metrics.generated';\nimport { CfnCluster, CfnCapacityProvider, CfnClusterCapacityProviderAssociations } from './ecs.generated';\n\n                                                        \nexport interface ClusterProps {\n                                                                                           \n  readonly clusterName?: string;\n\n                                                                                                                                                   \n  readonly vpc?: ec2.IVpc;\n\n                                                                                                                                                                                                                                        \n  readonly defaultCloudMapNamespace?: CloudMapNamespaceOptions;\n\n                                                                                                                                                            \n  readonly capacity?: AddCapacityOptions;\n\n                                                                                                                                                                                                                                 \n  readonly capacityProviders?: string[];\n\n                                                                                      \n  readonly enableFargateCapacityProviders?: boolean;\n\n                                                                                                                                                                \n  readonly containerInsights?: boolean;\n\n                                                                                                                          \n  readonly executeCommandConfiguration?: ExecuteCommandConfiguration;\n}\n\n                                 \nexport enum MachineImageType {\n                                                        \n  AMAZON_LINUX_2,\n                                 \n  BOTTLEROCKET\n}\n\n                                                                                                          \nexport class Cluster extends Resource implements ICluster {\n                                                                             \n  public static fromClusterAttributes(scope: Construct, id: string, attrs: ClusterAttributes): ICluster {\n    return new ImportedCluster(scope, id, attrs);\n  }\n\n                                                                                                                                                                                                                                     \n  public static fromClusterArn(scope: Construct, id: string, clusterArn: string): ICluster {\n    const stack = Stack.of(scope);\n    const arn = stack.splitArn(clusterArn, ArnFormat.SLASH_RESOURCE_NAME);\n    const clusterName = arn.resourceName;\n\n    if (!clusterName) {\n      throw new Error(`Missing required Cluster Name from Cluster ARN: ${clusterArn}`);\n    }\n\n    const errorSuffix = 'is not available for a Cluster imported using fromClusterArn(), please use fromClusterAttributes() instead.';\n\n    class Import extends Resource implements ICluster {\n      public readonly clusterArn = clusterArn;\n      public readonly clusterName = clusterName!;\n      get hasEc2Capacity(): boolean {\n        throw new Error(`hasEc2Capacity ${errorSuffix}`);\n      }\n      get connections(): ec2.Connections {\n        throw new Error(`connections ${errorSuffix}`);\n      }\n      get vpc(): ec2.IVpc {\n        throw new Error(`vpc ${errorSuffix}`);\n      }\n    }\n\n    return new Import(scope, id, {\n      environmentFromArn: clusterArn,\n    });\n  }\n\n                                                                                             \n  public readonly connections: ec2.Connections = new ec2.Connections();\n\n                                                     \n  public readonly vpc: ec2.IVpc;\n\n                                                                            \n  public readonly clusterArn: string;\n\n                                         \n  public readonly clusterName: string;\n\n  /**\n   * The names of both ASG and Fargate capacity providers associated with the cluster.\n   */\n  private _capacityProviderNames: string[] = [];\n\n  /**\n   * The AWS Cloud Map namespace to associate with the cluster.\n   */\n  private _defaultCloudMapNamespace?: cloudmap.INamespace;\n\n  /**\n   * Specifies whether the cluster has EC2 instance capacity.\n   */\n  private _hasEc2Capacity: boolean = false;\n\n  /**\n   * The autoscaling group for added Ec2 capacity\n   */\n  private _autoscalingGroup?: autoscaling.IAutoScalingGroup;\n\n  /**\n   * The execute command configuration for the cluster\n   */\n  private _executeCommandConfiguration?: ExecuteCommandConfiguration;\n\n                                                                \n  constructor(scope: Construct, id: string, props: ClusterProps = {}) {\n    super(scope, id, {\n      physicalName: props.clusterName,\n    });\n\n    /**\n     * clusterSettings needs to be undefined if containerInsights is not explicitly set in order to allow any\n     * containerInsights settings on the account to apply.  See:\n     * https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ecs-cluster-clustersettings.html#cfn-ecs-cluster-clustersettings-value\n    */\n    let clusterSettings = undefined;\n    if (props.containerInsights !== undefined) {\n      clusterSettings = [{ name: 'containerInsights', value: props.containerInsights ? ContainerInsights.ENABLED : ContainerInsights.DISABLED }];\n    }\n\n    this._capacityProviderNames = props.capacityProviders ?? [];\n    if (props.enableFargateCapacityProviders) {\n      this.enableFargateCapacityProviders();\n    }\n\n    if (props.executeCommandConfiguration) {\n      if ((props.executeCommandConfiguration.logging === ExecuteCommandLogging.OVERRIDE) !==\n        (props.executeCommandConfiguration.logConfiguration !== undefined)) {\n        throw new Error('Execute command log configuration must only be specified when logging is OVERRIDE.');\n      }\n      this._executeCommandConfiguration = props.executeCommandConfiguration;\n    }\n\n    const cluster = new CfnCluster(this, 'Resource', {\n      clusterName: this.physicalName,\n      clusterSettings,\n      configuration: this._executeCommandConfiguration && this.renderExecuteCommandConfiguration(),\n    });\n\n    this.clusterArn = this.getResourceArnAttribute(cluster.attrArn, {\n      service: 'ecs',\n      resource: 'cluster',\n      resourceName: this.physicalName,\n    });\n    this.clusterName = this.getResourceNameAttribute(cluster.ref);\n\n    this.vpc = props.vpc || new ec2.Vpc(this, 'Vpc', { maxAzs: 2 });\n\n\n    this._defaultCloudMapNamespace = props.defaultCloudMapNamespace !== undefined\n      ? this.addDefaultCloudMapNamespace(props.defaultCloudMapNamespace)\n      : undefined;\n\n    this._autoscalingGroup = props.capacity !== undefined\n      ? this.addCapacity('DefaultAutoScalingGroup', props.capacity)\n      : undefined;\n\n    // Only create cluster capacity provider associations if there are any EC2\n    // capacity providers. Ordinarily we'd just add the construct to the tree\n    // since it's harmless, but we'd prefer not to add unexpected new\n    // resources to the stack which could surprise users working with\n    // brown-field CDK apps and stacks.\n    Aspects.of(this).add(new MaybeCreateCapacityProviderAssociations(this, id, this._capacityProviderNames));\n  }\n\n                                                                        \n  public enableFargateCapacityProviders() {\n    for (const provider of ['FARGATE', 'FARGATE_SPOT']) {\n      if (!this._capacityProviderNames.includes(provider)) {\n        this._capacityProviderNames.push(provider);\n      }\n    }\n  }\n\n  private renderExecuteCommandConfiguration() : CfnCluster.ClusterConfigurationProperty {\n    return {\n      executeCommandConfiguration: {\n        kmsKeyId: this._executeCommandConfiguration?.kmsKey?.keyArn,\n        logConfiguration: this._executeCommandConfiguration?.logConfiguration && this.renderExecuteCommandLogConfiguration(),\n        logging: this._executeCommandConfiguration?.logging,\n      },\n    };\n  }\n\n  private renderExecuteCommandLogConfiguration(): CfnCluster.ExecuteCommandLogConfigurationProperty {\n    const logConfiguration = this._executeCommandConfiguration?.logConfiguration;\n    if (logConfiguration?.s3EncryptionEnabled && !logConfiguration?.s3Bucket) {\n      throw new Error('You must specify an S3 bucket name in the execute command log configuration to enable S3 encryption.');\n    }\n    if (logConfiguration?.cloudWatchEncryptionEnabled && !logConfiguration?.cloudWatchLogGroup) {\n      throw new Error('You must specify a CloudWatch log group in the execute command log configuration to enable CloudWatch encryption.');\n    }\n    return {\n      cloudWatchEncryptionEnabled: logConfiguration?.cloudWatchEncryptionEnabled,\n      cloudWatchLogGroupName: logConfiguration?.cloudWatchLogGroup?.logGroupName,\n      s3BucketName: logConfiguration?.s3Bucket?.bucketName,\n      s3EncryptionEnabled: logConfiguration?.s3EncryptionEnabled,\n      s3KeyPrefix: logConfiguration?.s3KeyPrefix,\n    };\n  }\n\n                                                                                                                                                                                                               \n  public addDefaultCloudMapNamespace(options: CloudMapNamespaceOptions): cloudmap.INamespace {\n    if (this._defaultCloudMapNamespace !== undefined) {\n      throw new Error('Can only add default namespace once.');\n    }\n\n    const namespaceType = options.type !== undefined\n      ? options.type\n      : cloudmap.NamespaceType.DNS_PRIVATE;\n\n    const sdNamespace = namespaceType === cloudmap.NamespaceType.DNS_PRIVATE ?\n      new cloudmap.PrivateDnsNamespace(this, 'DefaultServiceDiscoveryNamespace', {\n        name: options.name,\n        vpc: this.vpc,\n      }) :\n      new cloudmap.PublicDnsNamespace(this, 'DefaultServiceDiscoveryNamespace', {\n        name: options.name,\n      });\n\n    this._defaultCloudMapNamespace = sdNamespace;\n\n    return sdNamespace;\n  }\n\n                                                      \n  public get defaultCloudMapNamespace(): cloudmap.INamespace | undefined {\n    return this._defaultCloudMapNamespace;\n  }\n\n                                                                                                                                                                                                                                                                                                                      \n  public addCapacity(id: string, options: AddCapacityOptions): autoscaling.AutoScalingGroup {\n    // Do 2-way defaulting here: if the machineImageType is BOTTLEROCKET, pick the right AMI.\n    // Otherwise, determine the machineImageType from the given AMI.\n    const machineImage = options.machineImage ??\n      (options.machineImageType === MachineImageType.BOTTLEROCKET ? new BottleRocketImage({\n        architecture: options.instanceType.architecture,\n      }) : new EcsOptimizedAmi());\n\n    const machineImageType = options.machineImageType ??\n      (isBottleRocketImage(machineImage) ? MachineImageType.BOTTLEROCKET : MachineImageType.AMAZON_LINUX_2);\n\n    const autoScalingGroup = new autoscaling.AutoScalingGroup(this, id, {\n      vpc: this.vpc,\n      machineImage,\n      updateType: options.updateType || autoscaling.UpdateType.REPLACING_UPDATE,\n      ...options,\n    });\n\n    this.addAutoScalingGroup(autoScalingGroup, {\n      machineImageType: machineImageType,\n      ...options,\n    });\n\n    return autoScalingGroup;\n  }\n\n                                                                                                                                                               \n  public addAsgCapacityProvider(provider: AsgCapacityProvider, options: AddAutoScalingGroupCapacityOptions= {}) {\n    // Don't add the same capacity provider more than once.\n    if (this._capacityProviderNames.includes(provider.capacityProviderName)) {\n      return;\n    }\n    this._hasEc2Capacity = true;\n    this.configureAutoScalingGroup(provider.autoScalingGroup, {\n      ...options,\n      machineImageType: provider.machineImageType,\n      // Don't enable the instance-draining lifecycle hook if managed termination protection is enabled\n      taskDrainTime: provider.enableManagedTerminationProtection ? Duration.seconds(0) : options.taskDrainTime,\n    });\n\n    this._capacityProviderNames.push(provider.capacityProviderName);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                      \n  public addAutoScalingGroup(autoScalingGroup: autoscaling.AutoScalingGroup, options: AddAutoScalingGroupCapacityOptions = {}) {\n    this._hasEc2Capacity = true;\n    this.connections.connections.addSecurityGroup(...autoScalingGroup.connections.securityGroups);\n    this.configureAutoScalingGroup(autoScalingGroup, options);\n  }\n\n  private configureAutoScalingGroup(autoScalingGroup: autoscaling.AutoScalingGroup, options: AddAutoScalingGroupCapacityOptions = {}) {\n    if (autoScalingGroup.osType === ec2.OperatingSystemType.WINDOWS) {\n      this.configureWindowsAutoScalingGroup(autoScalingGroup, options);\n    } else {\n      // Tie instances to cluster\n      switch (options.machineImageType) {\n        // Bottlerocket AMI\n        case MachineImageType.BOTTLEROCKET: {\n          autoScalingGroup.addUserData(\n            // Connect to the cluster\n            // Source: https://github.com/bottlerocket-os/bottlerocket/blob/develop/QUICKSTART-ECS.md#connecting-to-your-cluster\n            '[settings.ecs]',\n            `cluster = \"${this.clusterName}\"`,\n          );\n          // Enabling SSM\n          // Source: https://github.com/bottlerocket-os/bottlerocket/blob/develop/QUICKSTART-ECS.md#enabling-ssm\n          autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonSSMManagedInstanceCore'));\n          // required managed policy\n          autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('service-role/AmazonEC2ContainerServiceforEC2Role'));\n          break;\n        }\n        default:\n          // Amazon ECS-optimized AMI for Amazon Linux 2\n          autoScalingGroup.addUserData(`echo ECS_CLUSTER=${this.clusterName} >> /etc/ecs/ecs.config`);\n          if (!options.canContainersAccessInstanceRole) {\n            // Deny containers access to instance metadata service\n            // Source: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html\n            autoScalingGroup.addUserData('sudo iptables --insert FORWARD 1 --in-interface docker+ --destination 169.254.169.254/32 --jump DROP');\n            autoScalingGroup.addUserData('sudo service iptables save');\n            // The following is only for AwsVpc networking mode, but doesn't hurt for the other modes.\n            autoScalingGroup.addUserData('echo ECS_AWSVPC_BLOCK_IMDS=true >> /etc/ecs/ecs.config');\n          }\n\n          if (autoScalingGroup.spotPrice && options.spotInstanceDraining) {\n            autoScalingGroup.addUserData('echo ECS_ENABLE_SPOT_INSTANCE_DRAINING=true >> /etc/ecs/ecs.config');\n          }\n      }\n    }\n\n    // ECS instances must be able to do these things\n    // Source: https://docs.aws.amazon.com/AmazonECS/latest/developerguide/instance_IAM_role.html\n    // But, scoped down to minimal permissions required.\n    //  Notes:\n    //   - 'ecs:CreateCluster' removed. The cluster already exists.\n    autoScalingGroup.addToRolePolicy(new iam.PolicyStatement({\n      actions: [\n        'ecs:DeregisterContainerInstance',\n        'ecs:RegisterContainerInstance',\n        'ecs:Submit*',\n      ],\n      resources: [\n        this.clusterArn,\n      ],\n    }));\n    autoScalingGroup.addToRolePolicy(new iam.PolicyStatement({\n      actions: [\n        // These act on a cluster instance, and the instance doesn't exist until the service starts.\n        // Thus, scope to the cluster using a condition.\n        // See: https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonelasticcontainerservice.html\n        'ecs:Poll',\n        'ecs:StartTelemetrySession',\n      ],\n      resources: ['*'],\n      conditions: {\n        ArnEquals: { 'ecs:cluster': this.clusterArn },\n      },\n    }));\n    autoScalingGroup.addToRolePolicy(new iam.PolicyStatement({\n      actions: [\n        // These do not support resource constraints, and must be resource '*'\n        'ecs:DiscoverPollEndpoint',\n        'ecr:GetAuthorizationToken',\n        // Preserved for backwards compatibility.\n        // Users are able to enable cloudwatch agent using CDK. Existing\n        // customers might be installing CW agent as part of user-data so if we\n        // remove these permissions we will break that customer use cases.\n        'logs:CreateLogStream',\n        'logs:PutLogEvents',\n      ],\n      resources: ['*'],\n    }));\n\n    // 0 disables, otherwise forward to underlying implementation which picks the sane default\n    if (!options.taskDrainTime || options.taskDrainTime.toSeconds() !== 0) {\n      new InstanceDrainHook(autoScalingGroup, 'DrainECSHook', {\n        autoScalingGroup,\n        cluster: this,\n        drainTime: options.taskDrainTime,\n        topicEncryptionKey: options.topicEncryptionKey,\n      });\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                        \n  public addCapacityProvider(provider: string) {\n    if (!(provider === 'FARGATE' || provider === 'FARGATE_SPOT')) {\n      throw new Error('CapacityProvider not supported');\n    }\n\n    if (!this._capacityProviderNames.includes(provider)) {\n      this._capacityProviderNames.push(provider);\n    }\n  }\n\n  private configureWindowsAutoScalingGroup(autoScalingGroup: autoscaling.AutoScalingGroup, options: AddAutoScalingGroupCapacityOptions = {}) {\n    // clear the cache of the agent\n    autoScalingGroup.addUserData('Remove-Item -Recurse C:\\\\ProgramData\\\\Amazon\\\\ECS\\\\Cache');\n\n    // pull the latest ECS Tools\n    autoScalingGroup.addUserData('Import-Module ECSTools');\n\n    // set the cluster name environment variable\n    autoScalingGroup.addUserData(`[Environment]::SetEnvironmentVariable(\"ECS_CLUSTER\", \"${this.clusterName}\", \"Machine\")`);\n    autoScalingGroup.addUserData('[Environment]::SetEnvironmentVariable(\"ECS_ENABLE_AWSLOGS_EXECUTIONROLE_OVERRIDE\", \"true\", \"Machine\")');\n    // tslint:disable-next-line: max-line-length\n    autoScalingGroup.addUserData('[Environment]::SetEnvironmentVariable(\"ECS_AVAILABLE_LOGGING_DRIVERS\", \\'[\"json-file\",\"awslogs\"]\\', \"Machine\")');\n\n    // enable instance draining\n    if (autoScalingGroup.spotPrice && options.spotInstanceDraining) {\n      autoScalingGroup.addUserData('[Environment]::SetEnvironmentVariable(\"ECS_ENABLE_SPOT_INSTANCE_DRAINING\", \"true\", \"Machine\")');\n    }\n\n    // enable task iam role\n    if (!options.canContainersAccessInstanceRole) {\n      autoScalingGroup.addUserData('[Environment]::SetEnvironmentVariable(\"ECS_ENABLE_TASK_IAM_ROLE\", \"true\", \"Machine\")');\n      autoScalingGroup.addUserData(`Initialize-ECSAgent -Cluster '${this.clusterName}' -EnableTaskIAMRole`);\n    } else {\n      autoScalingGroup.addUserData(`Initialize-ECSAgent -Cluster '${this.clusterName}'`);\n    }\n  }\n\n                                                              \n  public get autoscalingGroup(): autoscaling.IAutoScalingGroup | undefined {\n    return this._autoscalingGroup;\n  }\n\n                                                                        \n  public get hasEc2Capacity(): boolean {\n    return this._hasEc2Capacity;\n  }\n\n                                                                                      \n  public get executeCommandConfiguration(): ExecuteCommandConfiguration | undefined {\n    return this._executeCommandConfiguration;\n  }\n\n                                                                                                                                       \n  public metricCpuReservation(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(ECSMetrics.cpuReservationAverage, props);\n  }\n\n                                                                                                                                       \n  public metricCpuUtilization(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(ECSMetrics.cpuUtilizationAverage, props);\n  }\n\n                                                                                                                                          \n  public metricMemoryReservation(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(ECSMetrics.memoryReservationAverage, props);\n  }\n\n                                                                                                                                          \n  public metricMemoryUtilization(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(ECSMetrics.memoryUtilizationAverage, props);\n  }\n\n                                                                                     \n  public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/ECS',\n      metricName,\n      dimensionsMap: { ClusterName: this.clusterName },\n      ...props,\n    }).attachTo(this);\n  }\n\n  private cannedMetric(\n    fn: (dims: { ClusterName: string }) => cloudwatch.MetricProps,\n    props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      ...fn({ ClusterName: this.clusterName }),\n      ...props,\n    }).attachTo(this);\n  }\n}\n\n                                                                                                          \nexport interface ICluster extends IResource {\n                                                         \n  readonly clusterName: string;\n\n                                                                                            \n  readonly clusterArn: string;\n\n                                                     \n  readonly vpc: ec2.IVpc;\n\n                                                                                             \n  readonly connections: ec2.Connections;\n\n                                                                         \n  readonly hasEc2Capacity: boolean;\n\n                                                                           \n  readonly defaultCloudMapNamespace?: cloudmap.INamespace;\n\n                                                                                                    \n  readonly autoscalingGroup?: autoscaling.IAutoScalingGroup;\n\n                                                                  \n  readonly executeCommandConfiguration?: ExecuteCommandConfiguration;\n}\n\n                                                         \nexport interface ClusterAttributes {\n                                         \n  readonly clusterName: string;\n\n                                                                                                                        \n  readonly clusterArn?: string;\n\n                                                     \n  readonly vpc: ec2.IVpc;\n\n                                                                                                       \n  readonly securityGroups: ec2.ISecurityGroup[];\n\n                                                                                                 \n  readonly hasEc2Capacity?: boolean;\n\n                                                                                                                     \n  readonly defaultCloudMapNamespace?: cloudmap.INamespace;\n\n                                                                                                                              \n  readonly autoscalingGroup?: autoscaling.IAutoScalingGroup;\n\n                                                                                             \n  readonly executeCommandConfiguration?: ExecuteCommandConfiguration;\n}\n\n/**\n * An Cluster that has been imported\n */\nclass ImportedCluster extends Resource implements ICluster {\n  /**\n   * Name of the cluster\n   */\n  public readonly clusterName: string;\n\n  /**\n   * ARN of the cluster\n   */\n  public readonly clusterArn: string;\n\n  /**\n   * VPC that the cluster instances are running in\n   */\n  public readonly vpc: ec2.IVpc;\n\n  /**\n   * Security group of the cluster instances\n   */\n  public readonly connections = new ec2.Connections();\n\n  /**\n   * Whether the cluster has EC2 capacity\n   */\n  public readonly hasEc2Capacity: boolean;\n\n  /**\n   * Cloudmap namespace created in the cluster\n   */\n  private _defaultCloudMapNamespace?: cloudmap.INamespace;\n\n  /**\n   * The execute command configuration for the cluster\n   */\n  private _executeCommandConfiguration?: ExecuteCommandConfiguration;\n\n  /**\n   * Constructs a new instance of the ImportedCluster class.\n   */\n  constructor(scope: Construct, id: string, props: ClusterAttributes) {\n    super(scope, id);\n    this.clusterName = props.clusterName;\n    this.vpc = props.vpc;\n    this.hasEc2Capacity = props.hasEc2Capacity !== false;\n    this._defaultCloudMapNamespace = props.defaultCloudMapNamespace;\n    this._executeCommandConfiguration = props.executeCommandConfiguration;\n\n    this.clusterArn = props.clusterArn ?? Stack.of(this).formatArn({\n      service: 'ecs',\n      resource: 'cluster',\n      resourceName: props.clusterName,\n    });\n\n    this.connections = new ec2.Connections({\n      securityGroups: props.securityGroups,\n    });\n  }\n\n  public get defaultCloudMapNamespace(): cloudmap.INamespace | undefined {\n    return this._defaultCloudMapNamespace;\n  }\n\n  public get executeCommandConfiguration(): ExecuteCommandConfiguration | undefined {\n    return this._executeCommandConfiguration;\n  }\n}\n\n                                                         \nexport interface AddAutoScalingGroupCapacityOptions {\n                                                                                                                  \n  readonly canContainersAccessInstanceRole?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  readonly taskDrainTime?: Duration;\n\n                                                                                                                                                                                                                                                                                       \n  readonly spotInstanceDraining?: boolean\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly topicEncryptionKey?: kms.IKey;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly machineImageType?: MachineImageType;\n}\n\n                                                                              \nexport interface AddCapacityOptions extends AddAutoScalingGroupCapacityOptions, autoscaling.CommonAutoScalingGroupProps {\n                                                                                                 \n  readonly instanceType: ec2.InstanceType;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \n  readonly machineImage?: ec2.IMachineImage;\n}\n\n                                                               \nexport interface CloudMapNamespaceOptions {\n                                                                \n  readonly name: string;\n\n                                                                                        \n  readonly type?: cloudmap.NamespaceType;\n\n                                                                                                                                                                                               \n  readonly vpc?: ec2.IVpc;\n}\n\nenum ContainerInsights {\n  /**\n   * Enable CloudWatch Container Insights for the cluster\n   */\n\n  ENABLED = 'enabled',\n\n  /**\n   * Disable CloudWatch Container Insights for the cluster\n   */\n  DISABLED = 'disabled',\n}\n\n                                                                                                                                               \nexport interface CapacityProviderStrategy {\n                                                   \n  readonly capacityProvider: string;\n\n                                                                                                                                                                                                                                                                                                     \n  readonly base?: number;\n\n                                                                                                                                                                                                                                                                                    \n  readonly weight?: number;\n}\n\n                                                                                                                                                                                                                                                  \nexport interface ExecuteCommandConfiguration {\n                                                                                                                                                \n  readonly kmsKey?: kms.IKey,\n\n                                                                                                                                                                                \n  readonly logConfiguration?: ExecuteCommandLogConfiguration,\n\n                                                                                                           \n  readonly logging?: ExecuteCommandLogging,\n}\n\n                                                                                                                                                                                                                                                                                                    \nexport enum ExecuteCommandLogging {\n                                                           \n  NONE = 'NONE',\n\n                                                                                                                                                                                                                                      \n  DEFAULT = 'DEFAULT',\n\n                                                                           \n  OVERRIDE = 'OVERRIDE',\n}\n\n                                                                                                                                                                                                                                                                                                                                                 \nexport interface ExecuteCommandLogConfiguration {\n                                                                                                                              \n  readonly cloudWatchEncryptionEnabled?: boolean,\n\n                                                                                                                                             \n  readonly cloudWatchLogGroup?: logs.ILogGroup,\n\n                                                                                                                            \n  readonly s3Bucket?: s3.IBucket,\n\n                                                                                                                              \n  readonly s3EncryptionEnabled?: boolean,\n\n                                                                                                \n  readonly s3KeyPrefix?: string\n}\n\n                                                                            \nexport interface AsgCapacityProviderProps extends AddAutoScalingGroupCapacityOptions {\n                                                                                                                                                                                                                                                                                                \n  readonly capacityProviderName?: string;\n\n                                                                     \n  readonly autoScalingGroup: autoscaling.IAutoScalingGroup;\n\n                                                                          \n  readonly enableManagedScaling?: boolean;\n\n                                                                                         \n  readonly enableManagedTerminationProtection?: boolean;\n\n                                                                                                            \n  readonly maximumScalingStepSize?: number;\n\n                                                                                                         \n  readonly minimumScalingStepSize?: number;\n\n                                                                                                         \n  readonly targetCapacityPercent?: number;\n}\n\n                                                                                                                                                                                                                                                                                                                                                                              \nexport class AsgCapacityProvider extends Construct {\n                                                                              \n  readonly capacityProviderName: string;\n\n                                   \n  readonly autoScalingGroup: autoscaling.AutoScalingGroup;\n\n                                                     \n  readonly machineImageType: MachineImageType;\n\n                                                                  \n  readonly enableManagedTerminationProtection?: boolean;\n\n  constructor(scope: Construct, id: string, props: AsgCapacityProviderProps) {\n    super(scope, id);\n\n    this.autoScalingGroup = props.autoScalingGroup as autoscaling.AutoScalingGroup;\n\n    this.machineImageType = props.machineImageType ?? MachineImageType.AMAZON_LINUX_2;\n\n    this.enableManagedTerminationProtection =\n      props.enableManagedTerminationProtection === undefined ? true : props.enableManagedTerminationProtection;\n\n    if (this.enableManagedTerminationProtection) {\n      this.autoScalingGroup.protectNewInstancesFromScaleIn();\n    }\n    if (props.capacityProviderName) {\n      if (!(/^(?!aws|ecs|fargate).+/gm.test(props.capacityProviderName))) {\n        throw new Error(`Invalid Capacity Provider Name: ${props.capacityProviderName}, If a name is specified, it cannot start with aws, ecs, or fargate.`);\n      }\n    }\n    const capacityProvider = new CfnCapacityProvider(this, id, {\n      name: props.capacityProviderName,\n      autoScalingGroupProvider: {\n        autoScalingGroupArn: this.autoScalingGroup.autoScalingGroupName,\n        managedScaling: props.enableManagedScaling === false ? undefined : {\n          status: 'ENABLED',\n          targetCapacity: props.targetCapacityPercent || 100,\n          maximumScalingStepSize: props.maximumScalingStepSize,\n          minimumScalingStepSize: props.minimumScalingStepSize,\n        },\n        managedTerminationProtection: this.enableManagedTerminationProtection ? 'ENABLED' : 'DISABLED',\n      },\n    });\n\n    this.capacityProviderName = capacityProvider.ref;\n  }\n}\n\n/**\n * A visitor that adds a capacity provider association to a Cluster only if\n * the caller created any EC2 Capacity Providers.\n */\nclass MaybeCreateCapacityProviderAssociations implements IAspect {\n  private scope: Construct;\n  private id: string;\n  private capacityProviders: string[]\n  private resource?: CfnClusterCapacityProviderAssociations\n\n  constructor(scope: Construct, id: string, capacityProviders: string[] ) {\n    this.scope = scope;\n    this.id = id;\n    this.capacityProviders = capacityProviders;\n  }\n\n  public visit(node: IConstruct): void {\n    if (node instanceof Cluster) {\n      if (this.capacityProviders.length > 0 && !this.resource) {\n        const resource = new CfnClusterCapacityProviderAssociations(this.scope, this.id, {\n          cluster: node.clusterName,\n          defaultCapacityProviderStrategy: [],\n          capacityProviders: Lazy.list({ produce: () => this.capacityProviders }),\n        });\n        this.resource = resource;\n      }\n    }\n  }\n}\n\n\nfunction isBottleRocketImage(image: ec2.IMachineImage) {\n  return image instanceof BottleRocketImage;\n}\n"],
  "mappings": "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",
  "names": []
}
