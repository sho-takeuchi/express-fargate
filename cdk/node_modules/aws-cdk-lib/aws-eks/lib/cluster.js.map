{
  "version": 3,
  "sources": ["cluster.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as path from 'path';\nimport * as autoscaling from '../../aws-autoscaling';\nimport * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as kms from '../../aws-kms';\nimport * as lambda from '../../aws-lambda';\nimport * as ssm from '../../aws-ssm';\nimport { Annotations, CfnOutput, CfnResource, IResource, Resource, Stack, Tags, Token, Duration, Size } from '../../core';\nimport { Construct, Node } from 'constructs';\nimport * as YAML from 'yaml';\nimport { AlbController, AlbControllerOptions } from './alb-controller';\nimport { AwsAuth } from './aws-auth';\nimport { ClusterResource, clusterArnComponents } from './cluster-resource';\nimport { FargateProfile, FargateProfileOptions } from './fargate-profile';\nimport { HelmChart, HelmChartOptions } from './helm-chart';\nimport { INSTANCE_TYPES } from './instance-types';\nimport { KubernetesManifest, KubernetesManifestOptions } from './k8s-manifest';\nimport { KubernetesObjectValue } from './k8s-object-value';\nimport { KubernetesPatch } from './k8s-patch';\nimport { IKubectlProvider, KubectlProvider } from './kubectl-provider';\nimport { Nodegroup, NodegroupOptions } from './managed-nodegroup';\nimport { OpenIdConnectProvider } from './oidc-provider';\nimport { BottleRocketImage } from './private/bottlerocket';\nimport { ServiceAccount, ServiceAccountOptions } from './service-account';\nimport { LifecycleLabel, renderAmazonLinuxUserData, renderBottlerocketUserData } from './user-data';\n\n// defaults are based on https://eksctl.io\nconst DEFAULT_CAPACITY_COUNT = 2;\nconst DEFAULT_CAPACITY_TYPE = ec2.InstanceType.of(ec2.InstanceClass.M5, ec2.InstanceSize.LARGE);\n\n                         \nexport interface ICluster extends IResource, ec2.IConnectable {\n                                                          \n  readonly vpc: ec2.IVpc;\n\n                                                                 \n  readonly clusterName: string;\n\n                                                                                                               \n  readonly clusterArn: string;\n\n                                                            \n  readonly clusterEndpoint: string;\n\n                                                                                 \n  readonly clusterCertificateAuthorityData: string;\n\n                                                                                                                     \n  readonly clusterSecurityGroupId: string;\n\n                                                                                                           \n  readonly clusterSecurityGroup: ec2.ISecurityGroup;\n\n                                                                                                      \n  readonly clusterEncryptionConfigKeyArn: string;\n\n                                                                                                \n  readonly openIdConnectProvider: iam.IOpenIdConnectProvider;\n\n                                                                                                                                                                        \n  readonly kubectlRole?: iam.IRole;\n\n                                                                                          \n  readonly kubectlEnvironment?: { [key: string]: string };\n\n                                                                                                                                                              \n  readonly kubectlSecurityGroup?: ec2.ISecurityGroup;\n\n                                                                                                                                                              \n  readonly kubectlPrivateSubnets?: ec2.ISubnet[];\n\n                                                                                                                                                                                                                                                                                  \n  readonly kubectlLambdaRole?: iam.IRole;\n\n                                                                                                                                               \n  readonly kubectlLayer?: lambda.ILayerVersion;\n\n                                                                                                                                   \n  readonly kubectlProvider?: IKubectlProvider;\n\n                                                                                \n  readonly kubectlMemory?: Size;\n\n                                                                                                                                                                                                                                                                                         \n  readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n\n                                                                                                                                            \n  readonly onEventLayer?: lambda.ILayerVersion;\n\n                                                                                                                                                                                                                                                                                                      \n  readonly prune: boolean;\n\n                                                                                                                                                                                \n  addServiceAccount(id: string, options?: ServiceAccountOptions): ServiceAccount;\n\n                                                                                                                                                                                                                                                                                                      \n  addManifest(id: string, ...manifest: Record<string, any>[]): KubernetesManifest;\n\n                                                                                                                                                                                     \n  addHelmChart(id: string, options: HelmChartOptions): HelmChart;\n\n                                                                                                                                                                                                               \n  addCdk8sChart(id: string, chart: Construct, options?: KubernetesManifestOptions): KubernetesManifest;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  connectAutoScalingGroupCapacity(autoScalingGroup: autoscaling.AutoScalingGroup, options: AutoScalingGroupOptions): void;\n}\n\n                                       \nexport interface ClusterAttributes {\n                                                                                                                             \n  readonly vpc?: ec2.IVpc;\n\n                                                 \n  readonly clusterName: string;\n\n                                                                                                                            \n  readonly clusterEndpoint?: string;\n\n                                                                                                                                                                     \n  readonly clusterCertificateAuthorityData?: string;\n\n                                                                                                                                                                                      \n  readonly clusterSecurityGroupId?: string;\n\n                                                                                                                                                                                        \n  readonly clusterEncryptionConfigKeyArn?: string;\n\n                                                                                                                                                                                           \n  readonly securityGroupIds?: string[];\n\n                                                                                                                                                                                                            \n  readonly kubectlRoleArn?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly kubectlLambdaRole?: iam.IRole;\n\n                                                                                                                                  \n  readonly kubectlEnvironment?: { [name: string]: string };\n\n                                                                                                                                                                                                                   \n  readonly kubectlSecurityGroupId?: string;\n\n                                                                                                                                                                                                                   \n  readonly kubectlPrivateSubnetIds?: string[];\n\n                                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly openIdConnectProvider?: iam.IOpenIdConnectProvider;\n\n                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly kubectlLayer?: lambda.ILayerVersion;\n\n                                                                                                        \n  readonly kubectlProvider?: IKubectlProvider;\n\n                                                                                                                     \n  readonly kubectlMemory?: Size;\n\n                                                                                                                                                                                                           \n  readonly clusterHandlerSecurityGroupId?: string;\n\n                                                                                                                                                                                                                                                                                                                                              \n  readonly onEventLayer?: lambda.ILayerVersion;\n\n                                                                                                                                                                                                                                                                                                                                                            \n  readonly prune?: boolean;\n}\n\n                                                  \nexport interface CommonClusterOptions {\n                                                                                                                                                                         \n  readonly vpc?: ec2.IVpc;\n\n                                                                                                                                                                                                                                                                                                                                                 \n  readonly vpcSubnets?: ec2.SubnetSelection[];\n\n                                                                                                                                                                                                 \n  readonly role?: iam.IRole;\n\n                                                                                        \n  readonly clusterName?: string;\n\n                                                                                                                            \n  readonly securityGroup?: ec2.ISecurityGroup;\n\n                                                             \n  readonly version: KubernetesVersion;\n\n                                                                                                                                           \n  readonly outputClusterName?: boolean;\n\n                                                                                                                                                                                                                                                               \n  readonly outputConfigCommand?: boolean;\n}\n\n                                    \nexport interface ClusterOptions extends CommonClusterOptions {\n                                                                                                                                                                                                                                                                                                                                             \n  readonly mastersRole?: iam.IRole;\n\n                                                                                                                                                                                                                                                                            \n  readonly coreDnsComputeType?: CoreDnsComputeType;\n\n                                                                                                                                                                                     \n  readonly outputMastersRoleArn?: boolean;\n\n                                                                                                                                                                                                                    \n  readonly endpointAccess?: EndpointAccess;\n\n                                                                                                                                                            \n  readonly kubectlEnvironment?: { [key: string]: string };\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly kubectlLayer?: lambda.ILayerVersion;\n\n                                                                                                                     \n  readonly kubectlMemory?: Size;\n\n                                                                                                                                                                    \n  readonly clusterHandlerEnvironment?: { [key: string]: string };\n\n                                                                                                                                                                                                                                                                         \n  readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \n  readonly onEventLayer?: lambda.ILayerVersion;\n\n                                                                                                                                                                                                                                                                                                                                                            \n  readonly prune?: boolean;\n\n                                                                                                                                                                                                      \n  readonly placeClusterHandlerInVpc?: boolean;\n\n                                                                                                                                                                                                                                                                                                            \n  readonly secretsEncryptionKey?: kms.IKey;\n\n                                                                                                                                                                                                                                                                                                                                                                                \n  readonly serviceIpv4Cidr?: string;\n\n                                                                                                                                                                                                               \n  readonly albController?: AlbControllerOptions;\n}\n\n/**\n * Group access configuration together.\n */\ninterface EndpointAccessConfig {\n\n  /**\n   * Indicates if private access is enabled.\n   */\n  readonly privateAccess: boolean;\n\n  /**\n   * Indicates if public access is enabled.\n   */\n  readonly publicAccess: boolean;\n  /**\n   * Public access is allowed only from these CIDR blocks.\n   * An empty array means access is open to any address.\n   *\n   * @default - No restrictions.\n   */\n  readonly publicCidrs?: string[];\n\n}\n\n                                           \nexport class EndpointAccess {\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  public static readonly PUBLIC = new EndpointAccess({ privateAccess: false, publicAccess: true });\n\n                                                                                                                                              \n  public static readonly PRIVATE = new EndpointAccess({ privateAccess: true, publicAccess: false });\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  public static readonly PUBLIC_AND_PRIVATE = new EndpointAccess({ privateAccess: true, publicAccess: true });\n\n  private constructor(\n    /**\n     * Configuration properties.\n     *\n     * @internal\n     */\n    public readonly _config: EndpointAccessConfig) {\n    if (!_config.publicAccess && _config.publicCidrs && _config.publicCidrs.length > 0) {\n      throw new Error('CIDR blocks can only be configured when public access is enabled');\n    }\n  }\n\n\n                                                                                                                                                                           \n  public onlyFrom(...cidr: string[]) {\n    if (!this._config.privateAccess) {\n      // when private access is disabled, we can't restric public\n      // access since it will render the kubectl provider unusable.\n      throw new Error('Cannot restric public access to endpoint when private access is disabled. Use PUBLIC_AND_PRIVATE.onlyFrom() instead.');\n    }\n    return new EndpointAccess({\n      ...this._config,\n      // override CIDR\n      publicCidrs: cidr,\n    });\n  }\n}\n\n                                                       \nexport interface ClusterProps extends ClusterOptions {\n\n                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly defaultCapacity?: number;\n\n                                                                                                                                                                      \n  readonly defaultCapacityInstance?: ec2.InstanceType;\n\n                                                                                        \n  readonly defaultCapacityType?: DefaultCapacityType;\n\n                                                                                                                           \n  readonly kubectlLambdaRole?: iam.IRole;\n\n                                                                               \n  readonly tags?: { [key: string]: string };\n\n                                                                                          \n  readonly clusterLogging?: ClusterLoggingTypes[];\n}\n\n                                     \nexport class KubernetesVersion {\n                                        \n  public static readonly V1_14 = KubernetesVersion.of('1.14');\n\n                                        \n  public static readonly V1_15 = KubernetesVersion.of('1.15');\n\n                                        \n  public static readonly V1_16 = KubernetesVersion.of('1.16');\n\n                                        \n  public static readonly V1_17 = KubernetesVersion.of('1.17');\n\n                                        \n  public static readonly V1_18 = KubernetesVersion.of('1.18');\n\n                                        \n  public static readonly V1_19 = KubernetesVersion.of('1.19');\n\n                                        \n  public static readonly V1_20 = KubernetesVersion.of('1.20');\n\n                                        \n  public static readonly V1_21 = KubernetesVersion.of('1.21');\n\n                                                                                 \n  public static of(version: string) { return new KubernetesVersion(version); }\n  /**\n   *\n   * @param version cluster version number\n   */\n  private constructor(public readonly version: string) { }\n}\n\n                                    \nexport enum ClusterLoggingTypes {\n                                                                \n  API = 'api',\n                                                                          \n  AUDIT = 'audit',\n                                                                             \n  AUTHENTICATOR = 'authenticator',\n                                                                 \n  CONTROLLER_MANAGER = 'controllerManager',\n                                                         \n  SCHEDULER = 'scheduler',\n}\n\nabstract class ClusterBase extends Resource implements ICluster {\n  public abstract readonly connections: ec2.Connections;\n  public abstract readonly vpc: ec2.IVpc;\n  public abstract readonly clusterName: string;\n  public abstract readonly clusterArn: string;\n  public abstract readonly clusterEndpoint: string;\n  public abstract readonly clusterCertificateAuthorityData: string;\n  public abstract readonly clusterSecurityGroupId: string;\n  public abstract readonly clusterSecurityGroup: ec2.ISecurityGroup;\n  public abstract readonly clusterEncryptionConfigKeyArn: string;\n  public abstract readonly kubectlRole?: iam.IRole;\n  public abstract readonly kubectlLambdaRole?: iam.IRole;\n  public abstract readonly kubectlEnvironment?: { [key: string]: string };\n  public abstract readonly kubectlSecurityGroup?: ec2.ISecurityGroup;\n  public abstract readonly kubectlPrivateSubnets?: ec2.ISubnet[];\n  public abstract readonly kubectlMemory?: Size;\n  public abstract readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n  public abstract readonly prune: boolean;\n  public abstract readonly openIdConnectProvider: iam.IOpenIdConnectProvider;\n  public abstract readonly awsAuth: AwsAuth;\n\n  private _spotInterruptHandler?: HelmChart;\n\n  /**\n   * Manages the aws-auth config map.\n   *\n   * @internal\n   */\n  protected _awsAuth?: AwsAuth;\n\n                                                                                                                                                                                                                                                                                                      \n  public addManifest(id: string, ...manifest: Record<string, any>[]): KubernetesManifest {\n    return new KubernetesManifest(this, `manifest-${id}`, { cluster: this, manifest });\n  }\n\n                                                                                                                                                                                     \n  public addHelmChart(id: string, options: HelmChartOptions): HelmChart {\n    return new HelmChart(this, `chart-${id}`, { cluster: this, ...options });\n  }\n\n                                                                                                                                                                                                               \n  public addCdk8sChart(id: string, chart: Construct, options: KubernetesManifestOptions = {}): KubernetesManifest {\n\n    const cdk8sChart = chart as any;\n\n    // see https://github.com/awslabs/cdk8s/blob/master/packages/cdk8s/src/chart.ts#L84\n    if (typeof cdk8sChart.toJson !== 'function') {\n      throw new Error(`Invalid cdk8s chart. Must contain a 'toJson' method, but found ${typeof cdk8sChart.toJson}`);\n    }\n\n    const manifest = new KubernetesManifest(this, id, {\n      cluster: this,\n      manifest: cdk8sChart.toJson(),\n      ...options,\n    });\n\n    return manifest;\n  }\n\n  public addServiceAccount(id: string, options: ServiceAccountOptions = {}): ServiceAccount {\n    return new ServiceAccount(this, id, {\n      ...options,\n      cluster: this,\n    });\n  }\n\n  /**\n   * Installs the AWS spot instance interrupt handler on the cluster if it's not\n   * already added.\n   */\n  private addSpotInterruptHandler() {\n    if (!this._spotInterruptHandler) {\n      this._spotInterruptHandler = this.addHelmChart('spot-interrupt-handler', {\n        chart: 'aws-node-termination-handler',\n        version: '0.13.2',\n        repository: 'https://aws.github.io/eks-charts',\n        namespace: 'kube-system',\n        values: {\n          nodeSelector: {\n            lifecycle: LifecycleLabel.SPOT,\n          },\n        },\n      });\n    }\n\n    return this._spotInterruptHandler;\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  public connectAutoScalingGroupCapacity(autoScalingGroup: autoscaling.AutoScalingGroup, options: AutoScalingGroupOptions) {\n    // self rules\n    autoScalingGroup.connections.allowInternally(ec2.Port.allTraffic());\n\n    // Cluster to:nodes rules\n    autoScalingGroup.connections.allowFrom(this, ec2.Port.tcp(443));\n    autoScalingGroup.connections.allowFrom(this, ec2.Port.tcpRange(1025, 65535));\n\n    // Allow HTTPS from Nodes to Cluster\n    autoScalingGroup.connections.allowTo(this, ec2.Port.tcp(443));\n\n    // Allow all node outbound traffic\n    autoScalingGroup.connections.allowToAnyIpv4(ec2.Port.allTcp());\n    autoScalingGroup.connections.allowToAnyIpv4(ec2.Port.allUdp());\n    autoScalingGroup.connections.allowToAnyIpv4(ec2.Port.allIcmp());\n\n    // allow traffic to/from managed node groups (eks attaches this security group to the managed nodes)\n    autoScalingGroup.addSecurityGroup(this.clusterSecurityGroup);\n\n    const bootstrapEnabled = options.bootstrapEnabled ?? true;\n    if (options.bootstrapOptions && !bootstrapEnabled) {\n      throw new Error('Cannot specify \"bootstrapOptions\" if \"bootstrapEnabled\" is false');\n    }\n\n    if (bootstrapEnabled) {\n      const userData = options.machineImageType === MachineImageType.BOTTLEROCKET ?\n        renderBottlerocketUserData(this) :\n        renderAmazonLinuxUserData(this, autoScalingGroup, options.bootstrapOptions);\n      autoScalingGroup.addUserData(...userData);\n    }\n\n    autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEKSWorkerNodePolicy'));\n    autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEKS_CNI_Policy'));\n    autoScalingGroup.role.addManagedPolicy(iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEC2ContainerRegistryReadOnly'));\n\n    // EKS Required Tags\n    // https://docs.aws.amazon.com/eks/latest/userguide/worker.html\n    Tags.of(autoScalingGroup).add(`kubernetes.io/cluster/${this.clusterName}`, 'owned', {\n      applyToLaunchedInstances: true,\n      // exclude security groups to avoid multiple \"owned\" security groups.\n      // (the cluster security group already has this tag)\n      excludeResourceTypes: ['AWS::EC2::SecurityGroup'],\n    });\n\n    // do not attempt to map the role if `kubectl` is not enabled for this\n    // cluster or if `mapRole` is set to false. By default this should happen.\n    let mapRole = options.mapRole ?? true;\n    if (mapRole && !(this instanceof Cluster)) {\n      // do the mapping...\n      Annotations.of(autoScalingGroup).addWarning('Auto-mapping aws-auth role for imported cluster is not supported, please map role manually');\n      mapRole = false;\n    }\n    if (mapRole) {\n      // see https://docs.aws.amazon.com/en_us/eks/latest/userguide/add-user-role.html\n      this.awsAuth.addRoleMapping(autoScalingGroup.role, {\n        username: 'system:node:{{EC2PrivateDNSName}}',\n        groups: [\n          'system:bootstrappers',\n          'system:nodes',\n        ],\n      });\n    } else {\n      // since we are not mapping the instance role to RBAC, synthesize an\n      // output so it can be pasted into `aws-auth-cm.yaml`\n      new CfnOutput(autoScalingGroup, 'InstanceRoleARN', {\n        value: autoScalingGroup.role.roleArn,\n      });\n    }\n\n    const addSpotInterruptHandler = options.spotInterruptHandler ?? true;\n    // if this is an ASG with spot instances, install the spot interrupt handler (only if kubectl is enabled).\n    if (autoScalingGroup.spotPrice && addSpotInterruptHandler) {\n      this.addSpotInterruptHandler();\n    }\n\n    if (this instanceof Cluster && this.albController) {\n      // the controller runs on the worker nodes so they cannot\n      // be deleted before the controller.\n      Node.of(this.albController).addDependency(autoScalingGroup);\n    }\n  }\n}\n\n                                                             \nexport interface ServiceLoadBalancerAddressOptions {\n\n                                                                                                         \n  readonly timeout?: Duration;\n\n                                                                                   \n  readonly namespace?: string;\n\n}\n\n                                                              \nexport interface IngressLoadBalancerAddressOptions extends ServiceLoadBalancerAddressOptions {};\n\n                                                                                                                                                                                                 \nexport class Cluster extends ClusterBase {\n                                                                                                                                                                                                                                 \n  public static fromClusterAttributes(scope: Construct, id: string, attrs: ClusterAttributes): ICluster {\n    return new ImportedCluster(scope, id, attrs);\n  }\n\n                                                          \n  public readonly vpc: ec2.IVpc;\n\n                                                    \n  public readonly clusterName: string;\n\n                                                                                                                                        \n  public readonly clusterArn: string;\n\n                                                                                                                                                                                                                            \n  public readonly clusterEndpoint: string;\n\n                                                                 \n  public readonly clusterCertificateAuthorityData: string;\n\n                                                                                                     \n  public readonly clusterSecurityGroupId: string;\n\n                                                                                           \n  public readonly clusterSecurityGroup: ec2.ISecurityGroup;\n\n                                                                                      \n  public readonly clusterEncryptionConfigKeyArn: string;\n\n                                                                                                                                         \n  public readonly connections: ec2.Connections;\n\n                                                          \n  public readonly role: iam.IRole;\n\n                                                                                                                                                                                                                                          \n  public readonly defaultCapacity?: autoscaling.AutoScalingGroup;\n\n                                                                                                                                                                                                                                    \n  public readonly defaultNodegroup?: Nodegroup;\n\n                                                                                                                                                                        \n  public readonly kubectlRole?: iam.IRole;\n\n                                                                                                                                                                                                                                                                                                                                                                                     \n\n  public readonly kubectlLambdaRole?: iam.IRole;\n\n                                                                                          \n  public readonly kubectlEnvironment?: { [key: string]: string };\n\n                                                                                                                                                                     \n  public readonly kubectlSecurityGroup?: ec2.ISecurityGroup;\n\n                                                                                                                                                                     \n  public readonly kubectlPrivateSubnets?: ec2.ISubnet[];\n\n                                                                                                                                                   \n  public readonly adminRole: iam.Role;\n\n  /**\n   * If the cluster has one (or more) FargateProfiles associated, this array\n   * will hold a reference to each.\n   */\n  private readonly _fargateProfiles: FargateProfile[] = [];\n\n  /**\n   * an Open ID Connect Provider instance\n   */\n  private _openIdConnectProvider?: iam.IOpenIdConnectProvider;\n\n                                                                                                                                                          \n  public readonly kubectlLayer?: lambda.ILayerVersion;\n\n                                                                                          \n  public readonly kubectlMemory?: Size;\n\n                                                                                                                                                                                                                                                                         \n  public readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup;\n\n                                                                                                                                                         \n  readonly onEventLayer?: lambda.ILayerVersion;\n\n                                                                                \n  public readonly prune: boolean;\n\n                                                                                                                                    \n  public readonly albController?: AlbController;\n\n  /**\n   * If this cluster is kubectl-enabled, returns the `ClusterResource` object\n   * that manages it. If this cluster is not kubectl-enabled (i.e. uses the\n   * stock `CfnCluster`), this is `undefined`.\n   */\n  private readonly _clusterResource: ClusterResource;\n\n  private _neuronDevicePlugin?: KubernetesManifest;\n\n  private readonly endpointAccess: EndpointAccess;\n\n  private readonly vpcSubnets: ec2.SubnetSelection[];\n\n  private readonly version: KubernetesVersion;\n\n  private readonly logging?: { [key: string]: [ { [key: string]: any } ] };\n\n  /**\n   * A dummy CloudFormation resource that is used as a wait barrier which\n   * represents that the cluster is ready to receive \"kubectl\" commands.\n   *\n   * Specifically, all fargate profiles are automatically added as a dependency\n   * of this barrier, which means that it will only be \"signaled\" when all\n   * fargate profiles have been successfully created.\n   *\n   * When kubectl resources call `_attachKubectlResourceScope()`, this resource\n   * is added as their dependency which implies that they can only be deployed\n   * after the cluster is ready.\n   */\n  private readonly _kubectlReadyBarrier: CfnResource;\n\n  private readonly _kubectlResourceProvider: KubectlProvider;\n\n                                                                                                                                                                                                                                                      \n  constructor(scope: Construct, id: string, props: ClusterProps) {\n    super(scope, id, {\n      physicalName: props.clusterName,\n    });\n\n    const stack = Stack.of(this);\n\n    this.prune = props.prune ?? true;\n    this.vpc = props.vpc || new ec2.Vpc(this, 'DefaultVpc');\n    this.version = props.version;\n    this.kubectlLambdaRole = props.kubectlLambdaRole ? props.kubectlLambdaRole : undefined;\n\n    this.tagSubnets();\n\n    // this is the role used by EKS when interacting with AWS resources\n    this.role = props.role || new iam.Role(this, 'Role', {\n      assumedBy: new iam.ServicePrincipal('eks.amazonaws.com'),\n      managedPolicies: [\n        iam.ManagedPolicy.fromAwsManagedPolicyName('AmazonEKSClusterPolicy'),\n      ],\n    });\n\n    const securityGroup = props.securityGroup || new ec2.SecurityGroup(this, 'ControlPlaneSecurityGroup', {\n      vpc: this.vpc,\n      description: 'EKS Control Plane Security Group',\n    });\n\n    this.vpcSubnets = props.vpcSubnets ?? [{ subnetType: ec2.SubnetType.PUBLIC }, { subnetType: ec2.SubnetType.PRIVATE }];\n\n    const selectedSubnetIdsPerGroup = this.vpcSubnets.map(s => this.vpc.selectSubnets(s).subnetIds);\n    if (selectedSubnetIdsPerGroup.some(Token.isUnresolved) && selectedSubnetIdsPerGroup.length > 1) {\n      throw new Error('eks.Cluster: cannot select multiple subnet groups from a VPC imported from list tokens with unknown length. Select only one subnet group, pass a length to Fn.split, or switch to Vpc.fromLookup.');\n    }\n\n    // Get subnetIds for all selected subnets\n    const subnetIds = Array.from(new Set(flatten(selectedSubnetIdsPerGroup)));\n\n    this.logging = props.clusterLogging ? {\n      clusterLogging: [\n        {\n          enabled: true,\n          types: Object.values(props.clusterLogging),\n        },\n      ],\n    } : undefined;\n\n    this.endpointAccess = props.endpointAccess ?? EndpointAccess.PUBLIC_AND_PRIVATE;\n    this.kubectlEnvironment = props.kubectlEnvironment;\n    this.kubectlLayer = props.kubectlLayer;\n    this.kubectlMemory = props.kubectlMemory;\n\n    this.onEventLayer = props.onEventLayer;\n    this.clusterHandlerSecurityGroup = props.clusterHandlerSecurityGroup;\n\n    const privateSubnets = this.selectPrivateSubnets().slice(0, 16);\n    const publicAccessDisabled = !this.endpointAccess._config.publicAccess;\n    const publicAccessRestricted = !publicAccessDisabled\n      && this.endpointAccess._config.publicCidrs\n      && this.endpointAccess._config.publicCidrs.length !== 0;\n\n    // validate endpoint access configuration\n\n    if (privateSubnets.length === 0 && publicAccessDisabled) {\n      // no private subnets and no public access at all, no good.\n      throw new Error('Vpc must contain private subnets when public endpoint access is disabled');\n    }\n\n    if (privateSubnets.length === 0 && publicAccessRestricted) {\n      // no private subnets and public access is restricted, no good.\n      throw new Error('Vpc must contain private subnets when public endpoint access is restricted');\n    }\n\n    const placeClusterHandlerInVpc = props.placeClusterHandlerInVpc ?? false;\n\n    if (placeClusterHandlerInVpc && privateSubnets.length === 0) {\n      throw new Error('Cannot place cluster handler in the VPC since no private subnets could be selected');\n    }\n\n    if (props.clusterHandlerSecurityGroup && !placeClusterHandlerInVpc) {\n      throw new Error('Cannot specify clusterHandlerSecurityGroup without placeClusterHandlerInVpc set to true');\n    }\n\n    const resource = this._clusterResource = new ClusterResource(this, 'Resource', {\n      name: this.physicalName,\n      environment: props.clusterHandlerEnvironment,\n      roleArn: this.role.roleArn,\n      version: props.version.version,\n      resourcesVpcConfig: {\n        securityGroupIds: [securityGroup.securityGroupId],\n        subnetIds,\n      },\n      ...(props.secretsEncryptionKey ? {\n        encryptionConfig: [{\n          provider: {\n            keyArn: props.secretsEncryptionKey.keyArn,\n          },\n          resources: ['secrets'],\n        }],\n      } : {}),\n      kubernetesNetworkConfig: props.serviceIpv4Cidr ? {\n        serviceIpv4Cidr: props.serviceIpv4Cidr,\n      } : undefined,\n      endpointPrivateAccess: this.endpointAccess._config.privateAccess,\n      endpointPublicAccess: this.endpointAccess._config.publicAccess,\n      publicAccessCidrs: this.endpointAccess._config.publicCidrs,\n      secretsEncryptionKey: props.secretsEncryptionKey,\n      vpc: this.vpc,\n      subnets: placeClusterHandlerInVpc ? privateSubnets : undefined,\n      clusterHandlerSecurityGroup: this.clusterHandlerSecurityGroup,\n      onEventLayer: this.onEventLayer,\n      tags: props.tags,\n      logging: this.logging,\n    });\n\n    if (this.endpointAccess._config.privateAccess && privateSubnets.length !== 0) {\n\n      // when private access is enabled and the vpc has private subnets, lets connect\n      // the provider to the vpc so that it will work even when restricting public access.\n\n      // validate VPC properties according to: https://docs.aws.amazon.com/eks/latest/userguide/cluster-endpoint.html\n      if (this.vpc instanceof ec2.Vpc && !(this.vpc.dnsHostnamesEnabled && this.vpc.dnsSupportEnabled)) {\n        throw new Error('Private endpoint access requires the VPC to have DNS support and DNS hostnames enabled. Use `enableDnsHostnames: true` and `enableDnsSupport: true` when creating the VPC.');\n      }\n\n      this.kubectlPrivateSubnets = privateSubnets;\n\n      // the vpc must exist in order to properly delete the cluster (since we run `kubectl delete`).\n      // this ensures that.\n      this._clusterResource.node.addDependency(this.vpc);\n    }\n\n    this.adminRole = resource.adminRole;\n\n    // we use an SSM parameter as a barrier because it's free and fast.\n    this._kubectlReadyBarrier = new CfnResource(this, 'KubectlReadyBarrier', {\n      type: 'AWS::SSM::Parameter',\n      properties: {\n        Type: 'String',\n        Value: 'aws:cdk:eks:kubectl-ready',\n      },\n    });\n\n    // add the cluster resource itself as a dependency of the barrier\n    this._kubectlReadyBarrier.node.addDependency(this._clusterResource);\n\n    this.clusterName = this.getResourceNameAttribute(resource.ref);\n    this.clusterArn = this.getResourceArnAttribute(resource.attrArn, clusterArnComponents(this.physicalName));\n\n    this.clusterEndpoint = resource.attrEndpoint;\n    this.clusterCertificateAuthorityData = resource.attrCertificateAuthorityData;\n    this.clusterSecurityGroupId = resource.attrClusterSecurityGroupId;\n    this.clusterEncryptionConfigKeyArn = resource.attrEncryptionConfigKeyArn;\n\n    this.clusterSecurityGroup = ec2.SecurityGroup.fromSecurityGroupId(this, 'ClusterSecurityGroup', this.clusterSecurityGroupId);\n\n    this.connections = new ec2.Connections({\n      securityGroups: [this.clusterSecurityGroup, securityGroup],\n      defaultPort: ec2.Port.tcp(443), // Control Plane has an HTTPS API\n    });\n\n    // we can use the cluster security group since its already attached to the cluster\n    // and configured to allow connections from itself.\n    this.kubectlSecurityGroup = this.clusterSecurityGroup;\n\n    // use the cluster creation role to issue kubectl commands against the cluster because when the\n    // cluster is first created, that's the only role that has \"system:masters\" permissions\n    this.kubectlRole = this.adminRole;\n\n    this._kubectlResourceProvider = this.defineKubectlProvider();\n\n    const updateConfigCommandPrefix = `aws eks update-kubeconfig --name ${this.clusterName}`;\n    const getTokenCommandPrefix = `aws eks get-token --cluster-name ${this.clusterName}`;\n    const commonCommandOptions = [`--region ${stack.region}`];\n\n    if (props.outputClusterName) {\n      new CfnOutput(this, 'ClusterName', { value: this.clusterName });\n    }\n\n    // if an explicit role is not configured, define a masters role that can\n    // be assumed by anyone in the account (with sts:AssumeRole permissions of\n    // course)\n    const mastersRole = props.mastersRole ?? new iam.Role(this, 'MastersRole', {\n      assumedBy: new iam.AccountRootPrincipal(),\n    });\n\n    // map the IAM role to the `system:masters` group.\n    this.awsAuth.addMastersRole(mastersRole);\n\n    if (props.outputMastersRoleArn) {\n      new CfnOutput(this, 'MastersRoleArn', { value: mastersRole.roleArn });\n    }\n\n    commonCommandOptions.push(`--role-arn ${mastersRole.roleArn}`);\n\n    if (props.albController) {\n      this.albController = AlbController.create(this, { ...props.albController, cluster: this });\n    }\n\n    // allocate default capacity if non-zero (or default).\n    const minCapacity = props.defaultCapacity ?? DEFAULT_CAPACITY_COUNT;\n    if (minCapacity > 0) {\n      const instanceType = props.defaultCapacityInstance || DEFAULT_CAPACITY_TYPE;\n      this.defaultCapacity = props.defaultCapacityType === DefaultCapacityType.EC2 ?\n        this.addAutoScalingGroupCapacity('DefaultCapacity', { instanceType, minCapacity }) : undefined;\n\n      this.defaultNodegroup = props.defaultCapacityType !== DefaultCapacityType.EC2 ?\n        this.addNodegroupCapacity('DefaultCapacity', { instanceTypes: [instanceType], minSize: minCapacity }) : undefined;\n    }\n\n    const outputConfigCommand = props.outputConfigCommand ?? true;\n    if (outputConfigCommand) {\n      const postfix = commonCommandOptions.join(' ');\n      new CfnOutput(this, 'ConfigCommand', { value: `${updateConfigCommandPrefix} ${postfix}` });\n      new CfnOutput(this, 'GetTokenCommand', { value: `${getTokenCommandPrefix} ${postfix}` });\n    }\n\n    this.defineCoreDnsComputeType(props.coreDnsComputeType ?? CoreDnsComputeType.EC2);\n\n  }\n\n                                                                                                                                                                                             \n  public getServiceLoadBalancerAddress(serviceName: string, options: ServiceLoadBalancerAddressOptions = {}): string {\n\n    const loadBalancerAddress = new KubernetesObjectValue(this, `${serviceName}LoadBalancerAddress`, {\n      cluster: this,\n      objectType: 'service',\n      objectName: serviceName,\n      objectNamespace: options.namespace,\n      jsonPath: '.status.loadBalancer.ingress[0].hostname',\n      timeout: options.timeout,\n    });\n\n    return loadBalancerAddress.value;\n\n  }\n\n                                                                                                                                                                                                 \n  public getIngressLoadBalancerAddress(ingressName: string, options: IngressLoadBalancerAddressOptions = {}): string {\n\n    const loadBalancerAddress = new KubernetesObjectValue(this, `${ingressName}LoadBalancerAddress`, {\n      cluster: this,\n      objectType: 'ingress',\n      objectName: ingressName,\n      objectNamespace: options.namespace,\n      jsonPath: '.status.loadBalancer.ingress[0].hostname',\n      timeout: options.timeout,\n    });\n\n    return loadBalancerAddress.value;\n\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  public addAutoScalingGroupCapacity(id: string, options: AutoScalingGroupCapacityOptions): autoscaling.AutoScalingGroup {\n    if (options.machineImageType === MachineImageType.BOTTLEROCKET && options.bootstrapOptions !== undefined) {\n      throw new Error('bootstrapOptions is not supported for Bottlerocket');\n    }\n    const asg = new autoscaling.AutoScalingGroup(this, id, {\n      ...options,\n      vpc: this.vpc,\n      machineImage: options.machineImageType === MachineImageType.BOTTLEROCKET ?\n        new BottleRocketImage({\n          kubernetesVersion: this.version.version,\n        }) :\n        new EksOptimizedImage({\n          nodeType: nodeTypeForInstanceType(options.instanceType),\n          cpuArch: cpuArchForInstanceType(options.instanceType),\n          kubernetesVersion: this.version.version,\n        }),\n    });\n\n    this.connectAutoScalingGroupCapacity(asg, {\n      mapRole: options.mapRole,\n      bootstrapOptions: options.bootstrapOptions,\n      bootstrapEnabled: options.bootstrapEnabled,\n      machineImageType: options.machineImageType,\n      spotInterruptHandler: options.spotInterruptHandler,\n    });\n\n    if (nodeTypeForInstanceType(options.instanceType) === NodeType.INFERENTIA) {\n      this.addNeuronDevicePlugin();\n    }\n\n    return asg;\n  }\n\n                                                                                                                                                                                                                                                                                                                                               \n  public addNodegroupCapacity(id: string, options?: NodegroupOptions): Nodegroup {\n    return new Nodegroup(this, `Nodegroup${id}`, {\n      cluster: this,\n      ...options,\n    });\n  }\n\n                                                                                               \n  public get awsAuth() {\n    if (!this._awsAuth) {\n      this._awsAuth = new AwsAuth(this, 'AwsAuth', { cluster: this });\n    }\n\n    return this._awsAuth;\n  }\n\n                                                                                                                                                                                                                                                                                                                        \n  public get clusterOpenIdConnectIssuerUrl(): string {\n    return this._clusterResource.attrOpenIdConnectIssuerUrl;\n  }\n\n                                                                                                                                                                                                                                                                                                                    \n  public get clusterOpenIdConnectIssuer(): string {\n    return this._clusterResource.attrOpenIdConnectIssuer;\n  }\n\n                                                                                                                                                                                                                                            \n  public get openIdConnectProvider() {\n    if (!this._openIdConnectProvider) {\n      this._openIdConnectProvider = new OpenIdConnectProvider(this, 'OpenIdConnectProvider', {\n        url: this.clusterOpenIdConnectIssuerUrl,\n      });\n    }\n\n    return this._openIdConnectProvider;\n  }\n\n                                                                                                                                                                                                                       \n  public addFargateProfile(id: string, options: FargateProfileOptions) {\n    return new FargateProfile(this, `fargate-profile-${id}`, {\n      ...options,\n      cluster: this,\n    });\n  }\n\n  /**\n   * Internal API used by `FargateProfile` to keep inventory of Fargate profiles associated with\n   * this cluster, for the sake of ensuring the profiles are created sequentially.\n   *\n   * @returns the list of FargateProfiles attached to this cluster, including the one just attached.\n   * @internal\n   */\n  public _attachFargateProfile(fargateProfile: FargateProfile): FargateProfile[] {\n    this._fargateProfiles.push(fargateProfile);\n\n    // add all profiles as a dependency of the \"kubectl-ready\" barrier because all kubectl-\n    // resources can only be deployed after all fargate profiles are created.\n    this._kubectlReadyBarrier.node.addDependency(fargateProfile);\n\n    return this._fargateProfiles;\n  }\n\n  /**\n   * Adds a resource scope that requires `kubectl` to this cluster and returns\n   * the `KubectlProvider` which is the custom resource provider that should be\n   * used as the resource provider.\n   *\n   * Called from `HelmResource` and `KubernetesResource`\n   *\n   * @param resourceScope the construct scope in which kubectl resources are defined.\n   *\n   * @internal\n   */\n  public _attachKubectlResourceScope(resourceScope: Construct): KubectlProvider {\n    Node.of(resourceScope).addDependency(this._kubectlReadyBarrier);\n    return this._kubectlResourceProvider;\n  }\n\n  private defineKubectlProvider() {\n    const uid = '@aws-cdk/aws-eks.KubectlProvider';\n\n    // since we can't have the provider connect to multiple networks, and we\n    // wanted to avoid resource tear down, we decided for now that we will only\n    // support a single EKS cluster per CFN stack.\n    if (this.stack.node.tryFindChild(uid)) {\n      throw new Error('Only a single EKS cluster can be defined within a CloudFormation stack');\n    }\n\n    return new KubectlProvider(this.stack, uid, { cluster: this });\n  }\n\n  private selectPrivateSubnets(): ec2.ISubnet[] {\n    const privateSubnets: ec2.ISubnet[] = [];\n    const vpcPrivateSubnetIds = this.vpc.privateSubnets.map(s => s.subnetId);\n    const vpcPublicSubnetIds = this.vpc.publicSubnets.map(s => s.subnetId);\n\n    for (const placement of this.vpcSubnets) {\n\n      for (const subnet of this.vpc.selectSubnets(placement).subnets) {\n\n        if (vpcPrivateSubnetIds.includes(subnet.subnetId)) {\n          // definitely private, take it.\n          privateSubnets.push(subnet);\n          continue;\n        }\n\n        if (vpcPublicSubnetIds.includes(subnet.subnetId)) {\n          // definitely public, skip it.\n          continue;\n        }\n\n        // neither public and nor private - what is it then? this means its a subnet instance that was explicitly passed\n        // in the subnet selection. since ISubnet doesn't contain information on type, we have to assume its private and let it\n        // fail at deploy time :\\ (its better than filtering it out and preventing a possibly successful deployment)\n        privateSubnets.push(subnet);\n      }\n\n    }\n\n    return privateSubnets;\n  }\n\n  /**\n   * Installs the Neuron device plugin on the cluster if it's not\n   * already added.\n   */\n  private addNeuronDevicePlugin() {\n    if (!this._neuronDevicePlugin) {\n      const fileContents = fs.readFileSync(path.join(__dirname, 'addons/neuron-device-plugin.yaml'), 'utf8');\n      const sanitized = YAML.parse(fileContents);\n      this._neuronDevicePlugin = this.addManifest('NeuronDevicePlugin', sanitized);\n    }\n\n    return this._neuronDevicePlugin;\n  }\n\n  /**\n   * Opportunistically tag subnets with the required tags.\n   *\n   * If no subnets could be found (because this is an imported VPC), add a warning.\n   *\n   * @see https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html\n   */\n  private tagSubnets() {\n    const tagAllSubnets = (type: string, subnets: ec2.ISubnet[], tag: string) => {\n      for (const subnet of subnets) {\n        // if this is not a concrete subnet, attach a construct warning\n        if (!ec2.Subnet.isVpcSubnet(subnet)) {\n          // message (if token): \"could not auto-tag public/private subnet with tag...\"\n          // message (if not token): \"count not auto-tag public/private subnet xxxxx with tag...\"\n          const subnetID = Token.isUnresolved(subnet.subnetId) || Token.isUnresolved([subnet.subnetId]) ? '' : ` ${subnet.subnetId}`;\n          Annotations.of(this).addWarning(`Could not auto-tag ${type} subnet${subnetID} with \"${tag}=1\", please remember to do this manually`);\n          continue;\n        }\n\n        Tags.of(subnet).add(tag, '1');\n      }\n    };\n\n    // https://docs.aws.amazon.com/eks/latest/userguide/network_reqs.html\n    tagAllSubnets('private', this.vpc.privateSubnets, 'kubernetes.io/role/internal-elb');\n    tagAllSubnets('public', this.vpc.publicSubnets, 'kubernetes.io/role/elb');\n  }\n\n  /**\n   * Patches the CoreDNS deployment configuration and sets the \"eks.amazonaws.com/compute-type\"\n   * annotation to either \"ec2\" or \"fargate\". Note that if \"ec2\" is selected, the resource is\n   * omitted/removed, since the cluster is created with the \"ec2\" compute type by default.\n   */\n  private defineCoreDnsComputeType(type: CoreDnsComputeType) {\n    // ec2 is the \"built in\" compute type of the cluster so if this is the\n    // requested type we can simply omit the resource. since the resource's\n    // `restorePatch` is configured to restore the value to \"ec2\" this means\n    // that deletion of the resource will change to \"ec2\" as well.\n    if (type === CoreDnsComputeType.EC2) {\n      return;\n    }\n\n    // this is the json patch we merge into the resource based off of:\n    // https://docs.aws.amazon.com/eks/latest/userguide/fargate-getting-started.html#fargate-gs-coredns\n    const renderPatch = (computeType: CoreDnsComputeType) => ({\n      spec: {\n        template: {\n          metadata: {\n            annotations: {\n              'eks.amazonaws.com/compute-type': computeType,\n            },\n          },\n        },\n      },\n    });\n\n    new KubernetesPatch(this, 'CoreDnsComputeTypePatch', {\n      cluster: this,\n      resourceName: 'deployment/coredns',\n      resourceNamespace: 'kube-system',\n      applyPatch: renderPatch(CoreDnsComputeType.FARGATE),\n      restorePatch: renderPatch(CoreDnsComputeType.EC2),\n    });\n  }\n}\n\n                                          \nexport interface AutoScalingGroupCapacityOptions extends autoscaling.CommonAutoScalingGroupProps {\n                                                        \n  readonly instanceType: ec2.InstanceType;\n\n                                                                                                                                                                                                                                                                                        \n  readonly mapRole?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                       \n  readonly bootstrapEnabled?: boolean;\n\n                                                                          \n  readonly bootstrapOptions?: BootstrapOptions;\n\n                                                                                      \n  readonly machineImageType?: MachineImageType;\n\n                                                                                                                                                                              \n  readonly spotInterruptHandler?: boolean;\n}\n\n                                          \nexport interface BootstrapOptions {\n                                                                                                                     \n  readonly useMaxPods?: boolean;\n\n                                                                                     \n  readonly enableDockerBridge?: boolean;\n\n                                                                                                  \n  readonly awsApiRetryAttempts?: number;\n\n                                                                                                                                                                                     \n  readonly dockerConfigJson?: string;\n\n                                                                                                                                                                                                 \n  readonly dnsClusterIp?: string;\n\n                                                                                                                                                                             \n  readonly kubeletExtraArgs?: string;\n\n                                                                                                                                                                                                                    \n  readonly additionalArgs?: string;\n}\n\n                                                             \nexport interface AutoScalingGroupOptions {\n                                                                                                                                                                                                                                                                                        \n  readonly mapRole?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                       \n  readonly bootstrapEnabled?: boolean;\n\n                                                                                                             \n  readonly bootstrapOptions?: BootstrapOptions;\n\n                                                                                                                         \n  readonly machineImageType?: MachineImageType;\n\n                                                                                                                                                                                                              \n  readonly spotInterruptHandler?: boolean;\n}\n\n/**\n * Import a cluster to use in another stack\n */\nclass ImportedCluster extends ClusterBase {\n  public readonly clusterName: string;\n  public readonly clusterArn: string;\n  public readonly connections = new ec2.Connections();\n  public readonly kubectlRole?: iam.IRole;\n  public readonly kubectlLambdaRole?: iam.IRole;\n  public readonly kubectlEnvironment?: { [key: string]: string; } | undefined;\n  public readonly kubectlSecurityGroup?: ec2.ISecurityGroup | undefined;\n  public readonly kubectlPrivateSubnets?: ec2.ISubnet[] | undefined;\n  public readonly kubectlLayer?: lambda.ILayerVersion;\n  public readonly kubectlProvider?: IKubectlProvider;\n  public readonly onEventLayer?: lambda.ILayerVersion;\n  public readonly kubectlMemory?: Size;\n  public readonly clusterHandlerSecurityGroup?: ec2.ISecurityGroup | undefined;\n  public readonly prune: boolean;\n\n  // so that `clusterSecurityGroup` on `ICluster` can be configured without optionality, avoiding users from having\n  // to null check on an instance of `Cluster`, which will always have this configured.\n  private readonly _clusterSecurityGroup?: ec2.ISecurityGroup;\n\n  constructor(scope: Construct, id: string, private readonly props: ClusterAttributes) {\n    super(scope, id);\n\n    this.clusterName = props.clusterName;\n    this.clusterArn = this.stack.formatArn(clusterArnComponents(props.clusterName));\n    this.kubectlRole = props.kubectlRoleArn ? iam.Role.fromRoleArn(this, 'KubectlRole', props.kubectlRoleArn) : undefined;\n    this.kubectlSecurityGroup = props.kubectlSecurityGroupId ? ec2.SecurityGroup.fromSecurityGroupId(this, 'KubectlSecurityGroup', props.kubectlSecurityGroupId) : undefined;\n    this.kubectlEnvironment = props.kubectlEnvironment;\n    this.kubectlPrivateSubnets = props.kubectlPrivateSubnetIds ? props.kubectlPrivateSubnetIds.map((subnetid, index) => ec2.Subnet.fromSubnetId(this, `KubectlSubnet${index}`, subnetid)) : undefined;\n    this.kubectlLayer = props.kubectlLayer;\n    this.kubectlMemory = props.kubectlMemory;\n    this.clusterHandlerSecurityGroup = props.clusterHandlerSecurityGroupId ? ec2.SecurityGroup.fromSecurityGroupId(this, 'ClusterHandlerSecurityGroup', props.clusterHandlerSecurityGroupId) : undefined;\n    this.kubectlProvider = props.kubectlProvider;\n    this.onEventLayer = props.onEventLayer;\n    this.prune = props.prune ?? true;\n\n    let i = 1;\n    for (const sgid of props.securityGroupIds ?? []) {\n      this.connections.addSecurityGroup(ec2.SecurityGroup.fromSecurityGroupId(this, `SecurityGroup${i}`, sgid));\n      i++;\n    }\n\n    if (props.clusterSecurityGroupId) {\n      this._clusterSecurityGroup = ec2.SecurityGroup.fromSecurityGroupId(this, 'ClusterSecurityGroup', this.clusterSecurityGroupId);\n      this.connections.addSecurityGroup(this._clusterSecurityGroup);\n    }\n  }\n\n  public get vpc() {\n    if (!this.props.vpc) {\n      throw new Error('\"vpc\" is not defined for this imported cluster');\n    }\n    return this.props.vpc;\n  }\n\n  public get clusterSecurityGroup(): ec2.ISecurityGroup {\n    if (!this._clusterSecurityGroup) {\n      throw new Error('\"clusterSecurityGroup\" is not defined for this imported cluster');\n    }\n    return this._clusterSecurityGroup;\n  }\n\n  public get clusterSecurityGroupId(): string {\n    if (!this.props.clusterSecurityGroupId) {\n      throw new Error('\"clusterSecurityGroupId\" is not defined for this imported cluster');\n    }\n    return this.props.clusterSecurityGroupId;\n  }\n\n  public get clusterEndpoint(): string {\n    if (!this.props.clusterEndpoint) {\n      throw new Error('\"clusterEndpoint\" is not defined for this imported cluster');\n    }\n    return this.props.clusterEndpoint;\n  }\n\n  public get clusterCertificateAuthorityData(): string {\n    if (!this.props.clusterCertificateAuthorityData) {\n      throw new Error('\"clusterCertificateAuthorityData\" is not defined for this imported cluster');\n    }\n    return this.props.clusterCertificateAuthorityData;\n  }\n\n  public get clusterEncryptionConfigKeyArn(): string {\n    if (!this.props.clusterEncryptionConfigKeyArn) {\n      throw new Error('\"clusterEncryptionConfigKeyArn\" is not defined for this imported cluster');\n    }\n    return this.props.clusterEncryptionConfigKeyArn;\n  }\n\n  public get openIdConnectProvider(): iam.IOpenIdConnectProvider {\n    if (!this.props.openIdConnectProvider) {\n      throw new Error('\"openIdConnectProvider\" is not defined for this imported cluster');\n    }\n    return this.props.openIdConnectProvider;\n  }\n\n  public get awsAuth(): AwsAuth {\n    throw new Error('\"awsAuth\" is not supported on imported clusters');\n  }\n}\n\n                                           \nexport interface EksOptimizedImageProps {\n                                                                                                                              \n  readonly nodeType?: NodeType;\n\n                                                                                                                    \n  readonly cpuArch?: CpuArch;\n\n                                                                                      \n  readonly kubernetesVersion?: string;\n}\n\n                                                                                               \nexport class EksOptimizedImage implements ec2.IMachineImage {\n  private readonly nodeType?: NodeType;\n  private readonly cpuArch?: CpuArch;\n  private readonly kubernetesVersion?: string;\n  private readonly amiParameterName: string;\n\n                                                                        \n  public constructor(props: EksOptimizedImageProps = {}) {\n    this.nodeType = props.nodeType ?? NodeType.STANDARD;\n    this.cpuArch = props.cpuArch ?? CpuArch.X86_64;\n    this.kubernetesVersion = props.kubernetesVersion ?? LATEST_KUBERNETES_VERSION;\n\n    // set the SSM parameter name\n    this.amiParameterName = `/aws/service/eks/optimized-ami/${this.kubernetesVersion}/`\n      + (this.nodeType === NodeType.STANDARD ? this.cpuArch === CpuArch.X86_64 ?\n        'amazon-linux-2/' : 'amazon-linux-2-arm64/' : '')\n      + (this.nodeType === NodeType.GPU ? 'amazon-linux-2-gpu/' : '')\n      + (this.nodeType === NodeType.INFERENTIA ? 'amazon-linux-2-gpu/' : '')\n      + 'recommended/image_id';\n  }\n\n                                         \n  public getImage(scope: Construct): ec2.MachineImageConfig {\n    const ami = ssm.StringParameter.valueForStringParameter(scope, this.amiParameterName);\n    return {\n      imageId: ami,\n      osType: ec2.OperatingSystemType.LINUX,\n      userData: ec2.UserData.forLinux(),\n    };\n  }\n}\n\n// MAINTAINERS: use ./scripts/kube_bump.sh to update LATEST_KUBERNETES_VERSION\nconst LATEST_KUBERNETES_VERSION = '1.14';\n\n                                                                                 \nexport enum NodeType {\n                                   \n  STANDARD = 'Standard',\n\n                              \n  GPU = 'GPU',\n\n                                     \n  INFERENTIA = 'INFERENTIA',\n}\n\n                           \nexport enum CpuArch {\n                               \n  ARM_64 = 'arm64',\n\n                                \n  X86_64 = 'x86_64',\n}\n\n                                                            \nexport enum CoreDnsComputeType {\n                                                 \n  EC2 = 'ec2',\n\n                                                             \n  FARGATE = 'fargate'\n}\n\n                                                    \nexport enum DefaultCapacityType {\n                                   \n  NODEGROUP,\n                                      \n  EC2\n}\n\n                                 \nexport enum MachineImageType {\n                                               \n  AMAZON_LINUX_2,\n                                 \n  BOTTLEROCKET\n}\n\nfunction nodeTypeForInstanceType(instanceType: ec2.InstanceType) {\n  return INSTANCE_TYPES.gpu.includes(instanceType.toString().substring(0, 2)) ? NodeType.GPU :\n    INSTANCE_TYPES.inferentia.includes(instanceType.toString().substring(0, 4)) ? NodeType.INFERENTIA :\n      NodeType.STANDARD;\n}\n\nfunction cpuArchForInstanceType(instanceType: ec2.InstanceType) {\n  return INSTANCE_TYPES.graviton2.includes(instanceType.toString().substring(0, 3)) ? CpuArch.ARM_64 :\n    INSTANCE_TYPES.graviton.includes(instanceType.toString().substring(0, 2)) ? CpuArch.ARM_64 :\n      CpuArch.X86_64;\n}\n\nfunction flatten<A>(xss: A[][]): A[] {\n  return Array.prototype.concat.call([], ...xss);\n}\n"],
  "mappings": "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",
  "names": []
}
