{
  "version": 3,
  "sources": ["application-listener-rule.ts"],
  "sourcesContent": ["import * as cdk from '../../../core';\nimport { Construct } from 'constructs';\nimport { CfnListenerRule } from '../elasticloadbalancingv2.generated';\nimport { IListenerAction } from '../shared/listener-action';\nimport { IApplicationListener } from './application-listener';\nimport { ListenerAction } from './application-listener-action';\nimport { IApplicationTargetGroup } from './application-target-group';\nimport { ListenerCondition } from './conditions';\n\n                                                             \nexport interface BaseApplicationListenerRuleProps {\n                                                                                                                                                      \n  readonly priority: number;\n\n                                                                                                                                                                                                                                           \n  readonly targetGroups?: IApplicationTargetGroup[];\n\n                                                                                                                                                                                                    \n  readonly action?: ListenerAction;\n\n                                                                                                                                                                                                                                 \n  readonly fixedResponse?: FixedResponse;\n\n                                                                                                                                                                                                                                       \n  readonly redirectResponse?: RedirectResponse;\n\n                                                                                                                                                                                                            \n  readonly conditions?: ListenerCondition[];\n\n                                                                                                                                                                                                                                                                                                                                                  \n  readonly hostHeader?: string;\n\n                                                                                                                                                                                                                                                                                                \n  readonly pathPattern?: string;\n\n                                                                                                                                                                                                                                                                                                                                                            \n  readonly pathPatterns?: string[];\n}\n\n                                                  \nexport interface ApplicationListenerRuleProps extends BaseApplicationListenerRuleProps {\n                                                   \n  readonly listener: IApplicationListener;\n}\n\n                                                                                                     \nexport enum ContentType {\n  TEXT_PLAIN = 'text/plain',\n  TEXT_CSS = 'text/css',\n  TEXT_HTML = 'text/html',\n  APPLICATION_JAVASCRIPT = 'application/javascript',\n  APPLICATION_JSON = 'application/json'\n}\n\n                                                                                          \nexport interface FixedResponse {\n                                                         \n  readonly statusCode: string;\n\n                                                               \n  readonly contentType?: ContentType;\n\n                                                          \n  readonly messageBody?: string;\n}\n\n                                                                                        \nexport interface RedirectResponse {\n                                                                                                                                                 \n  readonly host?: string;\n                                                                                                                                                                                                            \n  readonly path?: string;\n                                                                                                                        \n  readonly port?: string;\n                                                                                                                                                                                                                                   \n  readonly protocol?: string;\n                                                                                                                                                                                                                                                                   \n  readonly query?: string;\n                                                              \n  readonly statusCode: string;\n}\n\n                                     \nexport class ApplicationListenerRule extends Construct {\n                                     \n  public readonly listenerRuleArn: string;\n\n  private readonly conditions: ListenerCondition[];\n  private readonly legacyConditions: {[key: string]: string[]} = {};\n\n  private readonly listener: IApplicationListener;\n  private action?: IListenerAction;\n\n  constructor(scope: Construct, id: string, props: ApplicationListenerRuleProps) {\n    super(scope, id);\n\n    this.conditions = props.conditions || [];\n\n    const hasPathPatterns = props.pathPatterns || props.pathPattern;\n    if (this.conditions.length === 0 && !props.hostHeader && !hasPathPatterns) {\n      throw new Error('At least one of \\'conditions\\', \\'hostHeader\\', \\'pathPattern\\' or \\'pathPatterns\\' is required when defining a load balancing rule.');\n    }\n\n    const possibleActions: Array<keyof ApplicationListenerRuleProps> = ['action', 'targetGroups', 'fixedResponse', 'redirectResponse'];\n    const providedActions = possibleActions.filter(action => props[action] !== undefined);\n    if (providedActions.length > 1) {\n      throw new Error(`'${providedActions}' specified together, specify only one`);\n    }\n\n    if (!cdk.Token.isUnresolved(props.priority) && props.priority <= 0) {\n      throw new Error('Priority must have value greater than or equal to 1');\n    }\n\n    this.listener = props.listener;\n\n    const resource = new CfnListenerRule(this, 'Resource', {\n      listenerArn: props.listener.listenerArn,\n      priority: props.priority,\n      conditions: cdk.Lazy.any({ produce: () => this.renderConditions() }),\n      actions: cdk.Lazy.any({ produce: () => this.action ? this.action.renderActions() : [] }),\n    });\n\n    if (props.hostHeader) {\n      this.setCondition('host-header', [props.hostHeader]);\n    }\n\n    if (hasPathPatterns) {\n      if (props.pathPattern && props.pathPatterns) {\n        throw new Error('Both `pathPatterns` and `pathPattern` are specified, specify only one');\n      }\n      const pathPattern = props.pathPattern ? [props.pathPattern] : props.pathPatterns;\n      this.setCondition('path-pattern', pathPattern);\n    }\n\n    if (props.action) {\n      this.configureAction(props.action);\n    }\n\n    (props.targetGroups || []).forEach((group) => {\n      this.configureAction(ListenerAction.forward([group]));\n    });\n\n    if (props.fixedResponse) {\n      this.addFixedResponse(props.fixedResponse);\n    } else if (props.redirectResponse) {\n      this.addRedirectResponse(props.redirectResponse);\n    }\n\n    this.listenerRuleArn = resource.ref;\n\n    this.node.addValidation({ validate: () => this.validateListenerRule() });\n  }\n\n                                                                                                                                                                                                                                 \n  public setCondition(field: string, values: string[] | undefined) {\n    if (values === undefined) {\n      delete this.legacyConditions[field];\n      return;\n    }\n\n    this.legacyConditions[field] = values;\n  }\n\n                                                          \n  public addCondition(condition: ListenerCondition) {\n    this.conditions.push(condition);\n  }\n\n                                                              \n  public configureAction(action: ListenerAction) {\n    // It might make sense to 'throw' here.\n    //\n    // However, programs may already exist out there which configured an action twice,\n    // in which case the second action accidentally overwrite the initial action, and in some\n    // way ended up with a program that did what the author intended. If we were to add throw now,\n    // the previously working program would be broken.\n    //\n    // Instead, signal this through a warning.\n    // @deprecate: upon the next major version bump, replace this with a `throw`\n    if (this.action) {\n      cdk.Annotations.of(this).addWarning('An Action already existed on this ListenerRule and was replaced. Configure exactly one default Action.');\n    }\n\n    action.bind(this, this.listener, this);\n    this.action = action;\n  }\n\n                                                                                                       \n  public addTargetGroup(targetGroup: IApplicationTargetGroup) {\n    this.configureAction(ListenerAction.forward([targetGroup]));\n  }\n\n                                                                                       \n  public addFixedResponse(fixedResponse: FixedResponse) {\n    validateFixedResponse(fixedResponse);\n\n    this.configureAction(ListenerAction.fixedResponse(cdk.Token.asNumber(fixedResponse.statusCode), {\n      contentType: fixedResponse.contentType,\n      messageBody: fixedResponse.messageBody,\n    }));\n  }\n\n                                                                                          \n  public addRedirectResponse(redirectResponse: RedirectResponse) {\n    validateRedirectResponse(redirectResponse);\n\n    this.configureAction(ListenerAction.redirect({\n      host: redirectResponse.host,\n      path: redirectResponse.path,\n      permanent: redirectResponse.statusCode === 'HTTP_301',\n      port: redirectResponse.port,\n      protocol: redirectResponse.protocol,\n      query: redirectResponse.query,\n    }));\n  }\n\n  /**\n   * Validate the rule\n   */\n  private validateListenerRule() {\n    if (this.action === undefined) {\n      return ['Listener rule needs at least one action'];\n    }\n\n    const legacyConditionFields = Object.keys(this.legacyConditions);\n    if (legacyConditionFields.length === 0 && this.conditions.length === 0) {\n      return ['Listener rule needs at least one condition'];\n    }\n\n    return [];\n  }\n\n  /**\n   * Render the conditions for this rule\n   */\n  private renderConditions(): any {\n    const legacyConditions = Object.entries(this.legacyConditions).map(([field, values]) => {\n      return { field, values };\n    });\n    const conditions = this.conditions.map(condition => condition.renderRawCondition());\n\n    return [\n      ...legacyConditions,\n      ...conditions,\n    ];\n  }\n}\n\n/**\n * Validate the status code and message body of a fixed response\n * @internal\n * @deprecated\n */\nfunction validateFixedResponse(fixedResponse: FixedResponse) {\n  if (fixedResponse.statusCode && !/^(2|4|5)\\d\\d$/.test(fixedResponse.statusCode)) {\n    throw new Error('`statusCode` must be 2XX, 4XX or 5XX.');\n  }\n\n  if (fixedResponse.messageBody && fixedResponse.messageBody.length > 1024) {\n    throw new Error('`messageBody` cannot have more than 1024 characters.');\n  }\n}\n\n/**\n * Validate the status code and message body of a redirect response\n * @internal\n * @deprecated\n */\nfunction validateRedirectResponse(redirectResponse: RedirectResponse) {\n  if (redirectResponse.protocol && !/^(HTTPS?|#\\{protocol\\})$/i.test(redirectResponse.protocol)) {\n    throw new Error('`protocol` must be HTTP, HTTPS, or #{protocol}.');\n  }\n\n  if (!redirectResponse.statusCode || !/^HTTP_30[12]$/.test(redirectResponse.statusCode)) {\n    throw new Error('`statusCode` must be HTTP_301 or HTTP_302.');\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
