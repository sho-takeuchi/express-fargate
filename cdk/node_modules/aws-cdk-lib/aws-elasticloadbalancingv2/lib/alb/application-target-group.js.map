{
  "version": 3,
  "sources": ["application-target-group.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../../aws-cloudwatch';\nimport * as ec2 from '../../../aws-ec2';\nimport { Annotations, Duration, Token } from '../../../core';\nimport { IConstruct, Construct } from 'constructs';\nimport { ApplicationELBMetrics } from '../elasticloadbalancingv2-canned-metrics.generated';\nimport {\n  BaseTargetGroupProps, ITargetGroup, loadBalancerNameFromListenerArn, LoadBalancerTargetProps,\n  TargetGroupAttributes, TargetGroupBase, TargetGroupImportProps,\n} from '../shared/base-target-group';\nimport { ApplicationProtocol, ApplicationProtocolVersion, Protocol, TargetType, TargetGroupLoadBalancingAlgorithmType } from '../shared/enums';\nimport { ImportedTargetGroupBase } from '../shared/imported';\nimport { determineProtocolAndPort } from '../shared/util';\nimport { IApplicationListener } from './application-listener';\nimport { HttpCodeTarget } from './application-load-balancer';\n\n                                                              \nexport interface ApplicationTargetGroupProps extends BaseTargetGroupProps {\n                                                                                                                     \n  readonly protocol?: ApplicationProtocol;\n\n                                                                                                \n  readonly protocolVersion?: ApplicationProtocolVersion;\n\n                                                                                                                                                          \n  readonly port?: number;\n\n                                                                                                                                                                                                                                             \n  readonly slowStart?: Duration;\n\n                                                                                                                                                                                                                                                                                                              \n  readonly stickinessCookieDuration?: Duration;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  readonly stickinessCookieName?: string;\n\n                                                                                                                                                          \n  readonly loadBalancingAlgorithmType?: TargetGroupLoadBalancingAlgorithmType;\n\n                                                                                                                                                                                                                                                                                          \n  readonly targets?: IApplicationLoadBalancerTarget[];\n}\n\n                                             \nexport class ApplicationTargetGroup extends TargetGroupBase implements IApplicationTargetGroup {\n                                                \n  public static fromTargetGroupAttributes(scope: Construct, id: string, attrs: TargetGroupAttributes): IApplicationTargetGroup {\n    return new ImportedApplicationTargetGroup(scope, id, attrs);\n  }\n\n                                                                                                              \n  public static import(scope: Construct, id: string, props: TargetGroupImportProps): IApplicationTargetGroup {\n    return ApplicationTargetGroup.fromTargetGroupAttributes(scope, id, props);\n  }\n\n  private readonly connectableMembers: ConnectableMember[];\n  private readonly listeners: IApplicationListener[];\n  private readonly protocol?: ApplicationProtocol;\n  private readonly port?: number;\n\n  constructor(scope: Construct, id: string, props: ApplicationTargetGroupProps = {}) {\n    const [protocol, port] = determineProtocolAndPort(props.protocol, props.port);\n    const { protocolVersion } = props;\n    super(scope, id, { ...props }, {\n      protocol,\n      protocolVersion,\n      port,\n    });\n\n    this.protocol = protocol;\n    this.port = port;\n\n    this.connectableMembers = [];\n    this.listeners = [];\n\n    if (props) {\n      if (props.slowStart !== undefined) {\n        if (props.slowStart.toSeconds() < 30 || props.slowStart.toSeconds() > 900) {\n          throw new Error('Slow start duration value must be between 30 and 900 seconds.');\n        }\n        this.setAttribute('slow_start.duration_seconds', props.slowStart.toSeconds().toString());\n      }\n\n      if (props.stickinessCookieDuration) {\n        this.enableCookieStickiness(props.stickinessCookieDuration, props.stickinessCookieName);\n      } else {\n        this.setAttribute('stickiness.enabled', 'false');\n      }\n\n      if (props.loadBalancingAlgorithmType) {\n        this.setAttribute('load_balancing.algorithm.type', props.loadBalancingAlgorithmType);\n      }\n      this.addTarget(...(props.targets || []));\n    }\n  }\n\n                                                                 \n  public addTarget(...targets: IApplicationLoadBalancerTarget[]) {\n    for (const target of targets) {\n      const result = target.attachToApplicationTargetGroup(this);\n      this.addLoadBalancerTarget(result);\n    }\n\n    if (this.targetType === TargetType.LAMBDA) {\n      this.setAttribute('stickiness.enabled', undefined);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                  \n  public enableCookieStickiness(duration: Duration, cookieName?: string) {\n    if (duration.toSeconds() < 1 || duration.toSeconds() > 604800) {\n      throw new Error('Stickiness cookie duration value must be between 1 second and 7 days (604800 seconds).');\n    }\n    if (cookieName !== undefined) {\n      if (!Token.isUnresolved(cookieName) && (cookieName.startsWith('AWSALB') || cookieName.startsWith('AWSALBAPP') || cookieName.startsWith('AWSALBTG'))) {\n        throw new Error('App cookie names that start with the following prefixes are not allowed: AWSALB, AWSALBAPP, and AWSALBTG; they\\'re reserved for use by the load balancer.');\n      }\n      if (cookieName === '') {\n        throw new Error('App cookie name cannot be an empty string.');\n      }\n    }\n    this.setAttribute('stickiness.enabled', 'true');\n    if (cookieName) {\n      this.setAttribute('stickiness.type', 'app_cookie');\n      this.setAttribute('stickiness.app_cookie.cookie_name', cookieName);\n      this.setAttribute('stickiness.app_cookie.duration_seconds', duration.toSeconds().toString());\n    } else {\n      this.setAttribute('stickiness.type', 'lb_cookie');\n      this.setAttribute('stickiness.lb_cookie.duration_seconds', duration.toSeconds().toString());\n    }\n  }\n\n                                                                                                                                                          \n  public registerConnectable(connectable: ec2.IConnectable, portRange?: ec2.Port) {\n    portRange = portRange || ec2.Port.tcp(this.defaultPort);\n\n    // Notify all listeners that we already know about of this new connectable.\n    // Then remember for new listeners that might get added later.\n    this.connectableMembers.push({ connectable, portRange });\n    for (const listener of this.listeners) {\n      listener.registerConnectable(connectable, portRange);\n    }\n  }\n\n                                                                                                                                                     \n  public registerListener(listener: IApplicationListener, associatingConstruct?: IConstruct) {\n    // Notify this listener of all connectables that we know about.\n    // Then remember for new connectables that might get added later.\n    for (const member of this.connectableMembers) {\n      listener.registerConnectable(member.connectable, member.portRange);\n    }\n    this.listeners.push(listener);\n    this.loadBalancerAttachedDependencies.add(associatingConstruct ?? listener);\n  }\n\n                                                 \n  public get firstLoadBalancerFullName(): string {\n    if (this.listeners.length === 0) {\n      throw new Error('The TargetGroup needs to be attached to a LoadBalancer before you can call this method');\n    }\n    return loadBalancerNameFromListenerArn(this.listeners[0].listenerArn);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                              \n  public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/ApplicationELB',\n      metricName,\n      dimensionsMap: {\n        TargetGroup: this.targetGroupFullName,\n        LoadBalancer: this.firstLoadBalancerFullName,\n      },\n      ...props,\n    }).attachTo(this);\n  }\n\n                                                                                                               \n  public metricIpv6RequestCount(props?: cloudwatch.MetricOptions) {\n    return this.cannedMetric(ApplicationELBMetrics.iPv6RequestCountSum, props);\n  }\n\n                                                                                                                                                                                                                       \n  public metricRequestCount(props?: cloudwatch.MetricOptions) {\n    return this.cannedMetric(ApplicationELBMetrics.requestCountSum, props);\n  }\n\n                                                                                                          \n  public metricHealthyHostCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('HealthyHostCount', {\n      statistic: 'Average',\n      ...props,\n    });\n  }\n\n                                                                                                            \n  public metricUnhealthyHostCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('UnHealthyHostCount', {\n      statistic: 'Average',\n      ...props,\n    });\n  }\n\n                                                                                                                                                                                                                                          \n  public metricHttpCodeTarget(code: HttpCodeTarget, props?: cloudwatch.MetricOptions) {\n    return this.metric(code, {\n      statistic: 'Sum',\n      ...props,\n    });\n  }\n\n                                                                                                                                                                                                                              \n  public metricRequestCountPerTarget(props?: cloudwatch.MetricOptions) {\n    return this.metric('RequestCountPerTarget', {\n      statistic: 'Sum',\n      ...props,\n    });\n  }\n\n                                                                                                                                                             \n  public metricTargetConnectionErrorCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('TargetConnectionErrorCount', {\n      statistic: 'Sum',\n      ...props,\n    });\n  }\n\n                                                                                                                                                                                 \n  public metricTargetResponseTime(props?: cloudwatch.MetricOptions) {\n    return this.metric('TargetResponseTime', {\n      statistic: 'Average',\n      ...props,\n    });\n  }\n\n                                                                                                                                                                                                                                           \n  public metricTargetTLSNegotiationErrorCount(props?: cloudwatch.MetricOptions) {\n    return this.metric('TargetTLSNegotiationErrorCount', {\n      statistic: 'Sum',\n      ...props,\n    });\n  }\n\n  protected validateTargetGroup(): string[] {\n    const ret = super.validateTargetGroup();\n\n    if (this.targetType !== undefined && this.targetType !== TargetType.LAMBDA\n      && (this.protocol === undefined || this.port === undefined)) {\n      ret.push('At least one of \\'port\\' or \\'protocol\\' is required for a non-Lambda TargetGroup');\n    }\n\n    if (this.healthCheck && this.healthCheck.protocol) {\n\n      if (ALB_HEALTH_CHECK_PROTOCOLS.includes(this.healthCheck.protocol)) {\n        if (this.healthCheck.interval && this.healthCheck.timeout &&\n          this.healthCheck.interval.toMilliseconds() <= this.healthCheck.timeout.toMilliseconds()) {\n          ret.push(`Healthcheck interval ${this.healthCheck.interval.toHumanString()} must be greater than the timeout ${this.healthCheck.timeout.toHumanString()}`);\n        }\n      }\n\n      if (!ALB_HEALTH_CHECK_PROTOCOLS.includes(this.healthCheck.protocol)) {\n        ret.push([\n          `Health check protocol '${this.healthCheck.protocol}' is not supported. `,\n          `Must be one of [${ALB_HEALTH_CHECK_PROTOCOLS.join(', ')}]`,\n        ].join(''));\n      }\n    }\n\n    return ret;\n  }\n\n  private cannedMetric(\n    fn: (dims: { LoadBalancer: string, TargetGroup: string }) => cloudwatch.MetricProps,\n    props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      ...fn({\n        LoadBalancer: this.firstLoadBalancerFullName,\n        TargetGroup: this.targetGroupFullName,\n      }),\n      ...props,\n    }).attachTo(this);\n  }\n}\n\n/**\n * A connectable member of a target group\n */\ninterface ConnectableMember {\n  /**\n   * The connectable member\n   */\n  connectable: ec2.IConnectable;\n\n  /**\n   * The port (range) the member is listening on\n   */\n  portRange: ec2.Port;\n}\n\n                                                        \nexport interface IApplicationTargetGroup extends ITargetGroup {\n                                                                                                                                                     \n  registerListener(listener: IApplicationListener, associatingConstruct?: IConstruct): void;\n\n                                                                                                                                                          \n  registerConnectable(connectable: ec2.IConnectable, portRange?: ec2.Port): void;\n\n                                                                 \n  addTarget(...targets: IApplicationLoadBalancerTarget[]): void;\n}\n\n/**\n * An imported application target group\n */\nclass ImportedApplicationTargetGroup extends ImportedTargetGroupBase implements IApplicationTargetGroup {\n  public registerListener(_listener: IApplicationListener, _associatingConstruct?: IConstruct) {\n    // Nothing to do, we know nothing of our members\n    Annotations.of(this).addWarning('Cannot register listener on imported target group -- security groups might need to be updated manually');\n  }\n\n  public registerConnectable(_connectable: ec2.IConnectable, _portRange?: ec2.Port | undefined): void {\n    Annotations.of(this).addWarning('Cannot register connectable on imported target group -- security groups might need to be updated manually');\n  }\n\n  public addTarget(...targets: IApplicationLoadBalancerTarget[]) {\n    for (const target of targets) {\n      const result = target.attachToApplicationTargetGroup(this);\n\n      if (result.targetJson !== undefined) {\n        throw new Error('Cannot add a non-self registering target to an imported TargetGroup. Create a new TargetGroup instead.');\n      }\n    }\n  }\n}\n\n                                                                                       \nexport interface IApplicationLoadBalancerTarget {\n                                                                                                                                                                                                                  \n  attachToApplicationTargetGroup(targetGroup: IApplicationTargetGroup): LoadBalancerTargetProps;\n}\n\nconst ALB_HEALTH_CHECK_PROTOCOLS = [Protocol.HTTP, Protocol.HTTPS];\n"],
  "mappings": "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",
  "names": []
}
