{
  "version": 3,
  "sources": ["policy-statement.ts"],
  "sourcesContent": ["import * as cdk from '../../core';\nimport { Group } from './group';\nimport {\n  AccountPrincipal, AccountRootPrincipal, AnyPrincipal, ArnPrincipal, CanonicalUserPrincipal,\n  FederatedPrincipal, IPrincipal, PrincipalBase, PrincipalPolicyFragment, ServicePrincipal, ServicePrincipalOpts,\n} from './principals';\nimport { LITERAL_STRING_KEY, mergePrincipal } from './util';\n\nconst ensureArrayOrUndefined = (field: any) => {\n  if (field === undefined) {\n    return undefined;\n  }\n  if (typeof (field) !== 'string' && !Array.isArray(field)) {\n    throw new Error('Fields must be either a string or an array of strings');\n  }\n  if (Array.isArray(field) && !!field.find((f: any) => typeof (f) !== 'string')) {\n    throw new Error('Fields must be either a string or an array of strings');\n  }\n  return Array.isArray(field) ? field : [field];\n};\n\n                                                            \nexport class PolicyStatement {\n\n                                                                                                                                                                                                  \n  public static fromJson(obj: any) {\n    const ret = new PolicyStatement({\n      sid: obj.Sid,\n      actions: ensureArrayOrUndefined(obj.Action),\n      resources: ensureArrayOrUndefined(obj.Resource),\n      conditions: obj.Condition,\n      effect: obj.Effect,\n      notActions: ensureArrayOrUndefined(obj.NotAction),\n      notResources: ensureArrayOrUndefined(obj.NotResource),\n      principals: obj.Principal ? [new JsonPrincipal(obj.Principal)] : undefined,\n      notPrincipals: obj.NotPrincipal ? [new JsonPrincipal(obj.NotPrincipal)] : undefined,\n    });\n\n    // validate that the PolicyStatement has the correct shape\n    const errors = ret.validateForAnyPolicy();\n    if (errors.length > 0) {\n      throw new Error('Incorrect Policy Statement: ' + errors.join('\\n'));\n    }\n\n    return ret;\n  }\n\n                                                \n  public sid?: string;\n                                                                       \n  public effect: Effect;\n\n  private readonly action = new Array<any>();\n  private readonly notAction = new Array<any>();\n  private readonly principal: { [key: string]: any[] } = {};\n  private readonly notPrincipal: { [key: string]: any[] } = {};\n  private readonly resource = new Array<any>();\n  private readonly notResource = new Array<any>();\n  private readonly condition: { [key: string]: any } = { };\n  private principalConditionsJson?: string;\n\n  constructor(props: PolicyStatementProps = {}) {\n    // Validate actions\n    for (const action of [...props.actions || [], ...props.notActions || []]) {\n\n      if (!/^(\\*|[a-zA-Z0-9-]+:[a-zA-Z0-9*]+)$/.test(action) && !cdk.Token.isUnresolved(action)) {\n        throw new Error(`Action '${action}' is invalid. An action string consists of a service namespace, a colon, and the name of an action. Action names can include wildcards.`);\n      }\n    }\n\n    this.sid = props.sid;\n    this.effect = props.effect || Effect.ALLOW;\n\n    this.addActions(...props.actions || []);\n    this.addNotActions(...props.notActions || []);\n    this.addPrincipals(...props.principals || []);\n    this.addNotPrincipals(...props.notPrincipals || []);\n    this.addResources(...props.resources || []);\n    this.addNotResources(...props.notResources || []);\n    if (props.conditions !== undefined) {\n      this.addConditions(props.conditions);\n    }\n  }\n\n  //\n  // Actions\n  //\n\n                                                                                                                                                                                                                                                          \n  public addActions(...actions: string[]) {\n    if (actions.length > 0 && this.notAction.length > 0) {\n      throw new Error('Cannot add \\'Actions\\' to policy statement if \\'NotActions\\' have been added');\n    }\n    this.action.push(...actions);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                     \n  public addNotActions(...notActions: string[]) {\n    if (notActions.length > 0 && this.action.length > 0) {\n      throw new Error('Cannot add \\'NotActions\\' to policy statement if \\'Actions\\' have been added');\n    }\n    this.notAction.push(...notActions);\n  }\n\n  //\n  // Principal\n  //\n\n                                                                        \n  public get hasPrincipal() {\n    return Object.keys(this.principal).length > 0 || Object.keys(this.notPrincipal).length > 0;\n  }\n\n                                                                                                                                                                                                                                                           \n  public addPrincipals(...principals: IPrincipal[]) {\n    if (Object.keys(principals).length > 0 && Object.keys(this.notPrincipal).length > 0) {\n      throw new Error('Cannot add \\'Principals\\' to policy statement if \\'NotPrincipals\\' have been added');\n    }\n    for (const principal of principals) {\n      this.validatePolicyPrincipal(principal);\n      const fragment = principal.policyFragment;\n      mergePrincipal(this.principal, fragment.principalJson);\n      this.addPrincipalConditions(fragment.conditions);\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                         \n  public addNotPrincipals(...notPrincipals: IPrincipal[]) {\n    if (Object.keys(notPrincipals).length > 0 && Object.keys(this.principal).length > 0) {\n      throw new Error('Cannot add \\'NotPrincipals\\' to policy statement if \\'Principals\\' have been added');\n    }\n    for (const notPrincipal of notPrincipals) {\n      this.validatePolicyPrincipal(notPrincipal);\n      const fragment = notPrincipal.policyFragment;\n      mergePrincipal(this.notPrincipal, fragment.principalJson);\n      this.addPrincipalConditions(fragment.conditions);\n    }\n  }\n\n  private validatePolicyPrincipal(principal: IPrincipal) {\n    if (principal instanceof Group) {\n      throw new Error('Cannot use an IAM Group as the \\'Principal\\' or \\'NotPrincipal\\' in an IAM Policy');\n    }\n  }\n\n                                                                                                                 \n  public addAwsAccountPrincipal(accountId: string) {\n    this.addPrincipals(new AccountPrincipal(accountId));\n  }\n\n                                                                                                                                                                                                                                                                                  \n  public addArnPrincipal(arn: string) {\n    this.addPrincipals(new ArnPrincipal(arn));\n  }\n\n                                                                                                                                                                                                                                                                                                       \n  public addServicePrincipal(service: string, opts?: ServicePrincipalOpts) {\n    this.addPrincipals(new ServicePrincipal(service, opts));\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                               \n  public addFederatedPrincipal(federated: any, conditions: Conditions) {\n    this.addPrincipals(new FederatedPrincipal(federated, conditions));\n  }\n\n                                                                                 \n  public addAccountRootPrincipal() {\n    this.addPrincipals(new AccountRootPrincipal());\n  }\n\n                                                                                                                                                                \n  public addCanonicalUserPrincipal(canonicalUserId: string) {\n    this.addPrincipals(new CanonicalUserPrincipal(canonicalUserId));\n  }\n\n                                                                                   \n  public addAnyPrincipal() {\n    this.addPrincipals(new AnyPrincipal());\n  }\n\n  //\n  // Resources\n  //\n\n                                                                                                                                                                                                                                                                                                                                                    \n  public addResources(...arns: string[]) {\n    if (arns.length > 0 && this.notResource.length > 0) {\n      throw new Error('Cannot add \\'Resources\\' to policy statement if \\'NotResources\\' have been added');\n    }\n    this.resource.push(...arns);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  public addNotResources(...arns: string[]) {\n    if (arns.length > 0 && this.resource.length > 0) {\n      throw new Error('Cannot add \\'NotResources\\' to policy statement if \\'Resources\\' have been added');\n    }\n    this.notResource.push(...arns);\n  }\n\n                                                           \n  public addAllResources() {\n    this.addResources('*');\n  }\n\n                                                                                           \n  public get hasResource() {\n    return this.resource && this.resource.length > 0;\n  }\n\n  //\n  // Condition\n  //\n\n                                              \n  public addCondition(key: string, value: Condition) {\n    const existingValue = this.condition[key];\n    this.condition[key] = existingValue ? { ...existingValue, ...value } : value;\n  }\n\n                                                      \n  public addConditions(conditions: Conditions) {\n    Object.keys(conditions).map(key => {\n      this.addCondition(key, conditions[key]);\n    });\n  }\n\n                                                               \n  public addAccountCondition(accountId: string) {\n    this.addCondition('StringEquals', { 'sts:ExternalId': accountId });\n  }\n\n                                                                                             \n  public toStatementJson(): any {\n    return noUndef({\n      Action: _norm(this.action, { unique: true }),\n      NotAction: _norm(this.notAction, { unique: true }),\n      Condition: _norm(this.condition),\n      Effect: _norm(this.effect),\n      Principal: _normPrincipal(this.principal),\n      NotPrincipal: _normPrincipal(this.notPrincipal),\n      Resource: _norm(this.resource, { unique: true }),\n      NotResource: _norm(this.notResource, { unique: true }),\n      Sid: _norm(this.sid),\n    });\n\n    function _norm(values: any, { unique }: { unique: boolean } = { unique: false }) {\n\n      if (typeof(values) === 'undefined') {\n        return undefined;\n      }\n\n      if (cdk.Token.isUnresolved(values)) {\n        return values;\n      }\n\n      if (Array.isArray(values)) {\n        if (!values || values.length === 0) {\n          return undefined;\n        }\n\n        if (values.length === 1) {\n          return values[0];\n        }\n\n        return unique ? [...new Set(values)] : values;\n      }\n\n      if (typeof(values) === 'object') {\n        if (Object.keys(values).length === 0) {\n          return undefined;\n        }\n      }\n\n      return values;\n    }\n\n    function _normPrincipal(principal: { [key: string]: any[] }) {\n      const keys = Object.keys(principal);\n      if (keys.length === 0) { return undefined; }\n\n      if (LITERAL_STRING_KEY in principal) {\n        return principal[LITERAL_STRING_KEY][0];\n      }\n\n      const result: any = {};\n      for (const key of keys) {\n        const normVal = _norm(principal[key]);\n        if (normVal) {\n          result[key] = normVal;\n        }\n      }\n      return result;\n    }\n  }\n\n                                                               \n  public toString() {\n    return cdk.Token.asString(this, {\n      displayHint: 'PolicyStatement',\n    });\n  }\n\n                                                                                      \n  public toJSON() {\n    return this.toStatementJson();\n  }\n\n  /**\n   * Add a principal's conditions\n   *\n   * For convenience, principals have been modeled as both a principal\n   * and a set of conditions. This makes it possible to have a single\n   * object represent e.g. an \"SNS Topic\" (SNS service principal + aws:SourcArn\n   * condition) or an Organization member (* + aws:OrgId condition).\n   *\n   * However, when using multiple principals in the same policy statement,\n   * they must all have the same conditions or the OR samentics\n   * implied by a list of principals cannot be guaranteed (user needs to\n   * add multiple statements in that case).\n   */\n  private addPrincipalConditions(conditions: Conditions) {\n    // Stringifying the conditions is an easy way to do deep equality\n    const theseConditions = JSON.stringify(conditions);\n    if (this.principalConditionsJson === undefined) {\n      // First principal, anything goes\n      this.principalConditionsJson = theseConditions;\n    } else {\n      if (this.principalConditionsJson !== theseConditions) {\n        throw new Error(`All principals in a PolicyStatement must have the same Conditions (got '${this.principalConditionsJson}' and '${theseConditions}'). Use multiple statements instead.`);\n      }\n    }\n    this.addConditions(conditions);\n  }\n\n                                                                                             \n  public validateForAnyPolicy(): string[] {\n    const errors = new Array<string>();\n    if (this.action.length === 0 && this.notAction.length === 0) {\n      errors.push('A PolicyStatement must specify at least one \\'action\\' or \\'notAction\\'.');\n    }\n    return errors;\n  }\n\n                                                                                                           \n  public validateForResourcePolicy(): string[] {\n    const errors = this.validateForAnyPolicy();\n    if (Object.keys(this.principal).length === 0 && Object.keys(this.notPrincipal).length === 0) {\n      errors.push('A PolicyStatement used in a resource-based policy must specify at least one IAM principal.');\n    }\n    return errors;\n  }\n\n                                                                                                            \n  public validateForIdentityPolicy(): string[] {\n    const errors = this.validateForAnyPolicy();\n    if (Object.keys(this.principal).length > 0 || Object.keys(this.notPrincipal).length > 0) {\n      errors.push('A PolicyStatement used in an identity-based policy cannot specify any IAM principals.');\n    }\n    if (Object.keys(this.resource).length === 0 && Object.keys(this.notResource).length === 0) {\n      errors.push('A PolicyStatement used in an identity-based policy must specify at least one resource.');\n    }\n    return errors;\n  }\n}\n\n                                                                                                                                                  \nexport enum Effect {\n                                                                                                                    \n  ALLOW = 'Allow',\n\n                                                                                                                                                                                                               \n  DENY = 'Deny',\n}\n\n/**\n * Condition for when an IAM policy is in effect. Maps from the keys in a request's context to\n * a string value or array of string values. See the Conditions interface for more details.\n */\nexport type Condition = any;\n\n// NOTE! We'd ideally like to type this as `Record<string, any>`, because the\n// API expects a map which can take either strings or lists of strings.\n//\n// However, if we were to change this right now, the Java bindings for CDK would\n// emit a type of `Map<String, Object>`, but the most common types people would\n// instantiate would be an `ImmutableMap<String, String>` which would not be\n// assignable to `Map<String, Object>`. The types don't have a built-in notion\n// of co-contravariance, you have to indicate that on the type. So jsii would first\n// need to emit the type as `Map<String, ? extends Object>`.\n//\n// Feature request in https://github.com/aws/jsii/issues/1517\n\n/**\n * Conditions for when an IAM Policy is in effect, specified in the following structure:\n *\n * `{ \"Operator\": { \"keyInRequestContext\": \"value\" } }`\n *\n * The value can be either a single string value or an array of string values.\n *\n * For more information, including which operators are supported, see [the IAM\n * documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_elements_condition.html).\n */\nexport type Conditions = Record<string, Condition>;\n\n                                                    \nexport interface PolicyStatementProps {\n                                                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly sid?: string;\n\n                                                                                        \n  readonly actions?: string[];\n\n                                                                                                \n  readonly notActions?: string[];\n\n                                                                                              \n  readonly principals?: IPrincipal[];\n\n                                                                                                      \n  readonly notPrincipals?: IPrincipal[];\n\n                                                                                        \n  readonly resources?: string[];\n\n                                                                                               \n  readonly notResources?: string[];\n\n                                                                                     \n  readonly conditions?: {[key: string]: any};\n\n                                                                                                       \n  readonly effect?: Effect;\n}\n\nfunction noUndef(x: any): any {\n  const ret: any = {};\n  for (const [key, value] of Object.entries(x)) {\n    if (value !== undefined) {\n      ret[key] = value;\n    }\n  }\n  return ret;\n}\n\nclass JsonPrincipal extends PrincipalBase {\n  public readonly policyFragment: PrincipalPolicyFragment;\n\n  constructor(json: any = { }) {\n    super();\n\n    // special case: if principal is a string, turn it into a \"LiteralString\" principal,\n    // so we render the exact same string back out.\n    if (typeof(json) === 'string') {\n      json = { [LITERAL_STRING_KEY]: [json] };\n    }\n    if (typeof(json) !== 'object') {\n      throw new Error(`JSON IAM principal should be an object, got ${JSON.stringify(json)}`);\n    }\n\n    this.policyFragment = {\n      principalJson: json,\n      conditions: {},\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
