{
  "version": 3,
  "sources": ["policy.ts"],
  "sourcesContent": ["import { IResource, Lazy, Resource } from '../../core';\nimport { Construct } from 'constructs';\nimport { IGroup } from './group';\nimport { CfnPolicy } from './iam.generated';\nimport { PolicyDocument } from './policy-document';\nimport { PolicyStatement } from './policy-statement';\nimport { IRole } from './role';\nimport { IUser } from './user';\nimport { generatePolicyName, undefinedIfEmpty } from './util';\n\n                                                                                                                           \nexport interface IPolicy extends IResource {\n                                                              \n  readonly policyName: string;\n}\n\n                                                                \nexport interface PolicyProps {\n                                                                                                                                                                                                                                                                                                                                                   \n  readonly policyName?: string;\n\n                                                                                                                                                           \n  readonly users?: IUser[];\n\n                                                                                                                                                           \n  readonly roles?: IRole[];\n\n                                                                                                                                                                \n  readonly groups?: IGroup[];\n\n                                                                                                                                                                                             \n  readonly statements?: PolicyStatement[];\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly force?: boolean;\n\n                                                                                                                                                                                                                                                  \n  readonly document?: PolicyDocument;\n}\n\n                                                                                                                                                                                                                                                                                         \nexport class Policy extends Resource implements IPolicy {\n\n                                                              \n  public static fromPolicyName(scope: Construct, id: string, policyName: string): IPolicy {\n    class Import extends Resource implements IPolicy {\n      public readonly policyName = policyName;\n    }\n\n    return new Import(scope, id);\n  }\n\n                                     \n  public readonly document = new PolicyDocument();\n\n  private readonly _policyName: string;\n  private readonly roles = new Array<IRole>();\n  private readonly users = new Array<IUser>();\n  private readonly groups = new Array<IGroup>();\n  private readonly force: boolean;\n  private referenceTaken = false;\n\n  constructor(scope: Construct, id: string, props: PolicyProps = {}) {\n    super(scope, id, {\n      physicalName: props.policyName ||\n        // generatePolicyName will take the last 128 characters of the logical id since\n        // policy names are limited to 128. the last 8 chars are a stack-unique hash, so\n        // that shouod be sufficient to ensure uniqueness within a principal.\n        Lazy.string({ produce: () => generatePolicyName(scope, resource.logicalId) }),\n    });\n\n    const self = this;\n\n    class CfnPolicyConditional extends CfnPolicy {\n      /**\n       * This function returns `true` if the CFN resource should be included in\n       * the cloudformation template unless `force` is `true`, if the policy\n       * document is empty, the resource will not be included.\n       */\n      protected shouldSynthesize() {\n        return self.force || self.referenceTaken || (!self.document.isEmpty && self.isAttached);\n      }\n    }\n\n    if (props.document) {\n      this.document = props.document;\n    }\n\n    const resource = new CfnPolicyConditional(this, 'Resource', {\n      policyDocument: this.document,\n      policyName: this.physicalName,\n      roles: undefinedIfEmpty(() => this.roles.map(r => r.roleName)),\n      users: undefinedIfEmpty(() => this.users.map(u => u.userName)),\n      groups: undefinedIfEmpty(() => this.groups.map(g => g.groupName)),\n    });\n\n    this._policyName = this.physicalName!;\n    this.force = props.force ?? false;\n\n    if (props.users) {\n      props.users.forEach(u => this.attachToUser(u));\n    }\n\n    if (props.groups) {\n      props.groups.forEach(g => this.attachToGroup(g));\n    }\n\n    if (props.roles) {\n      props.roles.forEach(r => this.attachToRole(r));\n    }\n\n    if (props.statements) {\n      props.statements.forEach(p => this.addStatements(p));\n    }\n\n    this.node.addValidation({ validate: () => this.validatePolicy() });\n  }\n\n                                                         \n  public addStatements(...statement: PolicyStatement[]) {\n    this.document.addStatements(...statement);\n  }\n\n                                                \n  public attachToUser(user: IUser) {\n    if (this.users.find(u => u === user)) { return; }\n    this.users.push(user);\n    user.attachInlinePolicy(this);\n  }\n\n                                                \n  public attachToRole(role: IRole) {\n    if (this.roles.find(r => r === role)) { return; }\n    this.roles.push(role);\n    role.attachInlinePolicy(this);\n  }\n\n                                                 \n  public attachToGroup(group: IGroup) {\n    if (this.groups.find(g => g === group)) { return; }\n    this.groups.push(group);\n    group.attachInlinePolicy(this);\n  }\n\n                                                              \n  public get policyName(): string {\n    this.referenceTaken = true;\n    return this._policyName;\n  }\n\n  private validatePolicy(): string[] {\n    const result = new Array<string>();\n\n    // validate that the policy document is not empty\n    if (this.document.isEmpty) {\n      if (this.force) {\n        result.push('Policy created with force=true is empty. You must add statements to the policy');\n      }\n      if (!this.force && this.referenceTaken) {\n        result.push('This Policy has been referenced by a resource, so it must contain at least one statement.');\n      }\n    }\n\n    // validate that the policy is attached to at least one principal (role, user or group).\n    if (!this.isAttached) {\n      if (this.force) {\n        result.push('Policy created with force=true must be attached to at least one principal: user, group or role');\n      }\n      if (!this.force && this.referenceTaken) {\n        result.push('This Policy has been referenced by a resource, so it must be attached to at least one user, group or role.');\n      }\n    }\n\n    result.push(...this.document.validateForIdentityPolicy());\n\n    return result;\n  }\n\n  /**\n   * Whether the policy resource has been attached to any identity\n   */\n  private get isAttached() {\n    return this.groups.length + this.users.length + this.roles.length > 0;\n  }\n}\n"],
  "mappings": "6MAAA,OAAA,QAAA,cAGA,gBAAA,QAAA,mBACA,kBAAA,QAAA,qBAIA,OAAA,QAAA,UAiCA,oBAA4B,QAAA,QAAQ,CAqBlC,YAAY,MAAkB,GAAY,MAAqB,GAAE,QAC/D,MAAM,MAAO,GAAI,CACf,aAAc,MAAM,YAIlB,OAAA,KAAK,OAAO,CAAE,QAAS,IAAM,OAAA,mBAAmB,MAAO,SAAS,eAftD,KAAA,SAAW,GAAI,mBAAA,eAGd,KAAA,MAAQ,GAAI,OACZ,KAAA,MAAQ,GAAI,OACZ,KAAA,OAAS,GAAI,OAEtB,KAAA,eAAiB,kEAWvB,KAAM,MAAO,KAEb,kCAAmC,iBAAA,SAAS,CAMhC,kBAAgB,CACxB,MAAO,MAAK,OAAS,KAAK,gBAAmB,CAAC,KAAK,SAAS,SAAW,KAAK,YAIhF,AAAI,MAAM,UACR,MAAK,SAAW,MAAM,UAGxB,KAAM,UAAW,GAAI,sBAAqB,KAAM,WAAY,CAC1D,eAAgB,KAAK,SACrB,WAAY,KAAK,aACjB,MAAO,OAAA,iBAAiB,IAAM,KAAK,MAAM,IAAI,GAAK,EAAE,WACpD,MAAO,OAAA,iBAAiB,IAAM,KAAK,MAAM,IAAI,GAAK,EAAE,WACpD,OAAQ,OAAA,iBAAiB,IAAM,KAAK,OAAO,IAAI,GAAK,EAAE,cAGxD,KAAK,YAAc,KAAK,aACxB,KAAK,MAAK,IAAG,MAAM,SAAK,MAAA,KAAA,OAAA,GAAI,GAExB,MAAM,OACR,MAAM,MAAM,QAAQ,GAAK,KAAK,aAAa,IAGzC,MAAM,QACR,MAAM,OAAO,QAAQ,GAAK,KAAK,cAAc,IAG3C,MAAM,OACR,MAAM,MAAM,QAAQ,GAAK,KAAK,aAAa,IAGzC,MAAM,YACR,MAAM,WAAW,QAAQ,GAAK,KAAK,cAAc,IAGnD,KAAK,KAAK,cAAc,CAAE,SAAU,IAAM,KAAK,yBAvEnC,gBAAe,MAAkB,GAAY,WAAkB,CAC3E,oBAAqB,QAAA,QAAQ,CAA7B,aAAA,qBACkB,KAAA,WAAa,YAG/B,MAAO,IAAI,QAAO,MAAO,IAsEpB,iBAAiB,UAA4B,wEAClD,KAAK,SAAS,cAAc,GAAG,WAI1B,aAAa,KAAW,CAC7B,wDAAI,MAAK,MAAM,KAAK,GAAK,IAAM,OAC/B,MAAK,MAAM,KAAK,MAChB,KAAK,mBAAmB,OAInB,aAAa,KAAW,CAC7B,wDAAI,MAAK,MAAM,KAAK,GAAK,IAAM,OAC/B,MAAK,MAAM,KAAK,MAChB,KAAK,mBAAmB,OAInB,cAAc,MAAa,CAChC,0DAAI,MAAK,OAAO,KAAK,GAAK,IAAM,QAChC,MAAK,OAAO,KAAK,OACjB,MAAM,mBAAmB,UAIhB,aAAU,CACnB,YAAK,eAAiB,GACf,KAAK,YAGN,gBAAc,CACpB,KAAM,QAAS,GAAI,OAGnB,MAAI,MAAK,SAAS,SACZ,MAAK,OACP,OAAO,KAAK,kFAEV,CAAC,KAAK,OAAS,KAAK,gBACtB,OAAO,KAAK,8FAKX,KAAK,YACJ,MAAK,OACP,OAAO,KAAK,kGAEV,CAAC,KAAK,OAAS,KAAK,gBACtB,OAAO,KAAK,+GAIhB,OAAO,KAAK,GAAG,KAAK,SAAS,6BAEtB,UAMG,aAAU,CACpB,MAAO,MAAK,OAAO,OAAS,KAAK,MAAM,OAAS,KAAK,MAAM,OAAS,GA7IxE,QAAA,OAAA",
  "names": []
}
