{
  "version": 3,
  "sources": ["role.ts"],
  "sourcesContent": ["import { ArnFormat, Duration, Resource, Stack, Token, TokenComparison } from '../../core';\nimport { Construct, Node } from 'constructs';\nimport { Grant } from './grant';\nimport { CfnRole } from './iam.generated';\nimport { IIdentity } from './identity-base';\nimport { IManagedPolicy } from './managed-policy';\nimport { Policy } from './policy';\nimport { PolicyDocument } from './policy-document';\nimport { PolicyStatement } from './policy-statement';\nimport { AddToPrincipalPolicyResult, ArnPrincipal, IPrincipal, PrincipalPolicyFragment } from './principals';\nimport { defaultAddPrincipalToAssumeRole } from './private/assume-role-policy';\nimport { ImmutableRole } from './private/immutable-role';\nimport { MutatingPolicyDocumentAdapter } from './private/policydoc-adapter';\nimport { AttachedPolicies, UniqueStringSet } from './util';\n\n                                              \nexport interface RoleProps {\n                                                                                                                                                                                                                                               \n  readonly assumedBy: IPrincipal;\n\n                                                                                                                                                                                                                                                                                        \n  readonly externalId?: string;\n\n                                                                                                                                                                                                                                                          \n  readonly externalIds?: string[];\n\n                                                                                                                                                                                                                                                \n  readonly managedPolicies?: IManagedPolicy[];\n\n                                                                                                                                                                                                                                                                                                                                                                            \n  readonly inlinePolicies?: { [name: string]: PolicyDocument };\n\n                                                                                                                                                               \n  readonly path?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly permissionsBoundary?: IManagedPolicy;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  readonly roleName?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n  readonly maxSessionDuration?: Duration;\n\n                                                                                                                      \n  readonly description?: string;\n}\n\n                                                                                 \nexport interface FromRoleArnOptions {\n                                                                                                                       \n  readonly mutable?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                 \n  readonly addGrantsToResources?: boolean;\n}\n\n                                                                                                                                                                                        \nexport class Role extends Resource implements IRole {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  public static fromRoleArn(scope: Construct, id: string, roleArn: string, options: FromRoleArnOptions = {}): IRole {\n    const scopeStack = Stack.of(scope);\n    const parsedArn = scopeStack.splitArn(roleArn, ArnFormat.SLASH_RESOURCE_NAME);\n    const resourceName = parsedArn.resourceName!;\n    const roleAccount = parsedArn.account;\n    // service roles have an ARN like 'arn:aws:iam::<account>:role/service-role/<roleName>'\n    // or 'arn:aws:iam::<account>:role/service-role/servicename.amazonaws.com/service-role/<roleName>'\n    // we want to support these as well, so we just use the element after the last slash as role name\n    const roleName = resourceName.split('/').pop()!;\n\n    class Import extends Resource implements IRole {\n      public readonly grantPrincipal: IPrincipal = this;\n      public readonly principalAccount = roleAccount;\n      public readonly assumeRoleAction: string = 'sts:AssumeRole';\n      public readonly policyFragment = new ArnPrincipal(roleArn).policyFragment;\n      public readonly roleArn = roleArn;\n      public readonly roleName = roleName;\n      private readonly attachedPolicies = new AttachedPolicies();\n      private defaultPolicy?: Policy;\n\n      constructor(_scope: Construct, _id: string) {\n        super(_scope, _id, {\n          account: roleAccount,\n        });\n      }\n\n      public addToPolicy(statement: PolicyStatement): boolean {\n        return this.addToPrincipalPolicy(statement).statementAdded;\n      }\n\n      public addToPrincipalPolicy(statement: PolicyStatement): AddToPrincipalPolicyResult {\n        if (!this.defaultPolicy) {\n          this.defaultPolicy = new Policy(this, 'Policy');\n          this.attachInlinePolicy(this.defaultPolicy);\n        }\n        this.defaultPolicy.addStatements(statement);\n        return { statementAdded: true, policyDependable: this.defaultPolicy };\n      }\n\n      public attachInlinePolicy(policy: Policy): void {\n        const thisAndPolicyAccountComparison = Token.compareStrings(this.env.account, policy.env.account);\n        const equalOrAnyUnresolved = thisAndPolicyAccountComparison === TokenComparison.SAME ||\n          thisAndPolicyAccountComparison === TokenComparison.BOTH_UNRESOLVED ||\n          thisAndPolicyAccountComparison === TokenComparison.ONE_UNRESOLVED;\n        if (equalOrAnyUnresolved) {\n          this.attachedPolicies.attach(policy);\n          policy.attachToRole(this);\n        }\n      }\n\n      public addManagedPolicy(_policy: IManagedPolicy): void {\n        // FIXME: Add warning that we're ignoring this\n      }\n\n      /**\n       * Grant permissions to the given principal to pass this role.\n       */\n      public grantPassRole(identity: IPrincipal): Grant {\n        return this.grant(identity, 'iam:PassRole');\n      }\n\n      /**\n       * Grant the actions defined in actions to the identity Principal on this resource.\n       */\n      public grant(grantee: IPrincipal, ...actions: string[]): Grant {\n        return Grant.addToPrincipal({\n          grantee,\n          actions,\n          resourceArns: [this.roleArn],\n          scope: this,\n        });\n      }\n    }\n\n    if (options.addGrantsToResources !== undefined && options.mutable !== false) {\n      throw new Error('\\'addGrantsToResources\\' can only be passed if \\'mutable: false\\'');\n    }\n\n    const importedRole = new Import(scope, id);\n    const roleArnAndScopeStackAccountComparison = Token.compareStrings(importedRole.env.account, scopeStack.account);\n    const equalOrAnyUnresolved = roleArnAndScopeStackAccountComparison === TokenComparison.SAME ||\n      roleArnAndScopeStackAccountComparison === TokenComparison.BOTH_UNRESOLVED ||\n      roleArnAndScopeStackAccountComparison === TokenComparison.ONE_UNRESOLVED;\n    // we only return an immutable Role if both accounts were explicitly provided, and different\n    return options.mutable !== false && equalOrAnyUnresolved\n      ? importedRole\n      : new ImmutableRole(scope, `ImmutableRole${id}`, importedRole, options.addGrantsToResources ?? false);\n  }\n\n  public readonly grantPrincipal: IPrincipal = this;\n  public readonly principalAccount: string | undefined = this.env.account;\n\n  public readonly assumeRoleAction: string = 'sts:AssumeRole';\n\n                                                                           \n  public readonly assumeRolePolicy?: PolicyDocument;\n\n                                              \n  public readonly roleArn: string;\n\n                                                                                                                                         \n  public readonly roleId: string;\n\n                                              \n  public readonly roleName: string;\n\n                                  \n  public readonly policyFragment: PrincipalPolicyFragment;\n\n                                                                       \n  public readonly permissionsBoundary?: IManagedPolicy;\n\n  private defaultPolicy?: Policy;\n  private readonly managedPolicies: IManagedPolicy[] = [];\n  private readonly attachedPolicies = new AttachedPolicies();\n  private readonly inlinePolicies: { [name: string]: PolicyDocument };\n  private immutableRole?: IRole;\n\n  constructor(scope: Construct, id: string, props: RoleProps) {\n    super(scope, id, {\n      physicalName: props.roleName,\n    });\n\n    const externalIds = props.externalIds || [];\n    if (props.externalId) {\n      externalIds.push(props.externalId);\n    }\n\n    this.assumeRolePolicy = createAssumeRolePolicy(props.assumedBy, externalIds);\n    this.managedPolicies.push(...props.managedPolicies || []);\n    this.inlinePolicies = props.inlinePolicies || {};\n    this.permissionsBoundary = props.permissionsBoundary;\n    const maxSessionDuration = props.maxSessionDuration && props.maxSessionDuration.toSeconds();\n    validateMaxSessionDuration(maxSessionDuration);\n    const description = (props.description && props.description?.length > 0) ? props.description : undefined;\n\n    if (description && description.length > 1000) {\n      throw new Error('Role description must be no longer than 1000 characters.');\n    }\n\n    const role = new CfnRole(this, 'Resource', {\n      assumeRolePolicyDocument: this.assumeRolePolicy as any,\n      managedPolicyArns: UniqueStringSet.from(() => this.managedPolicies.map(p => p.managedPolicyArn)),\n      policies: _flatten(this.inlinePolicies),\n      path: props.path,\n      permissionsBoundary: this.permissionsBoundary ? this.permissionsBoundary.managedPolicyArn : undefined,\n      roleName: this.physicalName,\n      maxSessionDuration,\n      description,\n    });\n\n    this.roleId = role.attrRoleId;\n    this.roleArn = this.getResourceArnAttribute(role.attrArn, {\n      region: '', // IAM is global in each partition\n      service: 'iam',\n      resource: 'role',\n      resourceName: this.physicalName,\n    });\n    this.roleName = this.getResourceNameAttribute(role.ref);\n    this.policyFragment = new ArnPrincipal(this.roleArn).policyFragment;\n\n    function _flatten(policies?: { [name: string]: PolicyDocument }) {\n      if (policies == null || Object.keys(policies).length === 0) {\n        return undefined;\n      }\n      const result = new Array<CfnRole.PolicyProperty>();\n      for (const policyName of Object.keys(policies)) {\n        const policyDocument = policies[policyName];\n        result.push({ policyName, policyDocument });\n      }\n      return result;\n    }\n\n    this.node.addValidation({ validate: () => this.validateRole() });\n  }\n\n                                                                                                                                                                                                                                    \n  public addToPrincipalPolicy(statement: PolicyStatement): AddToPrincipalPolicyResult {\n    if (!this.defaultPolicy) {\n      this.defaultPolicy = new Policy(this, 'DefaultPolicy');\n      this.attachInlinePolicy(this.defaultPolicy);\n    }\n    this.defaultPolicy.addStatements(statement);\n    return { statementAdded: true, policyDependable: this.defaultPolicy };\n  }\n\n  public addToPolicy(statement: PolicyStatement): boolean {\n    return this.addToPrincipalPolicy(statement).statementAdded;\n  }\n\n                                                                                                             \n  public addManagedPolicy(policy: IManagedPolicy) {\n    if (this.managedPolicies.find(mp => mp === policy)) { return; }\n    this.managedPolicies.push(policy);\n  }\n\n                                                                                        \n  public attachInlinePolicy(policy: Policy) {\n    this.attachedPolicies.attach(policy);\n    policy.attachToRole(this);\n  }\n\n                                                                                                 \n  public grant(grantee: IPrincipal, ...actions: string[]) {\n    return Grant.addToPrincipal({\n      grantee,\n      actions,\n      resourceArns: [this.roleArn],\n      scope: this,\n    });\n  }\n\n                                                                            \n  public grantPassRole(identity: IPrincipal) {\n    return this.grant(identity, 'iam:PassRole');\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                   \n  public withoutPolicyUpdates(options: WithoutPolicyUpdatesOptions = {}): IRole {\n    if (!this.immutableRole) {\n      this.immutableRole = new ImmutableRole(Node.of(this).scope as Construct, `ImmutableRole${this.node.id}`, this, options.addGrantsToResources ?? false);\n    }\n\n    return this.immutableRole;\n  }\n\n  private validateRole(): string[] {\n    const errors = new Array<string>();\n    errors.push(...this.assumeRolePolicy?.validateForResourcePolicy() ?? []);\n    for (const policy of Object.values(this.inlinePolicies)) {\n      errors.push(...policy.validateForIdentityPolicy());\n    }\n    return errors;\n  }\n}\n\n                        \nexport interface IRole extends IIdentity {\n                                                                   \n  readonly roleArn: string;\n\n                                                                    \n  readonly roleName: string;\n\n                                                                                                 \n  grant(grantee: IPrincipal, ...actions: string[]): Grant;\n\n                                                                            \n  grantPassRole(grantee: IPrincipal): Grant;\n}\n\nfunction createAssumeRolePolicy(principal: IPrincipal, externalIds: string[]) {\n  const actualDoc = new PolicyDocument();\n\n  // If requested, add externalIds to every statement added to this doc\n  const addDoc = externalIds.length === 0\n    ? actualDoc\n    : new MutatingPolicyDocumentAdapter(actualDoc, (statement) => {\n      statement.addCondition('StringEquals', {\n        'sts:ExternalId': externalIds.length === 1 ? externalIds[0] : externalIds,\n      });\n      return statement;\n    });\n\n  defaultAddPrincipalToAssumeRole(principal, addDoc);\n\n  return actualDoc;\n}\n\nfunction validateMaxSessionDuration(duration?: number) {\n  if (duration === undefined) {\n    return;\n  }\n\n  if (duration < 3600 || duration > 43200) {\n    throw new Error(`maxSessionDuration is set to ${duration}, but must be >= 3600sec (1hr) and <= 43200sec (12hrs)`);\n  }\n}\n\n                                                                      \nexport interface WithoutPolicyUpdatesOptions {\n                                                                                                                                                                                                                                                                                                                                                                            \n  readonly addGrantsToResources?: boolean;\n}"],
  "mappings": "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",
  "names": []
}
