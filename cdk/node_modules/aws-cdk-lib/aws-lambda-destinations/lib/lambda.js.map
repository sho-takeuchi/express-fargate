{
  "version": 3,
  "sources": ["lambda.ts"],
  "sourcesContent": ["import * as events from '../../aws-events';\nimport * as targets from '../../aws-events-targets';\nimport * as lambda from '../../aws-lambda';\nimport { EventBridgeDestination } from './event-bridge';\n\n// keep this import separate from other imports to reduce chance for merge conflicts with v2-main\n// eslint-disable-next-line no-duplicate-imports, import/order\nimport { Construct } from 'constructs';\n\n                                           \nexport interface LambdaDestinationOptions {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \n  readonly responseOnly?: boolean;\n}\n\n                                                        \nexport class LambdaDestination implements lambda.IDestination {\n  constructor(private readonly fn: lambda.IFunction, private readonly options: LambdaDestinationOptions = {}) {\n  }\n\n                                                    \n  public bind(scope: Construct, fn: lambda.IFunction, options?: lambda.DestinationOptions): lambda.DestinationConfig {\n    // Normal Lambda destination (full invocation record)\n    if (!this.options.responseOnly) {\n      // deduplicated automatically\n      this.fn.grantInvoke(fn);\n\n      return {\n        destination: this.fn.functionArn,\n      };\n    }\n\n    // Otherwise add rule to extract the response payload and use EventBridge\n    // as destination\n    if (!options) { // `options` added to bind() as optionnal to avoid breaking change\n      throw new Error('Options must be defined when using `responseOnly`.');\n    }\n\n    // Match invocation result of the source function (`fn`) and use it\n    // to trigger the destination function (`this.fn`).\n    new events.Rule(scope, options.type, {\n      eventPattern: {\n        detailType: [`Lambda Function Invocation Result - ${options.type}`],\n        resources: [`${fn.functionArn}:$LATEST`],\n        source: ['lambda'],\n      },\n      targets: [\n        new targets.LambdaFunction(this.fn, {\n          event: events.RuleTargetInput.fromEventPath('$.detail.responsePayload'), // Extract response payload\n        }),\n      ],\n    });\n\n    const destination = new EventBridgeDestination(); // Use default event bus here\n    return destination.bind(scope, fn);\n  }\n}\n"],
  "mappings": "wNAAA,OAAA,QAAA,oBACA,QAAA,QAAA,4BAEA,eAAA,QAAA,kBAaA,uBAA8B,CAC5B,YAA6B,GAAuC,QAAoC,GAAE,CAA7E,KAAA,GAAA,GAAuC,KAAA,QAAA,mKAI7D,KAAK,MAAkB,GAAsB,QAAmC,CAErF,2IAAI,CAAC,KAAK,QAAQ,aAEhB,YAAK,GAAG,YAAY,IAEb,CACL,YAAa,KAAK,GAAG,aAMzB,GAAI,CAAC,QACH,KAAM,IAAI,OAAM,sDAKlB,UAAI,QAAO,KAAK,MAAO,QAAQ,KAAM,CACnC,aAAc,CACZ,WAAY,CAAC,uCAAuC,QAAQ,QAC5D,UAAW,CAAC,GAAG,GAAG,uBAClB,OAAQ,CAAC,WAEX,QAAS,CACP,GAAI,SAAQ,eAAe,KAAK,GAAI,CAClC,MAAO,OAAO,gBAAgB,cAAc,iCAM3C,AADa,GAAI,gBAAA,yBACL,KAAK,MAAO,KAtCnC,QAAA,kBAAA",
  "names": []
}
