{
  "version": 3,
  "sources": ["function-base.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport { ArnFormat, IResource, Resource, Token } from '../../core';\nimport { Node } from 'constructs';\nimport { AliasOptions } from './alias';\nimport { Architecture } from './architecture';\nimport { EventInvokeConfig, EventInvokeConfigOptions } from './event-invoke-config';\nimport { IEventSource } from './event-source';\nimport { EventSourceMapping, EventSourceMappingOptions } from './event-source-mapping';\nimport { IVersion } from './lambda-version';\nimport { CfnPermission } from './lambda.generated';\nimport { Permission } from './permission';\nimport { addAlias, flatMap } from './util';\n\nexport interface IFunction extends IResource, ec2.IConnectable, iam.IGrantable {\n\n                                                               \n  readonly functionName: string;\n\n                                                              \n  readonly functionArn: string;\n\n                                                            \n  readonly role?: iam.IRole;\n\n                                                                                                                                                             \n  readonly isBoundToVpc: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                   \n  readonly latestVersion: IVersion;\n\n                                                                   \n  readonly permissionsNode: Node;\n\n                                                                               \n  readonly architecture: Architecture;\n\n                                                                                                                                            \n  addEventSourceMapping(id: string, options: EventSourceMappingOptions): EventSourceMapping;\n\n                                                                                                                                                                                                                         \n  addPermission(id: string, permission: Permission): void;\n\n                                                                          \n  addToRolePolicy(statement: iam.PolicyStatement): void;\n\n                                                                           \n  grantInvoke(identity: iam.IGrantable): iam.Grant;\n\n                                                              \n  metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                 \n  metricDuration(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                          \n  metricInvocations(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                    \n  metricThrottles(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                                                                                                                                                                                                                                              \n  addEventSource(source: IEventSource): void;\n\n                                                                \n  configureAsyncInvoke(options: EventInvokeConfigOptions): void;\n}\n\n                                                                      \nexport interface FunctionAttributes {\n                                                                                                                                        \n  readonly functionArn: string;\n\n                                                                                                                                                      \n  readonly role?: iam.IRole;\n\n                                                                                                                                                                                                                       \n  readonly securityGroupId?: string;\n\n                                                                                                                                                               \n  readonly securityGroup?: ec2.ISecurityGroup;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  readonly sameEnvironment?: boolean;\n\n                                                                                                                                                     \n  readonly architecture?: Architecture;\n}\n\nexport abstract class FunctionBase extends Resource implements IFunction, ec2.IClientVpnConnectionHandler {\n                                                                 \n  public abstract readonly grantPrincipal: iam.IPrincipal;\n\n                                          \n  public abstract readonly functionName: string;\n\n                                         \n  public abstract readonly functionArn: string;\n\n                                                                                                                             \n  public abstract readonly role?: iam.IRole;\n\n                                                                   \n  public abstract readonly permissionsNode: Node;\n\n                                                          \n  public abstract readonly architecture: Architecture;\n\n                                                                                                                                                                                   \n  protected abstract readonly canCreatePermissions: boolean;\n\n  /**\n   * Actual connections object for this Lambda\n   *\n   * May be unset, in which case this Lambda is not configured use in a VPC.\n   * @internal\n   */\n  protected _connections?: ec2.Connections;\n\n  private _latestVersion?: LatestVersion;\n\n  /**\n   * Mapping of invocation principals to grants. Used to de-dupe `grantInvoke()` calls.\n   * @internal\n   */\n  protected _invocationGrants: Record<string, iam.Grant> = {};\n\n                                                                                                                                                                                                                         \n  public addPermission(id: string, permission: Permission) {\n    if (!this.canCreatePermissions) {\n      // FIXME: @deprecated(v2) - throw an error if calling `addPermission` on a resource that doesn't support it.\n      return;\n    }\n\n    const principal = this.parsePermissionPrincipal(permission.principal);\n    const { sourceAccount, sourceArn } = this.parseConditions(permission.principal) ?? {};\n    const action = permission.action ?? 'lambda:InvokeFunction';\n    const scope = permission.scope ?? this;\n\n    new CfnPermission(scope, id, {\n      action,\n      principal,\n      functionName: this.functionArn,\n      eventSourceToken: permission.eventSourceToken,\n      sourceAccount: permission.sourceAccount ?? sourceAccount,\n      sourceArn: permission.sourceArn ?? sourceArn,\n    });\n  }\n\n                                                                          \n  public addToRolePolicy(statement: iam.PolicyStatement) {\n    if (!this.role) {\n      return;\n    }\n\n    this.role.addToPrincipalPolicy(statement);\n  }\n\n                                                                                                       \n  public get connections(): ec2.Connections {\n    if (!this._connections) {\n      // eslint-disable-next-line max-len\n      throw new Error('Only VPC-associated Lambda Functions have security groups to manage. Supply the \"vpc\" parameter when creating the Lambda, or \"securityGroupId\" when importing it.');\n    }\n    return this._connections;\n  }\n\n  public get latestVersion(): IVersion {\n    if (!this._latestVersion) {\n      this._latestVersion = new LatestVersion(this);\n    }\n    return this._latestVersion;\n  }\n\n                                                                                                                                                             \n  public get isBoundToVpc(): boolean {\n    return !!this._connections;\n  }\n\n  public addEventSourceMapping(id: string, options: EventSourceMappingOptions): EventSourceMapping {\n    return new EventSourceMapping(this, id, {\n      target: this,\n      ...options,\n    });\n  }\n\n                                                                           \n  public grantInvoke(grantee: iam.IGrantable): iam.Grant {\n    const identifier = `Invoke${grantee.grantPrincipal}`; // calls the .toString() of the principal\n\n    // Memoize the result so subsequent grantInvoke() calls are idempotent\n    let grant = this._invocationGrants[identifier];\n    if (!grant) {\n      grant = iam.Grant.addToPrincipalOrResource({\n        grantee,\n        actions: ['lambda:InvokeFunction'],\n        resourceArns: [this.functionArn],\n\n        // Fake resource-like object on which to call addToResourcePolicy(), which actually\n        // calls addPermission()\n        resource: {\n          addToResourcePolicy: (_statement) => {\n            // Couldn't add permissions to the principal, so add them locally.\n            this.addPermission(identifier, {\n              principal: grantee.grantPrincipal!,\n              action: 'lambda:InvokeFunction',\n            });\n\n            const permissionNode = this._functionNode().tryFindChild(identifier);\n            if (!permissionNode) {\n              throw new Error('Cannot modify permission to lambda function. Function is either imported or $LATEST version. '\n                + 'If the function is imported from the same account use `fromFunctionAttributes()` API with the `sameEnvironment` flag.');\n            }\n            return { statementAdded: true, policyDependable: permissionNode };\n          },\n          node: this.node,\n          stack: this.stack,\n          env: this.env,\n          applyRemovalPolicy: this.applyRemovalPolicy,\n        },\n      });\n      this._invocationGrants[identifier] = grant;\n    }\n    return grant;\n  }\n\n  public addEventSource(source: IEventSource) {\n    source.bind(this);\n  }\n\n  public configureAsyncInvoke(options: EventInvokeConfigOptions): void {\n    if (this.node.tryFindChild('EventInvokeConfig') !== undefined) {\n      throw new Error(`An EventInvokeConfig has already been configured for the function at ${this.node.path}`);\n    }\n\n    new EventInvokeConfig(this, 'EventInvokeConfig', {\n      function: this,\n      ...options,\n    });\n  }\n\n  /**\n   * Returns the construct tree node that corresponds to the lambda function.\n   * For use internally for constructs, when the tree is set up in non-standard ways. Ex: SingletonFunction.\n   * @internal\n   */\n  protected _functionNode(): Node {\n    return this.node;\n  }\n\n  /**\n   * Given the function arn, check if the account id matches this account\n   *\n   * Function ARNs look like this:\n   *\n   *   arn:aws:lambda:region:account-id:function:function-name\n   *\n   * ..which means that in order to extract the `account-id` component from the ARN, we can\n   * split the ARN using \":\" and select the component in index 4.\n   *\n   * @returns true if account id of function matches the account specified on the stack, false otherwise.\n   *\n   * @internal\n   */\n  protected _isStackAccount(): boolean {\n    if (Token.isUnresolved(this.stack.account) || Token.isUnresolved(this.functionArn)) {\n      return false;\n    }\n    return this.stack.splitArn(this.functionArn, ArnFormat.SLASH_RESOURCE_NAME).account === this.stack.account;\n  }\n\n  /**\n   * Translate IPrincipal to something we can pass to AWS::Lambda::Permissions\n   *\n   * Do some nasty things because `Permission` supports a subset of what the\n   * full IAM principal language supports, and we may not be able to parse strings\n   * outright because they may be tokens.\n   *\n   * Try to recognize some specific Principal classes first, then try a generic\n   * fallback.\n   */\n  private parsePermissionPrincipal(principal: iam.IPrincipal) {\n    // Try some specific common classes first.\n    // use duck-typing, not instance of\n    // @deprecated: after v2, we can change these to 'instanceof'\n    if ('wrapped' in principal) {\n      // eslint-disable-next-line dot-notation\n      principal = principal['wrapped'];\n    }\n\n    if ('accountId' in principal) {\n      return (principal as iam.AccountPrincipal).accountId;\n    }\n\n    if ('service' in principal) {\n      return (principal as iam.ServicePrincipal).service;\n    }\n\n    if ('arn' in principal) {\n      return (principal as iam.ArnPrincipal).arn;\n    }\n\n    // Try a best-effort approach to support simple principals that are not any of the predefined\n    // classes, but are simple enough that they will fit into the Permission model. Main target\n    // here: imported Roles, Users, Groups.\n    //\n    // The principal cannot have conditions and must have a single { AWS: [arn] } entry.\n    const json = principal.policyFragment.principalJson;\n    if (Object.keys(principal.policyFragment.conditions).length === 0 && json.AWS) {\n      if (typeof json.AWS === 'string') { return json.AWS; }\n      if (Array.isArray(json.AWS) && json.AWS.length === 1 && typeof json.AWS[0] === 'string') {\n        return json.AWS[0];\n      }\n    }\n\n    throw new Error(`Invalid principal type for Lambda permission statement: ${principal.constructor.name}. ` +\n      'Supported: AccountPrincipal, ArnPrincipal, ServicePrincipal');\n  }\n\n  private parseConditions(principal: iam.IPrincipal): { sourceAccount: string, sourceArn: string } | null {\n    if (this.isPrincipalWithConditions(principal)) {\n      const conditions: iam.Conditions = principal.policyFragment.conditions;\n      const conditionPairs = flatMap(\n        Object.entries(conditions),\n        ([operator, conditionObjs]) => Object.keys(conditionObjs as object).map(key => { return { operator, key }; }),\n      );\n      const supportedPrincipalConditions = [{ operator: 'ArnLike', key: 'aws:SourceArn' }, { operator: 'StringEquals', key: 'aws:SourceAccount' }];\n\n      const unsupportedConditions = conditionPairs.filter(\n        (condition) => !supportedPrincipalConditions.some(\n          (supportedCondition) => supportedCondition.operator === condition.operator && supportedCondition.key === condition.key,\n        ),\n      );\n\n      if (unsupportedConditions.length == 0) {\n        return {\n          sourceAccount: conditions.StringEquals['aws:SourceAccount'],\n          sourceArn: conditions.ArnLike['aws:SourceArn'],\n        };\n      } else {\n        throw new Error(`PrincipalWithConditions had unsupported conditions for Lambda permission statement: ${JSON.stringify(unsupportedConditions)}. ` +\n          `Supported operator/condition pairs: ${JSON.stringify(supportedPrincipalConditions)}`);\n      }\n    } else {\n      return null;\n    }\n  }\n\n  private isPrincipalWithConditions(principal: iam.IPrincipal): principal is iam.PrincipalWithConditions {\n    return 'conditions' in principal;\n  }\n}\n\nexport abstract class QualifiedFunctionBase extends FunctionBase {\n  public abstract readonly lambda: IFunction;\n\n  public readonly permissionsNode = this.node;\n\n                                                                                                                                                                                                                                                                                              \n  protected abstract readonly qualifier: string;\n\n  public get latestVersion() {\n    return this.lambda.latestVersion;\n  }\n\n  public configureAsyncInvoke(options: EventInvokeConfigOptions): void {\n    if (this.node.tryFindChild('EventInvokeConfig') !== undefined) {\n      throw new Error(`An EventInvokeConfig has already been configured for the qualified function at ${this.node.path}`);\n    }\n\n    new EventInvokeConfig(this, 'EventInvokeConfig', {\n      function: this.lambda,\n      qualifier: this.qualifier,\n      ...options,\n    });\n  }\n}\n\n/**\n * The $LATEST version of a function, useful when attempting to create aliases.\n */\nclass LatestVersion extends FunctionBase implements IVersion {\n  public readonly lambda: IFunction;\n  public readonly version = '$LATEST';\n  public readonly permissionsNode = this.node;\n\n  protected readonly canCreatePermissions = false;\n\n  constructor(lambda: FunctionBase) {\n    super(lambda, '$LATEST');\n    this.lambda = lambda;\n  }\n\n  public get functionArn() {\n    return `${this.lambda.functionArn}:${this.version}`;\n  }\n\n  public get functionName() {\n    return `${this.lambda.functionName}:${this.version}`;\n  }\n\n  public get architecture() {\n    return this.lambda.architecture;\n  }\n\n  public get grantPrincipal() {\n    return this.lambda.grantPrincipal;\n  }\n\n  public get latestVersion() {\n    return this;\n  }\n\n  public get role() {\n    return this.lambda.role;\n  }\n\n  public addAlias(aliasName: string, options: AliasOptions = {}) {\n    return addAlias(this, this, aliasName, options);\n  }\n\n  public get edgeArn(): never {\n    throw new Error('$LATEST function version cannot be used for Lambda@Edge');\n  }\n}\n"],
  "mappings": "oPAEA,IAAA,QAAA,iBACA,OAAA,QAAA,cAIA,sBAAA,QAAA,yBAEA,uBAAA,QAAA,0BAEA,mBAAA,QAAA,sBAEA,OAAA,QAAA,UA6EA,0BAA2C,QAAA,QAAQ,CAAnD,aAAA,qBAoCY,KAAA,kBAA+C,GAGlD,cAAc,GAAY,WAAsB,oBACrD,yEAAI,CAAC,KAAK,qBAER,OAGF,KAAM,WAAY,KAAK,yBAAyB,WAAW,WACrD,CAAE,cAAe,WAAW,IAAG,KAAK,gBAAgB,WAAW,cAAU,MAAA,KAAA,OAAA,GAAI,GAC7E,OAAM,IAAG,WAAW,UAAM,MAAA,KAAA,OAAA,GAAI,wBAC9B,MAAK,IAAG,WAAW,SAAK,MAAA,KAAA,OAAA,GAAI,KAElC,GAAI,oBAAA,cAAc,MAAO,GAAI,CAC3B,OACA,UACA,aAAc,KAAK,YACnB,iBAAkB,WAAW,iBAC7B,cAAa,IAAE,WAAW,iBAAa,MAAA,KAAA,OAAA,GAAI,cAC3C,UAAS,IAAE,WAAW,aAAS,MAAA,KAAA,OAAA,GAAI,YAKhC,gBAAgB,UAA8B,CACnD,uEAAI,EAAC,KAAK,MAIV,KAAK,KAAK,qBAAqB,cAItB,cAAW,CACpB,GAAI,CAAC,KAAK,aAER,KAAM,IAAI,OAAM,qKAElB,MAAO,MAAK,gBAGH,gBAAa,CACtB,MAAK,MAAK,gBACR,MAAK,eAAiB,GAAI,eAAc,OAEnC,KAAK,kBAIH,eAAY,CACrB,MAAO,CAAC,CAAC,KAAK,aAGT,sBAAsB,GAAY,QAAkC,0FAClE,GAAI,wBAAA,mBAAmB,KAAM,GAAI,CACtC,OAAQ,QACL,UAKA,YAAY,QAAuB,iEACxC,KAAM,YAAa,SAAS,QAAQ,iBAGpC,GAAI,OAAQ,KAAK,kBAAkB,YACnC,MAAK,QACH,OAAQ,IAAI,MAAM,yBAAyB,CACzC,QACA,QAAS,CAAC,yBACV,aAAc,CAAC,KAAK,aAIpB,SAAU,CACR,oBAAqB,AAAC,YAAc,CAElC,KAAK,cAAc,WAAY,CAC7B,UAAW,QAAQ,eACnB,OAAQ,0BAGV,KAAM,gBAAiB,KAAK,gBAAgB,aAAa,YACzD,GAAI,CAAC,eACH,KAAM,IAAI,OAAM,sNAGlB,MAAO,CAAE,eAAgB,GAAM,iBAAkB,iBAEnD,KAAM,KAAK,KACX,MAAO,KAAK,MACZ,IAAK,KAAK,IACV,mBAAoB,KAAK,sBAG7B,KAAK,kBAAkB,YAAc,OAEhC,MAGF,eAAe,OAAoB,qEACxC,OAAO,KAAK,MAGP,qBAAqB,QAAiC,CAC3D,oFAAI,KAAK,KAAK,aAAa,uBAAyB,OAClD,KAAM,IAAI,OAAM,wEAAwE,KAAK,KAAK,QAGpG,GAAI,uBAAA,kBAAkB,KAAM,oBAAqB,CAC/C,SAAU,QACP,UASG,eAAa,CACrB,MAAO,MAAK,KAiBJ,iBAAe,CACvB,MAAI,QAAA,MAAM,aAAa,KAAK,MAAM,UAAY,OAAA,MAAM,aAAa,KAAK,aAC7D,GAEF,KAAK,MAAM,SAAS,KAAK,YAAa,OAAA,UAAU,qBAAqB,UAAY,KAAK,MAAM,QAa7F,yBAAyB,UAAyB,CASxD,GALI,WAAa,YAEf,WAAY,UAAU,SAGpB,aAAe,WACjB,MAAQ,WAAmC,UAG7C,GAAI,WAAa,WACf,MAAQ,WAAmC,QAG7C,GAAI,OAAS,WACX,MAAQ,WAA+B,IAQzC,KAAM,MAAO,UAAU,eAAe,cACtC,GAAI,OAAO,KAAK,UAAU,eAAe,YAAY,SAAW,GAAK,KAAK,IAAK,CAC7E,GAAI,MAAO,MAAK,KAAQ,SAAY,MAAO,MAAK,IAChD,GAAI,MAAM,QAAQ,KAAK,MAAQ,KAAK,IAAI,SAAW,GAAK,MAAO,MAAK,IAAI,IAAO,SAC7E,MAAO,MAAK,IAAI,GAIpB,KAAM,IAAI,OAAM,2DAA2D,UAAU,YAAY,qEAI3F,gBAAgB,UAAyB,CAC/C,GAAI,KAAK,0BAA0B,WAAY,CAC7C,KAAM,YAA6B,UAAU,eAAe,WACtD,eAAiB,OAAA,QACrB,OAAO,QAAQ,YACf,CAAC,CAAC,SAAU,iBAAmB,OAAO,KAAK,eAAyB,IAAI,KAAgB,EAAE,SAAU,QAEhG,6BAA+B,CAAC,CAAE,SAAU,UAAW,IAAK,iBAAmB,CAAE,SAAU,eAAgB,IAAK,sBAEhH,sBAAwB,eAAe,OAC3C,AAAC,WAAc,CAAC,6BAA6B,KAC3C,AAAC,oBAAuB,mBAAmB,WAAa,UAAU,UAAY,mBAAmB,MAAQ,UAAU,MAIvH,GAAI,sBAAsB,QAAU,EAClC,MAAO,CACL,cAAe,WAAW,aAAa,qBACvC,UAAW,WAAW,QAAQ,kBAGhC,KAAM,IAAI,OAAM,uFAAuF,KAAK,UAAU,+DAC7E,KAAK,UAAU,qCAG1D,OAAO,MAIH,0BAA0B,UAAyB,CACzD,MAAO,cAAgB,YApQ3B,QAAA,aAAA,iHAwQA,mCAAoD,aAAY,CAAhE,aAAA,qBAGkB,KAAA,gBAAkB,KAAK,QAK5B,gBAAa,CACtB,MAAO,MAAK,OAAO,cAGd,qBAAqB,QAAiC,CAC3D,oFAAI,KAAK,KAAK,aAAa,uBAAyB,OAClD,KAAM,IAAI,OAAM,kFAAkF,KAAK,KAAK,QAG9G,GAAI,uBAAA,kBAAkB,KAAM,oBAAqB,CAC/C,SAAU,KAAK,OACf,UAAW,KAAK,aACb,WApBT,QAAA,sBAAA,4IA4BA,2BAA4B,aAAY,CAOtC,YAAY,OAAoB,CAC9B,MAAM,OAAQ,WANA,KAAA,QAAU,UACV,KAAA,gBAAkB,KAAK,KAEpB,KAAA,qBAAuB,GAIxC,KAAK,OAAS,UAGL,cAAW,CACpB,MAAO,GAAG,KAAK,OAAO,eAAe,KAAK,aAGjC,eAAY,CACrB,MAAO,GAAG,KAAK,OAAO,gBAAgB,KAAK,aAGlC,eAAY,CACrB,MAAO,MAAK,OAAO,gBAGV,iBAAc,CACvB,MAAO,MAAK,OAAO,kBAGV,gBAAa,CACtB,MAAO,SAGE,OAAI,CACb,MAAO,MAAK,OAAO,KAGd,SAAS,UAAmB,QAAwB,GAAE,CAC3D,MAAO,QAAA,SAAS,KAAM,KAAM,UAAW,YAG9B,UAAO,CAChB,KAAM,IAAI,OAAM",
  "names": []
}
