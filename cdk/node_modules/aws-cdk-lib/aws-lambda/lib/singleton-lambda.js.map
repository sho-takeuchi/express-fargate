{
  "version": 3,
  "sources": ["singleton-lambda.ts"],
  "sourcesContent": ["import * as ec2 from '../../aws-ec2';\nimport * as iam from '../../aws-iam';\nimport * as logs from '../../aws-logs';\nimport * as cdk from '../../core';\nimport { Construct, IConstruct, IDependable, Node } from 'constructs';\nimport { Architecture } from './architecture';\nimport { Function as LambdaFunction, FunctionProps, EnvironmentOptions } from './function';\nimport { FunctionBase } from './function-base';\nimport { Version } from './lambda-version';\nimport { ILayerVersion } from './layers';\nimport { Permission } from './permission';\nimport { Runtime } from './runtime';\n\n                                                          \nexport interface SingletonFunctionProps extends FunctionProps {\n                                                                                                                                                                                              \n  readonly uuid: string;\n\n                                                                                                                                                                                                                                                                                   \n  readonly lambdaPurpose?: string;\n}\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \nexport class SingletonFunction extends FunctionBase {\n  public readonly grantPrincipal: iam.IPrincipal;\n  public readonly functionName: string;\n  public readonly functionArn: string;\n  public readonly role?: iam.IRole;\n  public readonly permissionsNode: Node;\n  public readonly architecture: Architecture;\n\n                                                                 \n  public readonly runtime: Runtime;\n\n  protected readonly canCreatePermissions: boolean;\n  private lambdaFunction: LambdaFunction;\n\n  constructor(scope: Construct, id: string, props: SingletonFunctionProps) {\n    super(scope, id);\n\n    this.lambdaFunction = this.ensureLambda(props);\n    this.permissionsNode = this.lambdaFunction.node;\n    this.architecture = this.lambdaFunction.architecture;\n\n    this.functionArn = this.lambdaFunction.functionArn;\n    this.functionName = this.lambdaFunction.functionName;\n    this.role = this.lambdaFunction.role;\n    this.runtime = this.lambdaFunction.runtime;\n    this.grantPrincipal = this.lambdaFunction.grantPrincipal;\n\n    this.canCreatePermissions = true; // Doesn't matter, addPermission is overriden anyway\n  }\n\n                            \n  public get isBoundToVpc(): boolean {\n    return this.lambdaFunction.isBoundToVpc;\n  }\n\n                            \n  public get connections(): ec2.Connections {\n    return this.lambdaFunction.connections;\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  public get logGroup(): logs.ILogGroup {\n    return this.lambdaFunction.logGroup;\n  }\n\n                                                                                                                                                                                                                                                                                                                                                             \n  public get currentVersion(): Version {\n    return this.lambdaFunction.currentVersion;\n  }\n\n                                                                                                                                                                                                                                                                                                         \n  public addEnvironment(key: string, value: string, options?: EnvironmentOptions) {\n    return this.lambdaFunction.addEnvironment(key, value, options);\n  }\n\n                                                                                                                                                                                                                                                     \n  public addLayers(...layers: ILayerVersion[]) {\n    return this.lambdaFunction.addLayers(...layers);\n  }\n\n  public addPermission(name: string, permission: Permission) {\n    return this.lambdaFunction.addPermission(name, permission);\n  }\n\n                                                                                                                                                                                                            \n  public addDependency(...up: IDependable[]) {\n    this.lambdaFunction.node.addDependency(...up);\n  }\n\n                                                                                                                                                                                                                    \n  public dependOn(down: IConstruct) {\n    down.node.addDependency(this.lambdaFunction);\n  }\n\n  /** @internal */\n  public _checkEdgeCompatibility() {\n    return this.lambdaFunction._checkEdgeCompatibility();\n  }\n\n  /**\n   * Returns the construct tree node that corresponds to the lambda function.\n   * @internal\n   */\n  protected _functionNode(): Node {\n    return this.lambdaFunction.node;\n  }\n\n  private ensureLambda(props: SingletonFunctionProps): LambdaFunction {\n    const constructName = (props.lambdaPurpose || 'SingletonLambda') + slugify(props.uuid);\n    const existing = cdk.Stack.of(this).node.tryFindChild(constructName);\n    if (existing) {\n      // Just assume this is true\n      return existing as LambdaFunction;\n    }\n\n    return new LambdaFunction(cdk.Stack.of(this), constructName, props);\n  }\n}\n\nfunction slugify(x: string): string {\n  return x.replace(/[^a-zA-Z0-9]/g, '');\n}\n"],
  "mappings": "wNAGA,IAAA,QAAA,cAGA,WAAA,QAAA,cACA,gBAAA,QAAA,mBAgBA,+BAAuC,iBAAA,YAAY,CAcjD,YAAY,MAAkB,GAAY,MAA6B,CACrE,MAAM,MAAO,iFAEb,KAAK,eAAiB,KAAK,aAAa,OACxC,KAAK,gBAAkB,KAAK,eAAe,KAC3C,KAAK,aAAe,KAAK,eAAe,aAExC,KAAK,YAAc,KAAK,eAAe,YACvC,KAAK,aAAe,KAAK,eAAe,aACxC,KAAK,KAAO,KAAK,eAAe,KAChC,KAAK,QAAU,KAAK,eAAe,QACnC,KAAK,eAAiB,KAAK,eAAe,eAE1C,KAAK,qBAAuB,MAInB,eAAY,CACrB,MAAO,MAAK,eAAe,gBAIlB,cAAW,CACpB,MAAO,MAAK,eAAe,eAIlB,WAAQ,CACjB,MAAO,MAAK,eAAe,YAIlB,iBAAc,CACvB,MAAO,MAAK,eAAe,eAItB,eAAe,IAAa,MAAe,QAA4B,mFACrE,KAAK,eAAe,eAAe,IAAK,MAAO,SAIjD,aAAa,OAAuB,6EAClC,KAAK,eAAe,UAAU,GAAG,QAGnC,cAAc,KAAc,WAAsB,8EAChD,KAAK,eAAe,cAAc,KAAM,YAI1C,iBAAiB,GAAiB,CACvC,KAAK,eAAe,KAAK,cAAc,GAAG,IAIrC,SAAS,KAAgB,CAC9B,KAAK,KAAK,cAAc,KAAK,gBAIxB,yBAAuB,CAC5B,MAAO,MAAK,eAAe,0BAOnB,eAAa,CACrB,MAAO,MAAK,eAAe,KAGrB,aAAa,MAA6B,CAChD,KAAM,eAAiB,OAAM,eAAiB,mBAAqB,QAAQ,MAAM,MAC3E,SAAW,IAAI,MAAM,GAAG,MAAM,KAAK,aAAa,eACtD,MAAI,WAKG,GAAI,YAAA,SAAe,IAAI,MAAM,GAAG,MAAO,cAAe,QA/FjE,QAAA,kBAAA,gIAmGA,iBAAiB,EAAS,CACxB,MAAO,GAAE,QAAQ,gBAAiB",
  "names": []
}
