{
  "version": 3,
  "sources": ["sqs.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport * as s3 from '../../aws-s3';\nimport * as sqs from '../../aws-sqs';\nimport { Construct } from 'constructs';\n\n                                                                \nexport class SqsDestination implements s3.IBucketNotificationDestination {\n  constructor(private readonly queue: sqs.IQueue) {\n  }\n\n                                                                                                                                        \n  public bind(_scope: Construct, bucket: s3.IBucket): s3.BucketNotificationDestinationConfig {\n    this.queue.grantSendMessages(new iam.ServicePrincipal('s3.amazonaws.com', {\n      conditions: {\n        ArnLike: { 'aws:SourceArn': bucket.bucketArn },\n      },\n    }));\n\n    // if this queue is encrypted, we need to allow S3 to read messages since that's how\n    // it verifies that the notification destination configuration is valid.\n    if (this.queue.encryptionMasterKey) {\n      this.queue.encryptionMasterKey.addToResourcePolicy(new iam.PolicyStatement({\n        principals: [new iam.ServicePrincipal('s3.amazonaws.com')],\n        actions: ['kms:GenerateDataKey*', 'kms:Decrypt'],\n        resources: ['*'],\n      }), /* allowNoOp */ false);\n    }\n\n    return {\n      arn: this.queue.queueArn,\n      type: s3.BucketNotificationDestinationType.QUEUE,\n      dependencies: [this.queue],\n    };\n  }\n\n}\n"],
  "mappings": "qNAAA,IAAA,QAAA,iBACA,GAAA,QAAA,gBAKA,oBAA2B,CACzB,YAA6B,MAAiB,CAAjB,KAAA,MAAA,gEAItB,KAAK,OAAmB,OAAkB,mEAC/C,KAAK,MAAM,kBAAkB,GAAI,KAAI,iBAAiB,mBAAoB,CACxE,WAAY,CACV,QAAS,CAAE,gBAAiB,OAAO,eAMnC,KAAK,MAAM,qBACb,KAAK,MAAM,oBAAoB,oBAAoB,GAAI,KAAI,gBAAgB,CACzE,WAAY,CAAC,GAAI,KAAI,iBAAiB,qBACtC,QAAS,CAAC,uBAAwB,eAClC,UAAW,CAAC,OACM,IAGf,CACL,IAAK,KAAK,MAAM,SAChB,KAAM,GAAG,kCAAkC,MAC3C,aAAc,CAAC,KAAK,SAzB1B,QAAA,eAAA",
  "names": []
}
