{
  "version": 3,
  "sources": ["service.ts"],
  "sourcesContent": ["import * as elbv2 from '../../aws-elasticloadbalancingv2';\nimport { Duration, IResource, Resource } from '../../core';\nimport { Construct } from 'constructs';\nimport { AliasTargetInstance } from './alias-target-instance';\nimport { CnameInstance, CnameInstanceBaseProps } from './cname-instance';\nimport { IInstance } from './instance';\nimport { IpInstance, IpInstanceBaseProps } from './ip-instance';\nimport { INamespace, NamespaceType } from './namespace';\nimport { NonIpInstance, NonIpInstanceBaseProps } from './non-ip-instance';\nimport { CfnService } from './servicediscovery.generated';\n\nexport interface IService extends IResource {\n                                                                 \n  readonly serviceName: string;\n\n                                                         \n  readonly namespace: INamespace;\n\n                                                                                                    \n  readonly serviceId: string;\n\n                                                                                                     \n  readonly serviceArn: string;\n\n                                                      \n  readonly dnsRecordType: DnsRecordType;\n\n                                                       \n  readonly routingPolicy: RoutingPolicy;\n}\n\n                                                                                                           \nexport interface BaseServiceProps {\n                                                                                         \n  readonly name?: string;\n\n                                                                      \n  readonly description?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly healthCheck?: HealthCheckConfig;\n\n                                                                                                                                                                                                                                                                                        \n  readonly customHealthCheck?: HealthCheckCustomConfig;\n}\n\n                                                                                                                                                   \nexport interface DnsServiceProps extends BaseServiceProps {\n                                                                                                                                                                                         \n  readonly dnsRecordType?: DnsRecordType;\n\n                                                                                                                                                               \n  readonly dnsTtl?: Duration;\n\n                                                                                                                                                                                                                                                                       \n  readonly routingPolicy?: RoutingPolicy;\n\n                                                                                                                                                                                                                                                                           \n  readonly loadBalancer?: boolean;\n}\n\nexport interface ServiceProps extends DnsServiceProps {\n                                                                          \n  readonly namespace: INamespace;\n}\n\nabstract class ServiceBase extends Resource implements IService {\n  public abstract namespace: INamespace;\n  public abstract serviceId: string;\n  public abstract serviceArn: string;\n  public abstract dnsRecordType: DnsRecordType;\n  public abstract routingPolicy: RoutingPolicy;\n  public abstract readonly serviceName: string;\n}\n\nexport interface ServiceAttributes {\n  readonly namespace: INamespace;\n  readonly serviceName: string;\n  readonly serviceId: string;\n  readonly serviceArn: string;\n  readonly dnsRecordType: DnsRecordType;\n  readonly routingPolicy: RoutingPolicy;\n}\n\n                                    \nexport class Service extends ServiceBase {\n\n  public static fromServiceAttributes(scope: Construct, id: string, attrs: ServiceAttributes): IService {\n    class Import extends ServiceBase {\n      public namespace: INamespace = attrs.namespace;\n      public serviceId = attrs.serviceId;\n      public serviceArn = attrs.serviceArn;\n      public dnsRecordType = attrs.dnsRecordType;\n      public routingPolicy = attrs.routingPolicy;\n      public serviceName = attrs.serviceName;\n    }\n\n    return new Import(scope, id);\n  }\n\n                                                 \n  public readonly serviceName: string;\n\n                                                         \n  public readonly namespace: INamespace;\n\n                                                                                    \n  public readonly serviceId: string;\n\n                                                                                     \n  public readonly serviceArn: string;\n\n                                                      \n  public readonly dnsRecordType: DnsRecordType;\n\n                                                       \n  public readonly routingPolicy: RoutingPolicy;\n\n  constructor(scope: Construct, id: string, props: ServiceProps) {\n    super(scope, id);\n\n    const namespaceType = props.namespace.type;\n\n    // Validations\n    if (namespaceType === NamespaceType.HTTP && (props.routingPolicy || props.dnsRecordType)) {\n      throw new Error('Cannot specify `routingPolicy` or `dnsRecord` when using an HTTP namespace.');\n    }\n\n    if (props.healthCheck && props.customHealthCheck) {\n      throw new Error('Cannot specify both `healthCheckConfig` and `healthCheckCustomConfig`.');\n    }\n\n    if (namespaceType === NamespaceType.DNS_PRIVATE && props.healthCheck) {\n      throw new Error('Cannot specify `healthCheckConfig` for a Private DNS namespace.');\n    }\n\n    if (props.routingPolicy === RoutingPolicy.MULTIVALUE\n        && props.dnsRecordType === DnsRecordType.CNAME) {\n      throw new Error('Cannot use `CNAME` record when routing policy is `Multivalue`.');\n    }\n\n    // Additional validation for eventual attachment of LBs\n    // The same validation happens later on during the actual attachment\n    // of LBs, but we need the property for the correct configuration of\n    // routingPolicy anyway, so might as well do the validation as well.\n    if (props.routingPolicy === RoutingPolicy.MULTIVALUE\n        && props.loadBalancer) {\n      throw new Error('Cannot register loadbalancers when routing policy is `Multivalue`.');\n    }\n\n    if (props.healthCheck\n        && props.healthCheck.type === HealthCheckType.TCP\n        && props.healthCheck.resourcePath) {\n      throw new Error('Cannot specify `resourcePath` when using a `TCP` health check.');\n    }\n\n    // Set defaults where necessary\n    const routingPolicy = (props.dnsRecordType === DnsRecordType.CNAME) || props.loadBalancer\n      ? RoutingPolicy.WEIGHTED\n      : RoutingPolicy.MULTIVALUE;\n\n    const dnsRecordType = props.dnsRecordType || DnsRecordType.A;\n\n    if (props.loadBalancer\n      && (!(dnsRecordType === DnsRecordType.A\n        || dnsRecordType === DnsRecordType.AAAA\n        || dnsRecordType === DnsRecordType.A_AAAA))) {\n      throw new Error('Must support `A` or `AAAA` records to register loadbalancers.');\n    }\n\n    const dnsConfig: CfnService.DnsConfigProperty | undefined = props.namespace.type === NamespaceType.HTTP\n      ? undefined\n      : {\n        dnsRecords: renderDnsRecords(dnsRecordType, props.dnsTtl),\n        namespaceId: props.namespace.namespaceId,\n        routingPolicy,\n      };\n\n    const healthCheckConfigDefaults = {\n      type: HealthCheckType.HTTP,\n      failureThreshold: 1,\n      resourcePath: props.healthCheck && props.healthCheck.type !== HealthCheckType.TCP\n        ? '/'\n        : undefined,\n    };\n\n    const healthCheckConfig = props.healthCheck && { ...healthCheckConfigDefaults, ...props.healthCheck };\n    const healthCheckCustomConfig = props.customHealthCheck;\n\n    // Create service\n    const service = new CfnService(this, 'Resource', {\n      name: props.name,\n      description: props.description,\n      dnsConfig,\n      healthCheckConfig,\n      healthCheckCustomConfig,\n      namespaceId: props.namespace.namespaceId,\n    });\n\n    this.serviceName = service.attrName;\n    this.serviceArn = service.attrArn;\n    this.serviceId = service.attrId;\n    this.namespace = props.namespace;\n    this.dnsRecordType = dnsRecordType;\n    this.routingPolicy = routingPolicy;\n  }\n\n                                                                                                \n  public registerLoadBalancer(id: string, loadBalancer: elbv2.ILoadBalancerV2, customAttributes?: {[key: string]: string}): IInstance {\n    return new AliasTargetInstance(this, id, {\n      service: this,\n      dnsName: loadBalancer.loadBalancerDnsName,\n      customAttributes,\n    });\n  }\n\n                                                                                                                        \n  public registerNonIpInstance(id: string, props: NonIpInstanceBaseProps): IInstance {\n    return new NonIpInstance(this, id, {\n      service: this,\n      ...props,\n    });\n  }\n\n                                                                             \n  public registerIpInstance(id: string, props: IpInstanceBaseProps): IInstance {\n    return new IpInstance(this, id, {\n      service: this,\n      ...props,\n    });\n  }\n\n                                                                       \n  public registerCnameInstance(id: string, props: CnameInstanceBaseProps): IInstance {\n    return new CnameInstance(this, id, {\n      service: this,\n      ...props,\n    });\n  }\n}\n\nfunction renderDnsRecords(dnsRecordType: DnsRecordType, dnsTtl: Duration = Duration.minutes(1)): CfnService.DnsRecordProperty[] {\n  const ttl = dnsTtl.toSeconds();\n\n  if (dnsRecordType === DnsRecordType.A_AAAA) {\n    return [{\n      type: DnsRecordType.A,\n      ttl,\n    }, {\n      type: DnsRecordType.AAAA,\n      ttl,\n    }];\n  } else {\n    return [{ type: dnsRecordType, ttl }];\n  }\n}\n\n                                                                                                                                                                                                                                                    \nexport interface HealthCheckConfig {\n                                                                                                                                                                                                                                                   \n  readonly type?: HealthCheckType;\n\n                                                                                                                                                           \n  readonly resourcePath?: string;\n\n                                                                                                                                                                                                                        \n  readonly failureThreshold?: number;\n}\n\n                                                                       \nexport interface HealthCheckCustomConfig {\n                                                                                                                                                                                                                                   \n  readonly failureThreshold?: number;\n}\n\nexport enum DnsRecordType {\n                            \n  A = 'A',\n\n                               \n  AAAA = 'AAAA',\n\n                                          \n  A_AAAA = 'A, AAAA',\n\n                             \n  SRV = 'SRV',\n\n                               \n  CNAME = 'CNAME',\n}\n\nexport enum RoutingPolicy {\n                                                                                                                                                                    \n  WEIGHTED = 'WEIGHTED',\n\n                                                                                                                                                                    \n  MULTIVALUE = 'MULTIVALUE',\n}\n\nexport enum HealthCheckType {\n                                                                                                                                                                                          \n  HTTP = 'HTTP',\n\n                                                                                                                                                                                                                                                                                          \n  HTTPS = 'HTTPS',\n\n                                                                                                                                        \n  TCP = 'TCP',\n}\n"],
  "mappings": "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",
  "names": []
}
