{
  "version": 3,
  "sources": ["queue.ts"],
  "sourcesContent": ["import * as kms from '../../aws-kms';\nimport { Duration, RemovalPolicy, Stack, Token, ArnFormat } from '../../core';\nimport { Construct } from 'constructs';\nimport { IQueue, QueueAttributes, QueueBase } from './queue-base';\nimport { CfnQueue } from './sqs.generated';\nimport { validateProps } from './validate-props';\n\n                                              \nexport interface QueueProps {\n                                                                                                                                                                        \n  readonly queueName?: string;\n\n                                                                                                                                                                                                                                                                    \n  readonly retentionPeriod?: Duration;\n\n                                                                                                                                                                                                                      \n  readonly deliveryDelay?: Duration;\n\n                                                                                                                                                                                                                                                                         \n  readonly maxMessageSizeBytes?: number;\n\n                                                                                                                                                                                                                                                                \n  readonly receiveMessageWaitTime?: Duration;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  readonly visibilityTimeout?: Duration;\n\n                                                                                                                                            \n  readonly deadLetterQueue?: DeadLetterQueue;\n\n                                                                                                                                                                                                                                                        \n  readonly encryption?: QueueEncryption;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n  readonly encryptionMasterKey?: kms.IKey;\n\n                                                                                                                                                                                                                                                               \n  readonly dataKeyReuse?: Duration;\n\n                                                                                                                                                                   \n  readonly fifo?: boolean;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n  readonly contentBasedDeduplication?: boolean;\n\n                                                                                                                                                                                                                                   \n  readonly deduplicationScope?: DeduplicationScope;\n\n                                                                                                                                                                                                                                                        \n  readonly fifoThroughputLimit?: FifoThroughputLimit;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                         \n  readonly removalPolicy?: RemovalPolicy;\n}\n\n                                     \nexport interface DeadLetterQueue {\n                                                                                                                         \n  readonly queue: IQueue;\n\n                                                                                                                         \n  readonly maxReceiveCount: number;\n}\n\n                                                         \nexport enum QueueEncryption {\n                                                        \n  UNENCRYPTED = 'NONE',\n\n                                                                             \n  KMS_MANAGED = 'MANAGED',\n\n                                                                                                                                                                             \n  KMS = 'KMS',\n}\n\n                                                    \nexport enum DeduplicationScope {\n                                                                \n  MESSAGE_GROUP = 'messageGroup',\n                                                                \n  QUEUE = 'queue',\n}\n\n                                                                                                   \nexport enum FifoThroughputLimit {\n                                                   \n  PER_QUEUE = 'perQueue',\n                                                              \n  PER_MESSAGE_GROUP_ID = 'perMessageGroupId',\n}\n\n                                 \nexport class Queue extends QueueBase {\n\n                                                                                                                                                                                                                                      \n  public static fromQueueArn(scope: Construct, id: string, queueArn: string): IQueue {\n    return Queue.fromQueueAttributes(scope, id, { queueArn });\n  }\n\n                                         \n  public static fromQueueAttributes(scope: Construct, id: string, attrs: QueueAttributes): IQueue {\n    const stack = Stack.of(scope);\n    const parsedArn = stack.splitArn(attrs.queueArn, ArnFormat.NO_RESOURCE_NAME);\n    const queueName = attrs.queueName || parsedArn.resource;\n    const queueUrl = attrs.queueUrl || `https://sqs.${parsedArn.region}.${stack.urlSuffix}/${parsedArn.account}/${queueName}`;\n\n    class Import extends QueueBase {\n      public readonly queueArn = attrs.queueArn; // arn:aws:sqs:us-east-1:123456789012:queue1\n      public readonly queueUrl = queueUrl;\n      public readonly queueName = queueName;\n      public readonly encryptionMasterKey = attrs.keyArn\n        ? kms.Key.fromKeyArn(this, 'Key', attrs.keyArn)\n        : undefined;\n      public readonly fifo: boolean = this.determineFifo();\n\n      protected readonly autoCreatePolicy = false;\n\n      /**\n       * Determine fifo flag based on queueName and fifo attribute\n       */\n      private determineFifo(): boolean {\n        if (Token.isUnresolved(this.queueArn)) {\n          return attrs.fifo || false;\n        } else {\n          if (typeof attrs.fifo !== 'undefined') {\n            if (attrs.fifo && !queueName.endsWith('.fifo')) {\n              throw new Error(\"FIFO queue names must end in '.fifo'\");\n            }\n            if (!attrs.fifo && queueName.endsWith('.fifo')) {\n              throw new Error(\"Non-FIFO queue name may not end in '.fifo'\");\n            }\n          }\n          return queueName.endsWith('.fifo') ? true : false;\n        }\n      }\n    }\n\n    return new Import(scope, id);\n  }\n\n                                      \n  public readonly queueArn: string;\n\n                                       \n  public readonly queueName: string;\n\n                                      \n  public readonly queueUrl: string;\n\n                                                                 \n  public readonly encryptionMasterKey?: kms.IKey;\n\n                                                                                                    \n  public readonly fifo: boolean;\n\n                                                                                                              \n  public readonly deadLetterQueue?: DeadLetterQueue;\n\n  protected readonly autoCreatePolicy = true;\n\n  constructor(scope: Construct, id: string, props: QueueProps = {}) {\n    super(scope, id, {\n      physicalName: props.queueName,\n    });\n\n    validateProps(props);\n\n    const redrivePolicy = props.deadLetterQueue\n      ? {\n        deadLetterTargetArn: props.deadLetterQueue.queue.queueArn,\n        maxReceiveCount: props.deadLetterQueue.maxReceiveCount,\n      }\n      : undefined;\n\n    const { encryptionMasterKey, encryptionProps } = _determineEncryptionProps.call(this);\n\n    const fifoProps = this.determineFifoProps(props);\n    this.fifo = fifoProps.fifoQueue || false;\n\n    const queue = new CfnQueue(this, 'Resource', {\n      queueName: this.physicalName,\n      ...fifoProps,\n      ...encryptionProps,\n      redrivePolicy,\n      delaySeconds: props.deliveryDelay && props.deliveryDelay.toSeconds(),\n      maximumMessageSize: props.maxMessageSizeBytes,\n      messageRetentionPeriod: props.retentionPeriod && props.retentionPeriod.toSeconds(),\n      receiveMessageWaitTimeSeconds: props.receiveMessageWaitTime && props.receiveMessageWaitTime.toSeconds(),\n      visibilityTimeout: props.visibilityTimeout && props.visibilityTimeout.toSeconds(),\n    });\n    queue.applyRemovalPolicy(props.removalPolicy ?? RemovalPolicy.DESTROY);\n\n    this.queueArn = this.getResourceArnAttribute(queue.attrArn, {\n      service: 'sqs',\n      resource: this.physicalName,\n    });\n    this.queueName = this.getResourceNameAttribute(queue.attrQueueName);\n    this.encryptionMasterKey = encryptionMasterKey;\n    this.queueUrl = queue.ref;\n    this.deadLetterQueue = props.deadLetterQueue;\n\n    function _determineEncryptionProps(this: Queue): { encryptionProps: EncryptionProps, encryptionMasterKey?: kms.IKey } {\n      let encryption = props.encryption || QueueEncryption.UNENCRYPTED;\n\n      if (encryption !== QueueEncryption.KMS && props.encryptionMasterKey) {\n        encryption = QueueEncryption.KMS; // KMS is implied by specifying an encryption key\n      }\n\n      if (encryption === QueueEncryption.UNENCRYPTED) {\n        return { encryptionProps: {} };\n      }\n\n      if (encryption === QueueEncryption.KMS_MANAGED) {\n        return {\n          encryptionProps: {\n            kmsMasterKeyId: 'alias/aws/sqs',\n            kmsDataKeyReusePeriodSeconds: props.dataKeyReuse && props.dataKeyReuse.toSeconds(),\n          },\n        };\n      }\n\n      if (encryption === QueueEncryption.KMS) {\n        const masterKey = props.encryptionMasterKey || new kms.Key(this, 'Key', {\n          description: `Created by ${this.node.path}`,\n        });\n\n        return {\n          encryptionMasterKey: masterKey,\n          encryptionProps: {\n            kmsMasterKeyId: masterKey.keyArn,\n            kmsDataKeyReusePeriodSeconds: props.dataKeyReuse && props.dataKeyReuse.toSeconds(),\n          },\n        };\n      }\n\n      throw new Error(`Unexpected 'encryptionType': ${encryption}`);\n    }\n  }\n\n  /**\n   * Look at the props, see if the FIFO props agree, and return the correct subset of props\n   */\n  private determineFifoProps(props: QueueProps): FifoProps {\n    // Check if any of the signals that we have say that this is a FIFO queue.\n    let fifoQueue = props.fifo;\n    const queueName = props.queueName;\n    if (typeof fifoQueue === 'undefined' && queueName && !Token.isUnresolved(queueName) && queueName.endsWith('.fifo')) { fifoQueue = true; }\n    if (typeof fifoQueue === 'undefined' && props.contentBasedDeduplication) { fifoQueue = true; }\n    if (typeof fifoQueue === 'undefined' && props.deduplicationScope) { fifoQueue = true; }\n    if (typeof fifoQueue === 'undefined' && props.fifoThroughputLimit) { fifoQueue = true; }\n\n    // If we have a name, see that it agrees with the FIFO setting\n    if (typeof queueName === 'string') {\n      if (fifoQueue && !queueName.endsWith('.fifo')) {\n        throw new Error(\"FIFO queue names must end in '.fifo'\");\n      }\n      if (!fifoQueue && queueName.endsWith('.fifo')) {\n        throw new Error(\"Non-FIFO queue name may not end in '.fifo'\");\n      }\n    }\n\n    if (props.contentBasedDeduplication && !fifoQueue) {\n      throw new Error('Content-based deduplication can only be defined for FIFO queues');\n    }\n\n    if (props.deduplicationScope && !fifoQueue) {\n      throw new Error('Deduplication scope can only be defined for FIFO queues');\n    }\n\n    if (props.fifoThroughputLimit && !fifoQueue) {\n      throw new Error('FIFO throughput limit can only be defined for FIFO queues');\n    }\n\n    return {\n      contentBasedDeduplication: props.contentBasedDeduplication,\n      deduplicationScope: props.deduplicationScope,\n      fifoThroughputLimit: props.fifoThroughputLimit,\n      fifoQueue,\n    };\n  }\n}\n\ninterface FifoProps {\n  readonly fifoQueue?: boolean;\n  readonly contentBasedDeduplication?: boolean;\n  readonly deduplicationScope?: DeduplicationScope;\n  readonly fifoThroughputLimit?: FifoThroughputLimit;\n}\n\ninterface EncryptionProps {\n  readonly kmsMasterKeyId?: string;\n  readonly kmsDataKeyReusePeriodSeconds?: number;\n}\n"],
  "mappings": "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",
  "names": []
}
