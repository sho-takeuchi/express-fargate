{
  "version": 3,
  "sources": ["fields.ts"],
  "sourcesContent": ["import { Token, IResolvable } from '../../core';\nimport { findReferencedPaths, jsonPathString, JsonPathToken, renderObject, renderInExpression, jsonPathFromAny } from './private/json-path';\n\n                                                                                                                                                                                                             \nexport class JsonPath {\n                                                                              \n  public static readonly DISCARD = 'DISCARD';\n\n                                                                                  \n  public static stringAt(path: string): string {\n    validateJsonPath(path);\n    return new JsonPathToken(path).toString();\n  }\n\n                                                                                       \n  public static listAt(path: string): string[] {\n    // does not apply to task context\n    validateDataPath(path);\n    return Token.asList(new JsonPathToken(path));\n  }\n\n                                                                                  \n  public static numberAt(path: string): number {\n    validateJsonPath(path);\n    return Token.asNumber(new JsonPathToken(path));\n  }\n\n                                                                              \n  public static objectAt(path: string): IResolvable {\n    validateJsonPath(path);\n    return new JsonPathToken(path);\n  }\n\n                                                                                                                                                          \n  public static get entirePayload(): string {\n    return new JsonPathToken('$').toString();\n  }\n\n                                                                                                                         \n  public static isEncodedJsonPath(value: string): boolean {\n    return !!jsonPathString(value);\n  }\n\n                                                                                                                                                                                                              \n  public static get taskToken(): string {\n    return new JsonPathToken('$$.Task.Token').toString();\n  }\n\n                                                                                                                                                                  \n  public static get entireContext(): string {\n    return new JsonPathToken('$$').toString();\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  public static array(...values: string[]): string {\n    return new JsonPathToken(`States.Array(${values.map(renderInExpression).join(', ')})`).toString();\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                  \n  public static format(formatString: string, ...values: string[]): string {\n    const allArgs = [formatString, ...values];\n    return new JsonPathToken(`States.Format(${allArgs.map(renderInExpression).join(', ')})`).toString();\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                             \n  public static stringToJson(jsonString: string): IResolvable {\n    return new JsonPathToken(`States.StringToJson(${renderInExpression(jsonString)})`);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                \n  public static jsonToString(value: any): string {\n    const path = jsonPathFromAny(value);\n    if (!path) {\n      throw new Error('Argument to JsonPath.jsonToString() must be a JsonPath object');\n    }\n\n    return new JsonPathToken(`States.JsonToString(${path})`).toString();\n  }\n\n  private constructor() {}\n}\n\n                                                                                                                                      \nexport class Data {\n                                                                                  \n  public static stringAt(path: string): string {\n    validateDataPath(path);\n    return new JsonPathToken(path).toString();\n  }\n\n                                                                                       \n  public static listAt(path: string): string[] {\n    validateDataPath(path);\n    return Token.asList(new JsonPathToken(path));\n  }\n\n                                                                                  \n  public static numberAt(path: string): number {\n    validateDataPath(path);\n    return Token.asNumber(new JsonPathToken(path));\n  }\n\n                                                                                                                                                          \n  public static get entirePayload(): string {\n    return new JsonPathToken('$').toString();\n  }\n\n                                                                                                                         \n  public static isJsonPathString(value: string): boolean {\n    return !!jsonPathString(value);\n  }\n\n  private constructor() {}\n}\n\n                                                                                                                                                                                                                         \nexport class Context {\n                                                                                  \n  public static stringAt(path: string): string {\n    validateContextPath(path);\n    return new JsonPathToken(path).toString();\n  }\n\n                                                                                  \n  public static numberAt(path: string): number {\n    validateContextPath(path);\n    return Token.asNumber(new JsonPathToken(path));\n  }\n\n                                                                                                                                                                                                              \n  public static get taskToken(): string {\n    return new JsonPathToken('$$.Task.Token').toString();\n  }\n\n                                                                                                                                                                  \n  public static get entireContext(): string {\n    return new JsonPathToken('$$').toString();\n  }\n\n  private constructor() {}\n}\n\n                                                                     \nexport class FieldUtils {\n                                                                                               \n  public static renderObject(obj?: { [key: string]: any }): { [key: string]: any } | undefined {\n    return renderObject(obj);\n  }\n\n                                                                  \n  public static findReferencedPaths(obj?: { [key: string]: any }): string[] {\n    return Array.from(findReferencedPaths(obj)).sort();\n  }\n\n                                                                                                                                                                                                                                   \n  public static containsTaskToken(obj?: { [key: string]: any }): boolean {\n    const paths = findReferencedPaths(obj);\n    return paths.has('$$.Task.Token') || paths.has('$$.Task') || paths.has('$$');\n  }\n\n  private constructor() {}\n}\n\nfunction validateJsonPath(path: string) {\n  if (path !== '$'\n    && !path.startsWith('$.')\n    && path !== '$$'\n    && !path.startsWith('$$.')\n    && !path.startsWith('$[')\n    && ['Format', 'StringToJson', 'JsonToString', 'Array'].every(fn => !path.startsWith(`States.${fn}`))\n  ) {\n    throw new Error(`JSON path values must be exactly '$', '$$', start with '$.', start with '$$.', start with '$[', or start with an intrinsic function: States.Format, States.StringToJson, States.JsonToString, or States.Array. Received: ${path}`);\n  }\n}\n\nfunction validateDataPath(path: string) {\n  if (path !== '$' && !path.startsWith('$.')) {\n    throw new Error(\"Data JSON path values must either be exactly equal to '$' or start with '$.'\");\n  }\n}\n\nfunction validateContextPath(path: string) {\n  if (path !== '$$' && !path.startsWith('$$.')) {\n    throw new Error(\"Context JSON path values must either be exactly equal to '$$' or start with '$$.'\");\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
