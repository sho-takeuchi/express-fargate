{
  "version": 3,
  "sources": ["state-graph.ts"],
  "sourcesContent": ["import * as iam from '../../aws-iam';\nimport { Duration } from '../../core';\nimport { State } from './states/state';\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \nexport class StateGraph {\n                                                                                                                                                                                                      \n  public timeout?: Duration;\n\n                                                  \n  public readonly policyStatements = new Array<iam.PolicyStatement>();\n\n  /**\n   * All states in this graph\n   */\n  private readonly allStates = new Set<State>();\n\n  /**\n   * A mapping of stateId -> Graph for all states in this graph and subgraphs\n   */\n  private readonly allContainedStates = new Map<string, StateGraph>();\n\n  /**\n   * Containing graph of this graph\n   */\n  private superGraph?: StateGraph;\n\n                                                                                                                                                            \n  constructor(public readonly startState: State, private readonly graphDescription: string) {\n    this.allStates.add(startState);\n    startState.bindToGraph(this);\n  }\n\n                                                                                                \n  public registerState(state: State) {\n    this.registerContainedState(state.stateId, this);\n    this.allStates.add(state);\n  }\n\n                                                                         \n  public registerPolicyStatement(statement: iam.PolicyStatement) {\n    if (this.superGraph) {\n      this.superGraph.registerPolicyStatement(statement);\n    } else {\n      this.policyStatements.push(statement);\n    }\n  }\n\n                                                                                                                                    \n  public registerSuperGraph(graph: StateGraph) {\n    if (this.superGraph === graph) { return; }\n    if (this.superGraph) {\n      throw new Error('Every StateGraph can only be registered into one other StateGraph');\n    }\n    this.superGraph = graph;\n    this.pushContainedStatesUp(graph);\n    this.pushPolicyStatementsUp(graph);\n  }\n\n                                                                      \n  public toGraphJson(): object {\n    const states: any = {};\n    for (const state of this.allStates) {\n      states[state.stateId] = state.toStateJson();\n    }\n\n    return {\n      StartAt: this.startState.stateId,\n      States: states,\n      TimeoutSeconds: this.timeout && this.timeout.toSeconds(),\n    };\n  }\n\n                                                          \n  public toString() {\n    const someNodes = Array.from(this.allStates).slice(0, 3).map(x => x.stateId);\n    if (this.allStates.size > 3) { someNodes.push('...'); }\n    return `${this.graphDescription} (${someNodes.join(', ')})`;\n  }\n\n  /**\n   * Register a stateId and graph where it was registered\n   */\n  private registerContainedState(stateId: string, graph: StateGraph) {\n    if (this.superGraph) {\n      this.superGraph.registerContainedState(stateId, graph);\n    } else {\n      const existingGraph = this.allContainedStates.get(stateId);\n      if (existingGraph) {\n        throw new Error(`State with name '${stateId}' occurs in both ${graph} and ${existingGraph}. All states must have unique names.`);\n      }\n\n      this.allContainedStates.set(stateId, graph);\n    }\n  }\n\n  /**\n   * Push all contained state info up to the given super graph\n   */\n  private pushContainedStatesUp(superGraph: StateGraph) {\n    for (const [stateId, graph] of this.allContainedStates) {\n      superGraph.registerContainedState(stateId, graph);\n    }\n  }\n\n  /**\n   * Push all policy statements to into the given super graph\n   */\n  private pushPolicyStatementsUp(superGraph: StateGraph) {\n    for (const policyStatement of this.policyStatements) {\n      superGraph.registerPolicyStatement(policyStatement);\n    }\n  }\n\n}\n"],
  "mappings": "iNAKA,gBAAuB,CAuBrB,YAA4B,WAAoC,iBAAwB,CAA5D,KAAA,WAAA,WAAoC,KAAA,iBAAA,iBAlBhD,KAAA,iBAAmB,GAAI,OAKtB,KAAA,UAAY,GAAI,KAKhB,KAAA,mBAAqB,GAAI,6EASxC,KAAK,UAAU,IAAI,YACnB,WAAW,YAAY,MAIlB,cAAc,MAAY,oEAC/B,KAAK,uBAAuB,MAAM,QAAS,MAC3C,KAAK,UAAU,IAAI,OAId,wBAAwB,UAA8B,wEAC3D,AAAI,KAAK,WACP,KAAK,WAAW,wBAAwB,WAExC,KAAK,iBAAiB,KAAK,WAKxB,mBAAmB,MAAiB,CACzC,2EAAI,KAAK,aAAe,MACxB,IAAI,KAAK,WACP,KAAM,IAAI,OAAM,qEAElB,KAAK,WAAa,MAClB,KAAK,sBAAsB,OAC3B,KAAK,uBAAuB,QAIvB,aAAW,CAChB,KAAM,QAAc,GACpB,SAAW,SAAS,MAAK,UACvB,OAAO,MAAM,SAAW,MAAM,cAGhC,MAAO,CACL,QAAS,KAAK,WAAW,QACzB,OAAQ,OACR,eAAgB,KAAK,SAAW,KAAK,QAAQ,aAK1C,UAAQ,CACb,KAAM,WAAY,MAAM,KAAK,KAAK,WAAW,MAAM,EAAG,GAAG,IAAI,GAAK,EAAE,SACpE,MAAI,MAAK,UAAU,KAAO,GAAK,UAAU,KAAK,OACvC,GAAG,KAAK,qBAAqB,UAAU,KAAK,SAM7C,uBAAuB,QAAiB,MAAiB,CAC/D,GAAI,KAAK,WACP,KAAK,WAAW,uBAAuB,QAAS,WAC3C,CACL,KAAM,eAAgB,KAAK,mBAAmB,IAAI,SAClD,GAAI,cACF,KAAM,IAAI,OAAM,oBAAoB,2BAA2B,aAAa,qDAG9E,KAAK,mBAAmB,IAAI,QAAS,QAOjC,sBAAsB,WAAsB,CAClD,SAAW,CAAC,QAAS,QAAU,MAAK,mBAClC,WAAW,uBAAuB,QAAS,OAOvC,uBAAuB,WAAsB,CACnD,SAAW,mBAAmB,MAAK,iBACjC,WAAW,wBAAwB,kBAzGzC,QAAA,WAAA",
  "names": []
}
