{
  "version": 3,
  "sources": ["state-machine.ts"],
  "sourcesContent": ["import * as cloudwatch from '../../aws-cloudwatch';\nimport * as iam from '../../aws-iam';\nimport * as logs from '../../aws-logs';\nimport { Arn, ArnFormat, Duration, IResource, Resource, Stack, Token } from '../../core';\nimport { Construct } from 'constructs';\nimport { StateGraph } from './state-graph';\nimport { StatesMetrics } from './stepfunctions-canned-metrics.generated';\nimport { CfnStateMachine } from './stepfunctions.generated';\nimport { IChainable } from './types';\n\n                                                                                                                                                                                                                           \nexport enum StateMachineType {\n                                                                                         \n  EXPRESS = 'EXPRESS',\n\n                                                                                                 \n  STANDARD = 'STANDARD'\n}\n\n                                                                                                                                                                                        \nexport enum LogLevel {\n                           \n  OFF = 'OFF',\n                               \n  ALL = 'ALL',\n                               \n  ERROR = 'ERROR',\n                                 \n  FATAL = 'FATAL'\n}\n\n                                                                                      \nexport interface LogOptions {\n                                                                                 \n  readonly destination: logs.ILogGroup;\n\n                                                                                                   \n  readonly includeExecutionData?: boolean;\n\n                                                                                                        \n  readonly level?: LogLevel;\n}\n\n                                                  \nexport interface StateMachineProps {\n                                                                                                  \n  readonly stateMachineName?: string;\n\n                                                  \n  readonly definition: IChainable;\n\n                                                                                                                    \n  readonly role?: iam.IRole;\n\n                                                                                      \n  readonly timeout?: Duration;\n\n                                                                                       \n  readonly stateMachineType?: StateMachineType;\n\n                                                                                                                          \n  readonly logs?: LogOptions;\n\n                                                                                                                   \n  readonly tracingEnabled?: boolean;\n}\n\n/**\n * A new or imported state machine.\n */\nabstract class StateMachineBase extends Resource implements IStateMachine {\n\n                                       \n  public static fromStateMachineArn(scope: Construct, id: string, stateMachineArn: string): IStateMachine {\n    class Import extends StateMachineBase {\n      public readonly stateMachineArn = stateMachineArn;\n      public readonly grantPrincipal = new iam.UnknownPrincipal({ resource: this });\n    }\n    return new Import(scope, id);\n  }\n\n  public abstract readonly stateMachineArn: string;\n\n  /**\n   * The principal this state machine is running as\n   */\n  public abstract readonly grantPrincipal: iam.IPrincipal;\n\n                                                                                                       \n  public grantStartExecution(identity: iam.IGrantable): iam.Grant {\n    return iam.Grant.addToPrincipal({\n      grantee: identity,\n      actions: ['states:StartExecution'],\n      resourceArns: [this.stateMachineArn],\n    });\n  }\n\n                                                                                                                  \n  public grantStartSyncExecution(identity: iam.IGrantable): iam.Grant {\n    return iam.Grant.addToPrincipal({\n      grantee: identity,\n      actions: ['states:StartSyncExecution'],\n      resourceArns: [this.stateMachineArn],\n    });\n  }\n\n                                                                                              \n  public grantRead(identity: iam.IGrantable): iam.Grant {\n    iam.Grant.addToPrincipal({\n      grantee: identity,\n      actions: [\n        'states:ListExecutions',\n        'states:ListStateMachines',\n      ],\n      resourceArns: [this.stateMachineArn],\n    });\n    iam.Grant.addToPrincipal({\n      grantee: identity,\n      actions: [\n        'states:DescribeExecution',\n        'states:DescribeStateMachineForExecution',\n        'states:GetExecutionHistory',\n      ],\n      resourceArns: [`${this.executionArn()}:*`],\n    });\n    return iam.Grant.addToPrincipal({\n      grantee: identity,\n      actions: [\n        'states:ListActivities',\n        'states:DescribeStateMachine',\n        'states:DescribeActivity',\n      ],\n      resourceArns: ['*'],\n    });\n  }\n\n                                                                                      \n  public grantTaskResponse(identity: iam.IGrantable): iam.Grant {\n    return iam.Grant.addToPrincipal({\n      grantee: identity,\n      actions: [\n        'states:SendTaskSuccess',\n        'states:SendTaskFailure',\n        'states:SendTaskHeartbeat',\n      ],\n      resourceArns: [this.stateMachineArn],\n    });\n  }\n\n                                                                                            \n  public grantExecution(identity: iam.IGrantable, ...actions: string[]) {\n    return iam.Grant.addToPrincipal({\n      grantee: identity,\n      actions,\n      resourceArns: [`${this.executionArn()}:*`],\n    });\n  }\n\n                                                            \n  public grant(identity: iam.IGrantable, ...actions: string[]): iam.Grant {\n    return iam.Grant.addToPrincipal({\n      grantee: identity,\n      actions,\n      resourceArns: [this.stateMachineArn],\n    });\n  }\n\n\n                                                                                                                          \n  public metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      namespace: 'AWS/States',\n      metricName,\n      dimensionsMap: { StateMachineArn: this.stateMachineArn },\n      statistic: 'sum',\n      ...props,\n    }).attachTo(this);\n  }\n\n                                                                                                        \n  public metricFailed(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(StatesMetrics.executionsFailedSum, props);\n  }\n\n                                                                                                                \n  public metricThrottled(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    // There's a typo in the \"canned\" version of this\n    return this.metric('ExecutionThrottled', props);\n  }\n\n                                                                                                              \n  public metricAborted(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(StatesMetrics.executionsAbortedSum, props);\n  }\n\n                                                                                                           \n  public metricSucceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(StatesMetrics.executionsSucceededSum, props);\n  }\n\n                                                                                                           \n  public metricTimedOut(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(StatesMetrics.executionsTimedOutSum, props);\n  }\n\n                                                                                                              \n  public metricStarted(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.metric('ExecutionsStarted', props);\n  }\n\n                                                                                                                                                                   \n  public metricTime(props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return this.cannedMetric(StatesMetrics.executionTimeAverage, props);\n  }\n\n  /**\n   * Returns the pattern for the execution ARN's of the state machine\n   */\n  private executionArn(): string {\n    return Stack.of(this).formatArn({\n      resource: 'execution',\n      service: 'states',\n      resourceName: Arn.split(this.stateMachineArn, ArnFormat.COLON_RESOURCE_NAME).resourceName,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n  }\n\n  private cannedMetric(\n    fn: (dims: { StateMachineArn: string }) => cloudwatch.MetricProps,\n    props?: cloudwatch.MetricOptions): cloudwatch.Metric {\n    return new cloudwatch.Metric({\n      ...fn({ StateMachineArn: this.stateMachineArn }),\n      ...props,\n    }).attachTo(this);\n  }\n}\n\n                                               \nexport class StateMachine extends StateMachineBase {\n                                                     \n  public readonly role: iam.IRole;\n\n                                                              \n  public readonly stateMachineName: string;\n\n                                             \n  public readonly stateMachineArn: string;\n\n                                                          \n  public readonly stateMachineType: StateMachineType;\n\n  constructor(scope: Construct, id: string, props: StateMachineProps) {\n    super(scope, id, {\n      physicalName: props.stateMachineName,\n    });\n\n    if (props.stateMachineName !== undefined) {\n      this.validateStateMachineName(props.stateMachineName);\n    }\n\n    this.role = props.role || new iam.Role(this, 'Role', {\n      assumedBy: new iam.ServicePrincipal('states.amazonaws.com'),\n    });\n\n    const graph = new StateGraph(props.definition.startState, `State Machine ${id} definition`);\n    graph.timeout = props.timeout;\n\n    this.stateMachineType = props.stateMachineType ?? StateMachineType.STANDARD;\n\n    const resource = new CfnStateMachine(this, 'Resource', {\n      stateMachineName: this.physicalName,\n      stateMachineType: props.stateMachineType ?? undefined,\n      roleArn: this.role.roleArn,\n      definitionString: Stack.of(this).toJsonString(graph.toGraphJson()),\n      loggingConfiguration: props.logs ? this.buildLoggingConfiguration(props.logs) : undefined,\n      tracingConfiguration: props.tracingEnabled ? this.buildTracingConfiguration() : undefined,\n    });\n\n    resource.node.addDependency(this.role);\n\n    for (const statement of graph.policyStatements) {\n      this.addToRolePolicy(statement);\n    }\n\n    this.stateMachineName = this.getResourceNameAttribute(resource.attrName);\n    this.stateMachineArn = this.getResourceArnAttribute(resource.ref, {\n      service: 'states',\n      resource: 'stateMachine',\n      resourceName: this.physicalName,\n      arnFormat: ArnFormat.COLON_RESOURCE_NAME,\n    });\n  }\n\n                                                               \n  public get grantPrincipal() {\n    return this.role.grantPrincipal;\n  }\n\n                                                             \n  public addToRolePolicy(statement: iam.PolicyStatement) {\n    this.role.addToPrincipalPolicy(statement);\n  }\n\n  private validateStateMachineName(stateMachineName: string) {\n    if (!Token.isUnresolved(stateMachineName)) {\n      if (stateMachineName.length < 1 || stateMachineName.length > 80) {\n        throw new Error(`State Machine name must be between 1 and 80 characters. Received: ${stateMachineName}`);\n      }\n\n      if (!stateMachineName.match(/^[a-z0-9\\+\\!\\@\\.\\(\\)\\-\\=\\_\\']+$/i)) {\n        throw new Error(`State Machine name must match \"^[a-z0-9+!@.()-=_']+$/i\". Received: ${stateMachineName}`);\n      }\n    }\n  }\n\n  private buildLoggingConfiguration(logOptions: LogOptions): CfnStateMachine.LoggingConfigurationProperty {\n    // https://docs.aws.amazon.com/step-functions/latest/dg/cw-logs.html#cloudwatch-iam-policy\n    this.addToRolePolicy(new iam.PolicyStatement({\n      effect: iam.Effect.ALLOW,\n      actions: [\n        'logs:CreateLogDelivery',\n        'logs:GetLogDelivery',\n        'logs:UpdateLogDelivery',\n        'logs:DeleteLogDelivery',\n        'logs:ListLogDeliveries',\n        'logs:PutResourcePolicy',\n        'logs:DescribeResourcePolicies',\n        'logs:DescribeLogGroups',\n      ],\n      resources: ['*'],\n    }));\n\n    return {\n      destinations: [{\n        cloudWatchLogsLogGroup: { logGroupArn: logOptions.destination.logGroupArn },\n      }],\n      includeExecutionData: logOptions.includeExecutionData,\n      level: logOptions.level || 'ERROR',\n    };\n  }\n\n  private buildTracingConfiguration(): CfnStateMachine.TracingConfigurationProperty {\n    this.addToRolePolicy(new iam.PolicyStatement({\n      // https://docs.aws.amazon.com/xray/latest/devguide/security_iam_id-based-policy-examples.html#xray-permissions-resources\n      // https://docs.aws.amazon.com/step-functions/latest/dg/xray-iam.html\n      actions: [\n        'xray:PutTraceSegments',\n        'xray:PutTelemetryRecords',\n        'xray:GetSamplingRules',\n        'xray:GetSamplingTargets',\n      ],\n      resources: ['*'],\n    }));\n\n    return {\n      enabled: true,\n    };\n  }\n}\n\n                          \nexport interface IStateMachine extends IResource, iam.IGrantable {\n                                                             \n  readonly stateMachineArn: string;\n\n                                                                                                                                               \n  grantStartExecution(identity: iam.IGrantable): iam.Grant;\n\n                                                                                                                                                          \n  grantStartSyncExecution(identity: iam.IGrantable): iam.Grant;\n\n                                                                                                                         \n  grantRead(identity: iam.IGrantable): iam.Grant;\n\n                                                                                                                         \n  grantTaskResponse(identity: iam.IGrantable): iam.Grant;\n\n                                                                                                                                                                                   \n  grantExecution(identity: iam.IGrantable, ...actions: string[]): iam.Grant;\n\n                                                                                                                                                    \n  grant(identity: iam.IGrantable, ...actions: string[]): iam.Grant;\n\n                                                                                                                          \n  metric(metricName: string, props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                        \n  metricFailed(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                              \n  metricThrottled(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                              \n  metricAborted(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                           \n  metricSucceeded(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                           \n  metricTimedOut(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                              \n  metricStarted(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n\n                                                                                                                                                               \n  metricTime(props?: cloudwatch.MetricOptions): cloudwatch.Metric;\n}\n"],
  "mappings": "6PAAA,WAAA,QAAA,wBACA,IAAA,QAAA,iBAEA,OAAA,QAAA,cAEA,cAAA,QAAA,iBACA,yCAAA,QAAA,4CACA,0BAAA,QAAA,6BAIA,GAAY,kBAAZ,AAAA,UAAY,kBAAgB,CAE1B,kBAAA,QAAA,UAGA,kBAAA,SAAA,aALU,iBAAA,QAAA,kBAAA,SAAA,iBAAgB,KAS5B,GAAY,UAAZ,AAAA,UAAY,UAAQ,CAElB,UAAA,IAAA,MAEA,UAAA,IAAA,MAEA,UAAA,MAAA,QAEA,UAAA,MAAA,UARU,SAAA,QAAA,UAAA,SAAA,SAAQ,KAkDpB,8BAAwC,QAAA,QAAQ,OAGhC,qBAAoB,MAAkB,GAAY,gBAAuB,CACrF,oBAAqB,iBAAgB,CAArC,aAAA,qBACkB,KAAA,gBAAkB,gBAClB,KAAA,eAAiB,GAAI,KAAI,iBAAiB,CAAE,SAAU,QAExE,MAAO,IAAI,QAAO,MAAO,IAWpB,oBAAoB,SAAwB,CACjD,MAAO,KAAI,MAAM,eAAe,CAC9B,QAAS,SACT,QAAS,CAAC,yBACV,aAAc,CAAC,KAAK,mBAKjB,wBAAwB,SAAwB,CACrD,MAAO,KAAI,MAAM,eAAe,CAC9B,QAAS,SACT,QAAS,CAAC,6BACV,aAAc,CAAC,KAAK,mBAKjB,UAAU,SAAwB,CACvC,WAAI,MAAM,eAAe,CACvB,QAAS,SACT,QAAS,CACP,wBACA,4BAEF,aAAc,CAAC,KAAK,mBAEtB,IAAI,MAAM,eAAe,CACvB,QAAS,SACT,QAAS,CACP,2BACA,0CACA,8BAEF,aAAc,CAAC,GAAG,KAAK,sBAElB,IAAI,MAAM,eAAe,CAC9B,QAAS,SACT,QAAS,CACP,wBACA,8BACA,2BAEF,aAAc,CAAC,OAKZ,kBAAkB,SAAwB,CAC/C,MAAO,KAAI,MAAM,eAAe,CAC9B,QAAS,SACT,QAAS,CACP,yBACA,yBACA,4BAEF,aAAc,CAAC,KAAK,mBAKjB,eAAe,YAA6B,QAAiB,CAClE,MAAO,KAAI,MAAM,eAAe,CAC9B,QAAS,SACT,QACA,aAAc,CAAC,GAAG,KAAK,sBAKpB,MAAM,YAA6B,QAAiB,CACzD,MAAO,KAAI,MAAM,eAAe,CAC9B,QAAS,SACT,QACA,aAAc,CAAC,KAAK,mBAMjB,OAAO,WAAoB,MAAgC,CAChE,MAAO,IAAI,YAAW,OAAO,CAC3B,UAAW,aACX,WACA,cAAe,CAAE,gBAAiB,KAAK,iBACvC,UAAW,SACR,QACF,SAAS,MAIP,aAAa,MAAgC,CAClD,MAAO,MAAK,aAAa,yCAAA,cAAc,oBAAqB,OAIvD,gBAAgB,MAAgC,CAErD,MAAO,MAAK,OAAO,qBAAsB,OAIpC,cAAc,MAAgC,CACnD,MAAO,MAAK,aAAa,yCAAA,cAAc,qBAAsB,OAIxD,gBAAgB,MAAgC,CACrD,MAAO,MAAK,aAAa,yCAAA,cAAc,uBAAwB,OAI1D,eAAe,MAAgC,CACpD,MAAO,MAAK,aAAa,yCAAA,cAAc,sBAAuB,OAIzD,cAAc,MAAgC,CACnD,MAAO,MAAK,OAAO,oBAAqB,OAInC,WAAW,MAAgC,CAChD,MAAO,MAAK,aAAa,yCAAA,cAAc,qBAAsB,OAMvD,cAAY,CAClB,MAAO,QAAA,MAAM,GAAG,MAAM,UAAU,CAC9B,SAAU,YACV,QAAS,SACT,aAAc,OAAA,IAAI,MAAM,KAAK,gBAAiB,OAAA,UAAU,qBAAqB,aAC7E,UAAW,OAAA,UAAU,sBAIjB,aACN,GACA,MAAgC,CAChC,MAAO,IAAI,YAAW,OAAO,IACxB,GAAG,CAAE,gBAAiB,KAAK,qBAC3B,QACF,SAAS,OAKhB,0BAAkC,iBAAgB,CAahD,YAAY,MAAkB,GAAY,MAAwB,WAChE,MAAM,MAAO,GAAI,CACf,aAAc,MAAM,kGAGlB,MAAM,mBAAqB,QAC7B,KAAK,yBAAyB,MAAM,kBAGtC,KAAK,KAAO,MAAM,MAAQ,GAAI,KAAI,KAAK,KAAM,OAAQ,CACnD,UAAW,GAAI,KAAI,iBAAiB,0BAGtC,KAAM,OAAQ,GAAI,eAAA,WAAW,MAAM,WAAW,WAAY,iBAAiB,iBAC3E,MAAM,QAAU,MAAM,QAEtB,KAAK,iBAAgB,IAAG,MAAM,oBAAgB,MAAA,KAAA,OAAA,GAAI,iBAAiB,SAEnE,KAAM,UAAW,GAAI,2BAAA,gBAAgB,KAAM,WAAY,CACrD,iBAAkB,KAAK,aACvB,iBAAgB,IAAE,MAAM,oBAAgB,MAAA,KAAA,OAAA,GAAI,OAC5C,QAAS,KAAK,KAAK,QACnB,iBAAkB,OAAA,MAAM,GAAG,MAAM,aAAa,MAAM,eACpD,qBAAsB,MAAM,KAAO,KAAK,0BAA0B,MAAM,MAAQ,OAChF,qBAAsB,MAAM,eAAiB,KAAK,4BAA8B,SAGlF,SAAS,KAAK,cAAc,KAAK,MAEjC,SAAW,aAAa,OAAM,iBAC5B,KAAK,gBAAgB,WAGvB,KAAK,iBAAmB,KAAK,yBAAyB,SAAS,UAC/D,KAAK,gBAAkB,KAAK,wBAAwB,SAAS,IAAK,CAChE,QAAS,SACT,SAAU,eACV,aAAc,KAAK,aACnB,UAAW,OAAA,UAAU,yBAKd,iBAAc,CACvB,MAAO,MAAK,KAAK,eAIZ,gBAAgB,UAA8B,wEACnD,KAAK,KAAK,qBAAqB,WAGzB,yBAAyB,iBAAwB,CACvD,GAAI,CAAC,OAAA,MAAM,aAAa,kBAAmB,CACzC,GAAI,iBAAiB,OAAS,GAAK,iBAAiB,OAAS,GAC3D,KAAM,IAAI,OAAM,qEAAqE,oBAGvF,GAAI,CAAC,iBAAiB,MAAM,oCAC1B,KAAM,IAAI,OAAM,sEAAsE,qBAKpF,0BAA0B,WAAsB,CAEtD,YAAK,gBAAgB,GAAI,KAAI,gBAAgB,CAC3C,OAAQ,IAAI,OAAO,MACnB,QAAS,CACP,yBACA,sBACA,yBACA,yBACA,yBACA,yBACA,gCACA,0BAEF,UAAW,CAAC,QAGP,CACL,aAAc,CAAC,CACb,uBAAwB,CAAE,YAAa,WAAW,YAAY,eAEhE,qBAAsB,WAAW,qBACjC,MAAO,WAAW,OAAS,SAIvB,2BAAyB,CAC/B,YAAK,gBAAgB,GAAI,KAAI,gBAAgB,CAG3C,QAAS,CACP,wBACA,2BACA,wBACA,2BAEF,UAAW,CAAC,QAGP,CACL,QAAS,KArHf,QAAA,aAAA",
  "names": []
}
