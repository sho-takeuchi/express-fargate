{
  "version": 3,
  "sources": ["state.ts"],
  "sourcesContent": ["import { IConstruct, Construct, Node } from 'constructs';\nimport { Condition } from '../condition';\nimport { FieldUtils, JsonPath } from '../fields';\nimport { StateGraph } from '../state-graph';\nimport { CatchProps, Errors, IChainable, INextable, RetryProps } from '../types';\n\n                                          \nexport interface StateProps {\n                                                                              \n  readonly comment?: string;\n\n                                                                                                                                                                                                                                                   \n  readonly inputPath?: string;\n\n                                                                                                                                                                                                                                                                                                               \n  readonly parameters?: { [name: string]: any };\n\n                                                                                                                                                                                                                                                     \n  readonly outputPath?: string;\n\n                                                                                                                                                                                                                                \n  readonly resultPath?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                          \n  readonly resultSelector?: { [key: string]: any };\n}\n\n                                                 \nexport abstract class State extends Construct implements IChainable {\n                                                                                    \n  public static prefixStates(root: IConstruct, prefix: string) {\n    const queue = [root];\n    while (queue.length > 0) {\n      const el = queue.splice(0, 1)[0]!;\n      if (isPrefixable(el)) {\n        el.addPrefix(prefix);\n      }\n      queue.push(...Node.of(el).children);\n    }\n  }\n\n                                                                                                                                                                                                             \n  public static findReachableStates(start: State, options: FindStateOptions = {}): State[] {\n    const visited = new Set<State>();\n    const ret = new Set<State>();\n    const queue = [start];\n    while (queue.length > 0) {\n      const state = queue.splice(0, 1)[0]!;\n      if (visited.has(state)) { continue; }\n      visited.add(state);\n      const outgoing = state.outgoingTransitions(options);\n      queue.push(...outgoing);\n      ret.add(state);\n    }\n    return Array.from(ret);\n  }\n\n                                                                                                           \n  public static findReachableEndStates(start: State, options: FindStateOptions = {}): State[] {\n    const visited = new Set<State>();\n    const ret = new Set<State>();\n    const queue = [start];\n    while (queue.length > 0) {\n      const state = queue.splice(0, 1)[0]!;\n      if (visited.has(state)) { continue; }\n      visited.add(state);\n\n      const outgoing = state.outgoingTransitions(options);\n\n      if (outgoing.length > 0) {\n        // We can continue\n        queue.push(...outgoing);\n      } else {\n        // Terminal state\n        ret.add(state);\n      }\n    }\n    return Array.from(ret);\n  }\n\n                                                                                   \n  public static filterNextables(states: State[]): INextable[] {\n    return states.filter(isNextable) as any;\n  }\n\n                                              \n  public readonly startState: State;\n\n                                                     \n  public abstract readonly endStates: INextable[];\n\n  // This class has a superset of most of the features of the other states,\n  // and the subclasses decide which part of the features to expose. Most\n  // features are shared by a couple of states, and it becomes cumbersome to\n  // slice it out across all states. This is not great design, but it is\n  // pragmatic!\n  protected readonly comment?: string;\n  protected readonly inputPath?: string;\n  protected readonly parameters?: object;\n  protected readonly outputPath?: string;\n  protected readonly resultPath?: string;\n  protected readonly resultSelector?: object;\n  protected readonly branches: StateGraph[] = [];\n  protected iteration?: StateGraph;\n  protected defaultChoice?: State;\n\n  /**\n   * @internal\n   */\n  protected _next?: State;\n\n  private readonly retries: RetryProps[] = [];\n  private readonly catches: CatchTransition[] = [];\n  private readonly choices: ChoiceTransition[] = [];\n  private readonly prefixes: string[] = [];\n\n  /**\n   * The graph that this state is part of.\n   *\n   * Used for guaranteeing consistency between graphs and graph components.\n   */\n  private containingGraph?: StateGraph;\n\n  /**\n   * States with references to this state.\n   *\n   * Used for finding complete connected graph that a state is part of.\n   */\n  private readonly incomingStates: State[] = [];\n\n  constructor(scope: Construct, id: string, props: StateProps) {\n    super(scope, id);\n\n    this.startState = this;\n\n    this.comment = props.comment;\n    this.inputPath = props.inputPath;\n    this.parameters = props.parameters;\n    this.outputPath = props.outputPath;\n    this.resultPath = props.resultPath;\n    this.resultSelector = props.resultSelector;\n\n    this.node.addValidation({ validate: () => this.validateState() });\n  }\n\n                                                     \n  protected validateState(): string[] {\n    return [];\n  }\n\n  public get id() {\n    return this.node.id;\n  }\n\n                                                                  \n  public get stateId(): string {\n    return this.prefixes.concat(this.id).join('');\n  }\n\n                                                          \n  public addPrefix(x: string) {\n    if (x !== '') {\n      this.prefixes.splice(0, 0, x);\n    }\n  }\n\n                                                                                                                                                                   \n  public bindToGraph(graph: StateGraph) {\n    if (this.containingGraph === graph) { return; }\n\n    if (this.containingGraph) {\n      // eslint-disable-next-line max-len\n      throw new Error(`Trying to use state '${this.stateId}' in ${graph}, but is already in ${this.containingGraph}. Every state can only be used in one graph.`);\n    }\n\n    this.containingGraph = graph;\n    this.whenBoundToGraph(graph);\n\n    for (const incoming of this.incomingStates) {\n      incoming.bindToGraph(graph);\n    }\n    for (const outgoing of this.outgoingTransitions({ includeErrorHandlers: true })) {\n      outgoing.bindToGraph(graph);\n    }\n    for (const branch of this.branches) {\n      branch.registerSuperGraph(this.containingGraph);\n    }\n    if (!!this.iteration) {\n      this.iteration.registerSuperGraph(this.containingGraph);\n    }\n  }\n\n                                         \n  public abstract toStateJson(): object;\n\n  /**\n   * Add a retrier to the retry list of this state\n   * @internal\n   */\n  protected _addRetry(props: RetryProps = {}) {\n    validateErrors(props.errors);\n\n    this.retries.push({\n      ...props,\n      errors: props.errors ?? [Errors.ALL],\n    });\n  }\n\n  /**\n   * Add an error handler to the catch list of this state\n   * @internal\n   */\n  protected _addCatch(handler: State, props: CatchProps = {}) {\n    validateErrors(props.errors);\n\n    this.catches.push({\n      next: handler,\n      props: {\n        errors: props.errors ?? [Errors.ALL],\n        resultPath: props.resultPath,\n      },\n    });\n    handler.addIncoming(this);\n    if (this.containingGraph) {\n      handler.bindToGraph(this.containingGraph);\n    }\n  }\n\n                                                                              \n  protected makeNext(next: State) {\n    // Can't be called 'setNext' because of JSII\n    if (this._next) {\n      throw new Error(`State '${this.id}' already has a next state`);\n    }\n    this._next = next;\n    next.addIncoming(this);\n    if (this.containingGraph) {\n      next.bindToGraph(this.containingGraph);\n    }\n  }\n\n                                                  \n  protected addChoice(condition: Condition, next: State) {\n    this.choices.push({ condition, next });\n    next.startState.addIncoming(this);\n    if (this.containingGraph) {\n      next.startState.bindToGraph(this.containingGraph);\n    }\n  }\n\n                                                   \n  protected addBranch(branch: StateGraph) {\n    this.branches.push(branch);\n    if (this.containingGraph) {\n      branch.registerSuperGraph(this.containingGraph);\n    }\n  }\n\n                                                 \n  protected addIterator(iteration: StateGraph) {\n    this.iteration = iteration;\n    if (this.containingGraph) {\n      iteration.registerSuperGraph(this.containingGraph);\n    }\n  }\n\n                                                                                     \n  protected makeDefault(def: State) {\n    // Can't be called 'setDefault' because of JSII\n    if (this.defaultChoice) {\n      throw new Error(`Choice '${this.id}' already has a default next state`);\n    }\n    this.defaultChoice = def;\n  }\n\n                                                                 \n  protected renderNextEnd(): any {\n    if (this._next) {\n      return { Next: this._next.stateId };\n    } else {\n      return { End: true };\n    }\n  }\n\n                                                      \n  protected renderChoices(): any {\n    return {\n      Choices: renderList(this.choices, renderChoice),\n      Default: this.defaultChoice?.stateId,\n    };\n  }\n\n                                                                          \n  protected renderInputOutput(): any {\n    return {\n      InputPath: renderJsonPath(this.inputPath),\n      Parameters: this.parameters,\n      OutputPath: renderJsonPath(this.outputPath),\n    };\n  }\n\n                                                            \n  protected renderBranches(): any {\n    return {\n      Branches: this.branches.map(b => b.toGraphJson()),\n    };\n  }\n\n                                                       \n  protected renderIterator(): any {\n    if (!this.iteration) {\n      throw new Error('Iterator must not be undefined !');\n    }\n    return {\n      Iterator: this.iteration.toGraphJson(),\n    };\n  }\n\n                                                                 \n  protected renderRetryCatch(): any {\n    return {\n      Retry: renderList(this.retries, renderRetry, (a, b) => compareErrors(a.errors, b.errors)),\n      Catch: renderList(this.catches, renderCatch, (a, b) => compareErrors(a.props.errors, b.props.errors)),\n    };\n  }\n\n                                                         \n  protected renderResultSelector(): any {\n    return FieldUtils.renderObject({\n      ResultSelector: this.resultSelector,\n    });\n  }\n\n                                                                                                          \n  protected whenBoundToGraph(graph: StateGraph) {\n    graph.registerState(this);\n  }\n\n  /**\n   * Add a state to the incoming list\n   */\n  private addIncoming(source: State) {\n    this.incomingStates.push(source);\n  }\n\n  /**\n   * Return all states this state can transition to\n   */\n  private outgoingTransitions(options: FindStateOptions): State[] {\n    const ret = new Array<State>();\n    if (this._next) { ret.push(this._next); }\n    if (this.defaultChoice) { ret.push(this.defaultChoice); }\n    for (const c of this.choices) {\n      ret.push(c.next);\n    }\n    if (options.includeErrorHandlers) {\n      for (const c of this.catches) {\n        ret.push(c.next);\n      }\n    }\n    return ret;\n  }\n}\n\n                                               \nexport interface FindStateOptions {\n                                                                                             \n  readonly includeErrorHandlers?: boolean;\n}\n\n/**\n * A Choice Transition\n */\ninterface ChoiceTransition {\n  /**\n   * State to transition to\n   */\n  next: State;\n\n  /**\n   * Condition for this transition\n   */\n  condition: Condition;\n}\n\n/**\n * Render a choice transition\n */\nfunction renderChoice(c: ChoiceTransition) {\n  return {\n    ...c.condition.renderCondition(),\n    Next: c.next.stateId,\n  };\n}\n\n/**\n * A Catch Transition\n */\ninterface CatchTransition {\n  /**\n   * State to transition to\n   */\n  next: State;\n\n  /**\n   * Additional properties for this transition\n   */\n  props: CatchProps;\n}\n\n/**\n * Render a Retry object to ASL\n */\nfunction renderRetry(retry: RetryProps) {\n  return {\n    ErrorEquals: retry.errors,\n    IntervalSeconds: retry.interval && retry.interval.toSeconds(),\n    MaxAttempts: retry.maxAttempts,\n    BackoffRate: retry.backoffRate,\n  };\n}\n\n/**\n * Render a Catch object to ASL\n */\nfunction renderCatch(c: CatchTransition) {\n  return {\n    ErrorEquals: c.props.errors,\n    ResultPath: renderJsonPath(c.props.resultPath),\n    Next: c.next.stateId,\n  };\n}\n\n/**\n * Compares a list of Errors to move Errors.ALL last in a sort function\n */\nfunction compareErrors(a?: string[], b?: string[]) {\n  if (a?.includes(Errors.ALL)) {\n    return 1;\n  }\n  if (b?.includes(Errors.ALL)) {\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * Validates an errors list\n */\nfunction validateErrors(errors?: string[]) {\n  if (errors?.includes(Errors.ALL) && errors.length > 1) {\n    throw new Error(`${Errors.ALL} must appear alone in an error list`);\n  }\n}\n\n/**\n * Render a list or return undefined for an empty list\n */\nexport function renderList<T>(xs: T[], mapFn: (x: T) => any, sortFn?: (a: T, b: T) => number): any {\n  if (xs.length === 0) { return undefined; }\n  let list = xs;\n  if (sortFn) {\n    list = xs.sort(sortFn);\n  }\n  return list.map(mapFn);\n}\n\n/**\n * Render JSON path, respecting the special value DISCARD\n */\nexport function renderJsonPath(jsonPath?: string): undefined | null | string {\n  if (jsonPath === undefined) { return undefined; }\n  if (jsonPath === JsonPath.DISCARD) { return null; }\n\n  if (!jsonPath.startsWith('$')) {\n    throw new Error(`Expected JSON path to start with '$', got: ${jsonPath}`);\n  }\n  return jsonPath;\n}\n\n/**\n * Interface for structural feature testing (to make TypeScript happy)\n */\ninterface Prefixable {\n  addPrefix(x: string): void;\n}\n\n/**\n * Whether an object is a Prefixable\n */\nfunction isPrefixable(x: any): x is Prefixable {\n  return typeof(x) === 'object' && x.addPrefix;\n}\n\n/**\n * Whether an object is INextable\n */\nfunction isNextable(x: any): x is INextable {\n  return typeof(x) === 'object' && x.next;\n}\n"],
  "mappings": "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",
  "names": []
}
