{
  "version": 3,
  "sources": ["intrinsic.ts"],
  "sourcesContent": ["import { IResolvable, IResolveContext } from '../resolvable';\nimport { captureStackTrace } from '../stack-trace';\nimport { Token } from '../token';\n\n                                                             \nexport interface IntrinsicProps {\n                                                                                               \n  readonly stackTrace?: boolean;\n}\n\n                                                                                                                                                                                                                                                                                                                                           \nexport class Intrinsic implements IResolvable {\n                                                                                                        \n  public readonly creationStack: string[];\n\n  private readonly value: any;\n\n  constructor(value: any, options: IntrinsicProps = {}) {\n    if (isFunction(value)) {\n      throw new Error(`Argument to Intrinsic must be a plain value object, got ${value}`);\n    }\n\n    this.creationStack = options.stackTrace ?? true ? captureStackTrace() : [];\n    this.value = value;\n  }\n\n  public resolve(_context: IResolveContext) {\n    return this.value;\n  }\n\n                                                                                                                                                                                                                                           \n  public toString(): string {\n    return Token.asString(this);\n  }\n\n                                                                                                                     \n  public toJSON(): any {\n    // We can't do the right work here because in case we contain a function, we\n    // won't know the type of value that function represents (in the simplest\n    // case, string or number), and we can't know that without an\n    // IResolveContext to actually do the resolution, which we don't have.\n\n    // We used to throw an error, but since JSON.stringify() is often used in\n    // error messages to produce a readable representation of an object, if we\n    // throw here we'll obfuscate that descriptive error with something worse.\n    // So return a string representation that indicates this thing is a token\n    // and needs resolving.\n    return '<unresolved-token>';\n  }\n\n                                                                                                                                 \n  protected newError(message: string): any {\n    return new Error(`${message}\\nToken created:\\n    at ${this.creationStack.join('\\n    at ')}\\nError thrown:`);\n  }\n}\n\nfunction isFunction(x: any) {\n  return typeof x === 'function';\n}\n"],
  "mappings": "mNACA,cAAA,QAAA,kBACA,QAAA,QAAA,YASA,eAAsB,CAMpB,YAAY,MAAY,QAA0B,GAAE,QAClD,+DAAI,WAAW,OACb,KAAM,IAAI,OAAM,2DAA2D,SAG7E,KAAK,cAAgB,KAAA,QAAQ,cAAU,MAAA,KAAA,OAAA,GAAI,IAAO,cAAA,oBAAsB,GACxE,KAAK,MAAQ,MAGR,QAAQ,SAAyB,sEAC/B,KAAK,MAIP,UAAQ,CACb,MAAO,SAAA,MAAM,SAAS,MAIjB,QAAM,CAWX,MAAO,qBAIC,SAAS,QAAe,CAChC,MAAO,IAAI,OAAM,GAAG;;SAAmC,KAAK,cAAc,KAAK;;iBAzCnF,QAAA,UAAA,6FA6CA,oBAAoB,EAAM,CACxB,MAAO,OAAO,IAAM",
  "names": []
}
