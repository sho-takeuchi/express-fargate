{
  "version": 3,
  "sources": ["resolvable.ts"],
  "sourcesContent": ["import { IConstruct } from 'constructs';\nimport { TokenString } from './private/encoding';\nimport { TokenMap } from './private/token-map';\nimport { TokenizedStringFragments } from './string-fragments';\n\n                                                \nexport interface IResolveContext {\n                                                                   \n  readonly scope: IConstruct;\n\n                                                                                            \n  readonly preparing: boolean;\n\n                                        \n  resolve(x: any, options?: ResolveChangeContextOptions): any;\n\n                                                                                          \n  registerPostProcessor(postProcessor: IPostProcessor): void;\n}\n\n                                                                      \nexport interface ResolveChangeContextOptions {\n                                                                                      \n  readonly allowIntrinsicKeys?: boolean;\n}\n\n                                                                                                                            \nexport interface IResolvable {\n                                                                                                                                                                                                                                                                                            \n  readonly creationStack: string[];\n\n                                                             \n  resolve(context: IResolveContext): any;\n\n                                                                                                                                \n  toString(): string;\n}\n\n                                                                                                          \nexport interface IPostProcessor {\n                                                                                                    \n  postProcess(input: any, context: IResolveContext): any;\n}\n\n                                \nexport interface ITokenResolver {\n                                       \n  resolveToken(t: IResolvable, context: IResolveContext, postProcessor: IPostProcessor): any;\n\n                                                                                                             \n  resolveString(s: TokenizedStringFragments, context: IResolveContext): any;\n\n                                         \n  resolveList(l: string[], context: IResolveContext): any;\n}\n\n                                                                                                                                                \nexport interface IFragmentConcatenator {\n                                                               \n  join(left: any | undefined, right: any | undefined): any;\n}\n\n                                                                                        \nexport class StringConcat implements IFragmentConcatenator {\n  public join(left: any | undefined, right: any | undefined): any {\n    if (left === undefined) { return right !== undefined ? `${right}` : undefined; }\n    if (right === undefined) { return `${left}`; }\n    return `${left}${right}`;\n  }\n}\n\n                                             \nexport class DefaultTokenResolver implements ITokenResolver {\n  constructor(private readonly concat: IFragmentConcatenator) {\n  }\n\n                                                                                                                                           \n  public resolveToken(t: IResolvable, context: IResolveContext, postProcessor: IPostProcessor) {\n    try {\n      let resolved = t.resolve(context);\n\n      // The token might have returned more values that need resolving, recurse\n      resolved = context.resolve(resolved);\n      resolved = postProcessor.postProcess(resolved, context);\n      return resolved;\n    } catch (e) {\n      let message = `Resolution error: ${e.message}.`;\n      if (t.creationStack && t.creationStack.length > 0) {\n        message += `\\nObject creation stack:\\n  at ${t.creationStack.join('\\n  at ')}`;\n      }\n\n      e.message = message;\n      throw e;\n    }\n  }\n\n                                                   \n  public resolveString(fragments: TokenizedStringFragments, context: IResolveContext) {\n    return fragments.mapTokens({ mapToken: context.resolve }).join(this.concat);\n  }\n\n  public resolveList(xs: string[], context: IResolveContext) {\n    // Must be a singleton list token, because concatenation is not allowed.\n    if (xs.length !== 1) {\n      throw new Error(`Cannot add elements to list token, got: ${xs}`);\n    }\n\n    const str = TokenString.forListToken(xs[0]);\n    const tokenMap = TokenMap.instance();\n    const fragments = str.split(tokenMap.lookupToken.bind(tokenMap));\n    if (fragments.length !== 1) {\n      throw new Error(`Cannot concatenate strings in a tokenized string array, got: ${xs[0]}`);\n    }\n\n    return fragments.mapTokens({ mapToken: context.resolve }).firstValue;\n  }\n}\n"],
  "mappings": "mPACA,WAAA,QAAA,sBACA,YAAA,QAAA,uBA6DA,kBAAyB,CAChB,KAAK,KAAuB,MAAsB,CACvD,MAAI,QAAS,OAAoB,QAAU,OAAY,GAAG,QAAU,OAChE,QAAU,OAAoB,GAAG,OAC9B,GAAG,OAAO,SAJrB,QAAA,aAAA,sGASA,0BAAiC,CAC/B,YAA6B,OAA6B,CAA7B,KAAA,OAAA,yEAItB,aAAa,EAAgB,QAA0B,cAA6B,mLACzF,GAAI,CACF,GAAI,UAAW,EAAE,QAAQ,SAGzB,gBAAW,QAAQ,QAAQ,UAC3B,SAAW,cAAc,YAAY,SAAU,SACxC,eACA,EAAP,CACA,GAAI,SAAU,qBAAqB,EAAE,WACrC,KAAI,GAAE,eAAiB,EAAE,cAAc,OAAS,GAC9C,UAAW;;OAAkC,EAAE,cAAc,KAAK;WAGpE,EAAE,QAAU,QACN,GAKH,cAAc,UAAqC,QAAwB,6IACzE,UAAU,UAAU,CAAE,SAAU,QAAQ,UAAW,KAAK,KAAK,QAG/D,YAAY,GAAc,QAAwB,CAEvD,gEAAI,GAAG,SAAW,EAChB,KAAM,IAAI,OAAM,2CAA2C,MAG7D,KAAM,KAAM,WAAA,YAAY,aAAa,GAAG,IAClC,SAAW,YAAA,SAAS,WACpB,UAAY,IAAI,MAAM,SAAS,YAAY,KAAK,WACtD,GAAI,UAAU,SAAW,EACvB,KAAM,IAAI,OAAM,gEAAgE,GAAG,MAGrF,MAAO,WAAU,UAAU,CAAE,SAAU,QAAQ,UAAW,YA1C9D,QAAA,qBAAA",
  "names": []
}
