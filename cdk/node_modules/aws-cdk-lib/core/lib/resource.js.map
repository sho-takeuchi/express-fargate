{
  "version": 3,
  "sources": ["resource.ts"],
  "sourcesContent": ["import { ArnComponents, ArnFormat } from './arn';\nimport { CfnResource } from './cfn-resource';\nimport { IStringProducer, Lazy } from './lazy';\nimport { generatePhysicalName, isGeneratedWhenNeededMarker } from './private/physical-name-generator';\nimport { Reference } from './reference';\nimport { RemovalPolicy } from './removal-policy';\nimport { IResolveContext } from './resolvable';\nimport { Stack } from './stack';\nimport { Token, Tokenization } from './token';\n\n// v2 - leave this as a separate section so it reduces merge conflicts when compat is removed\n// eslint-disable-next-line import/order\nimport { Construct, IConstruct } from 'constructs';\n\nconst RESOURCE_SYMBOL = Symbol.for('@aws-cdk/core.Resource');\n\n                                                                                                                                    \nexport interface ResourceEnvironment {\n                                                                                                                                                                                                                                                                                         \n  readonly account: string;\n\n                                                                                                                                                                                                                                                                                 \n  readonly region: string;\n}\n\n                                                \nexport interface IResource extends IConstruct {\n                                                             \n  readonly stack: Stack;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  readonly env: ResourceEnvironment;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  applyRemovalPolicy(policy: RemovalPolicy): void;\n}\n\n                                                        \nexport interface ResourceProps {\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n  readonly physicalName?: string;\n\n                                                                                                                                                 \n  readonly account?: string;\n\n                                                                                                                                            \n  readonly region?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                    \n  readonly environmentFromArn?: string;\n}\n\n                                                        \nexport abstract class Resource extends Construct implements IResource {\n                                                                \n  public static isResource(construct: IConstruct): construct is CfnResource {\n    return construct !== null && typeof(construct) === 'object' && RESOURCE_SYMBOL in construct;\n  }\n\n  public readonly stack: Stack;\n  public readonly env: ResourceEnvironment;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                \n  protected readonly physicalName: string;\n\n  private _physicalName: string | undefined;\n  private readonly _allowCrossEnvironment: boolean;\n\n  constructor(scope: Construct, id: string, props: ResourceProps = {}) {\n    super(scope, id);\n\n    if ((props.account !== undefined || props.region !== undefined) && props.environmentFromArn !== undefined) {\n      throw new Error(`Supply at most one of 'account'/'region' (${props.account}/${props.region}) and 'environmentFromArn' (${props.environmentFromArn})`);\n    }\n\n    Object.defineProperty(this, RESOURCE_SYMBOL, { value: true });\n\n    this.stack = Stack.of(this);\n\n    const parsedArn = props.environmentFromArn ?\n      // Since we only want the region and account, NO_RESOURE_NAME is good enough\n      this.stack.splitArn(props.environmentFromArn, ArnFormat.NO_RESOURCE_NAME)\n      : undefined;\n    this.env = {\n      account: props.account ?? parsedArn?.account ?? this.stack.account,\n      region: props.region ?? parsedArn?.region ?? this.stack.region,\n    };\n\n    let physicalName = props.physicalName;\n\n    if (props.physicalName && isGeneratedWhenNeededMarker(props.physicalName)) {\n      // auto-generate only if cross-env is required\n      this._physicalName = undefined;\n      this._allowCrossEnvironment = true;\n      physicalName = Lazy.string({ produce: () => this._physicalName });\n    } else if (props.physicalName && !Token.isUnresolved(props.physicalName)) {\n      // concrete value specified by the user\n      this._physicalName = props.physicalName;\n      this._allowCrossEnvironment = true;\n    } else {\n      // either undefined (deploy-time) or has tokens, which means we can't use for cross-env\n      this._physicalName = props.physicalName;\n      this._allowCrossEnvironment = false;\n    }\n\n    if (physicalName === undefined) {\n      physicalName = Token.asString(undefined);\n    }\n\n    this.physicalName = physicalName;\n  }\n\n  /**\n   * Called when this resource is referenced across environments\n   * (account/region) to order to request that a physical name will be generated\n   * for this resource during synthesis, so the resource can be referenced\n   * through it's absolute name/arn.\n   *\n   * @internal\n   */\n  public _enableCrossEnvironment(): void {\n    if (!this._allowCrossEnvironment) {\n      // error out - a deploy-time name cannot be used across environments\n      throw new Error(`Cannot use resource '${this.node.path}' in a cross-environment fashion, ` +\n        \"the resource's physical name must be explicit set or use `PhysicalName.GENERATE_IF_NEEDED`\");\n    }\n\n    if (!this._physicalName) {\n      this._physicalName = this.generatePhysicalName();\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  public applyRemovalPolicy(policy: RemovalPolicy) {\n    const child = this.node.defaultChild;\n    if (!child || !CfnResource.isCfnResource(child)) {\n      throw new Error('Cannot apply RemovalPolicy: no child or not a CfnResource. Apply the removal policy on the CfnResource directly.');\n    }\n    child.applyRemovalPolicy(policy);\n  }\n\n  protected generatePhysicalName(): string {\n    return generatePhysicalName(this);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  protected getResourceNameAttribute(nameAttr: string) {\n    return mimicReference(nameAttr, {\n      produce: (context: IResolveContext) => {\n        const consumingStack = Stack.of(context.scope);\n\n        if (this.stack.environment !== consumingStack.environment) {\n          this._enableCrossEnvironment();\n          return this.physicalName;\n        } else {\n          return nameAttr;\n        }\n      },\n    });\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  protected getResourceArnAttribute(arnAttr: string, arnComponents: ArnComponents) {\n    return mimicReference(arnAttr, {\n      produce: (context: IResolveContext) => {\n        const consumingStack = Stack.of(context.scope);\n        if (this.stack.environment !== consumingStack.environment) {\n          this._enableCrossEnvironment();\n          return this.stack.formatArn(arnComponents);\n        } else {\n          return arnAttr;\n        }\n      },\n    });\n  }\n}\n\n/**\n * Produce a Lazy that is also a Reference (if the base value is a Reference).\n *\n * If the given value is a Reference (or resolves to a Reference), return a new\n * Reference that mimics the same target and display name, but resolves using\n * the logic of the passed lazy.\n *\n * If the given value is NOT a Reference, just return a simple Lazy.\n */\nfunction mimicReference(refSource: any, producer: IStringProducer): string {\n  const reference = Tokenization.reverse(refSource, {\n    // If this is an ARN concatenation, just fail to extract a reference.\n    failConcat: false,\n  });\n  if (!Reference.isReference(reference)) {\n    return Lazy.uncachedString(producer);\n  }\n\n  return Token.asString(new class extends Reference {\n    resolve(context: IResolveContext) {\n      return producer.produce(context);\n    }\n  }(reference, reference.target, reference.displayName));\n}\n"],
  "mappings": "+MAAA,MAAA,QAAA,SACA,eAAA,QAAA,kBACA,OAAA,QAAA,UACA,0BAAA,QAAA,qCACA,YAAA,QAAA,eAGA,QAAA,QAAA,WACA,QAAA,QAAA,WAIA,aAAA,QAAA,cAEM,gBAAkB,OAAO,IAAI,0BAuCnC,sBAAuC,cAAA,SAAS,CAe9C,YAAY,MAAkB,GAAY,MAAuB,GAAE,iBACjE,MAAM,MAAO,IAEb,4DAAK,OAAM,UAAY,QAAa,MAAM,SAAW,SAAc,MAAM,qBAAuB,OAC9F,KAAM,IAAI,OAAM,6CAA6C,MAAM,WAAW,MAAM,qCAAqC,MAAM,uBAGjI,OAAO,eAAe,KAAM,gBAAiB,CAAE,MAAO,KAEtD,KAAK,MAAQ,QAAA,MAAM,GAAG,MAEtB,KAAM,WAAY,MAAM,mBAEtB,KAAK,MAAM,SAAS,MAAM,mBAAoB,MAAA,UAAU,kBACtD,OACJ,KAAK,IAAM,CACT,QAAO,IAAA,IAAE,MAAM,WAAO,MAAA,KAAA,OAAA,GAAI,WAAS,KAAA,OAAT,UAAW,WAAO,MAAA,KAAA,OAAA,GAAI,KAAK,MAAM,QAC3D,OAAM,IAAA,IAAE,MAAM,UAAM,MAAA,KAAA,OAAA,GAAI,WAAS,KAAA,OAAT,UAAW,UAAM,MAAA,KAAA,OAAA,GAAI,KAAK,MAAM,QAG1D,GAAI,cAAe,MAAM,aAEzB,AAAI,MAAM,cAAgB,0BAAA,4BAA4B,MAAM,cAE1D,MAAK,cAAgB,OACrB,KAAK,uBAAyB,GAC9B,aAAe,OAAA,KAAK,OAAO,CAAE,QAAS,IAAM,KAAK,iBAC5C,AAAI,MAAM,cAAgB,CAAC,QAAA,MAAM,aAAa,MAAM,cAEzD,MAAK,cAAgB,MAAM,aAC3B,KAAK,uBAAyB,IAG9B,MAAK,cAAgB,MAAM,aAC3B,KAAK,uBAAyB,IAG5B,eAAiB,QACnB,cAAe,QAAA,MAAM,SAAS,SAGhC,KAAK,aAAe,mBAtDR,YAAW,UAAqB,CAC5C,MAAO,aAAc,MAAQ,MAAO,YAAe,UAAY,kBAAmB,WAgE7E,yBAAuB,CAC5B,GAAI,CAAC,KAAK,uBAER,KAAM,IAAI,OAAM,wBAAwB,KAAK,KAAK,sIAIpD,AAAK,KAAK,eACR,MAAK,cAAgB,KAAK,wBAKvB,mBAAmB,OAAqB,2DAC7C,KAAM,OAAQ,KAAK,KAAK,aACxB,GAAI,CAAC,OAAS,CAAC,eAAA,YAAY,cAAc,OACvC,KAAM,IAAI,OAAM,oHAElB,MAAM,mBAAmB,QAGjB,sBAAoB,CAC5B,MAAO,2BAAA,qBAAqB,MAIpB,yBAAyB,SAAgB,CACjD,MAAO,gBAAe,SAAU,CAC9B,QAAS,AAAC,SAA4B,CACpC,KAAM,gBAAiB,QAAA,MAAM,GAAG,QAAQ,OAExC,MAAI,MAAK,MAAM,cAAgB,eAAe,YAC5C,MAAK,0BACE,KAAK,cAEL,YAOL,wBAAwB,QAAiB,cAA4B,yEACtE,eAAe,QAAS,CAC7B,QAAS,AAAC,SAA4B,CACpC,KAAM,gBAAiB,QAAA,MAAM,GAAG,QAAQ,OACxC,MAAI,MAAK,MAAM,cAAgB,eAAe,YAC5C,MAAK,0BACE,KAAK,MAAM,UAAU,gBAErB,YArHjB,QAAA,SAAA,0FAqIA,wBAAwB,UAAgB,SAAyB,CAC/D,KAAM,WAAY,QAAA,aAAa,QAAQ,UAAW,CAEhD,WAAY,KAEd,MAAK,aAAA,UAAU,YAAY,WAIpB,QAAA,MAAM,SAAS,GAAI,cAAc,aAAA,SAAS,CAC/C,QAAQ,QAAwB,CAC9B,MAAO,UAAS,QAAQ,WAE1B,UAAW,UAAU,OAAQ,UAAU,cAPhC,OAAA,KAAK,eAAe",
  "names": []
}
