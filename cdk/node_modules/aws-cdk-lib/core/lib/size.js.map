{
  "version": 3,
  "sources": ["size.ts"],
  "sourcesContent": ["import { Token } from './token';\n\n                                                                                                                                                                                                                                                                        \nexport class Size {\n                                                                                                                                                                                                      \n  public static kibibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Kibibytes);\n  }\n\n                                                                                                                                                                                                    \n  public static mebibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Mebibytes);\n  }\n\n                                                                                                                                                                                                    \n  public static gibibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Gibibytes);\n  }\n\n                                                                                                                                                                                                    \n  public static tebibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Tebibytes);\n  }\n\n                                                                                                                                       \n  public static pebibyte(amount: number): Size {\n    return Size.pebibytes(amount);\n  }\n\n                                                                                                                                                                                                    \n  public static pebibytes(amount: number): Size {\n    return new Size(amount, StorageUnit.Pebibytes);\n  }\n\n  private readonly amount: number;\n  private readonly unit: StorageUnit;\n\n  private constructor(amount: number, unit: StorageUnit) {\n    if (!Token.isUnresolved(amount) && amount < 0) {\n      throw new Error(`Storage amounts cannot be negative. Received: ${amount}`);\n    }\n    this.amount = amount;\n    this.unit = unit;\n  }\n\n                                                                                                                                                                                 \n  public toKibibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Kibibytes, opts);\n  }\n\n                                                                                                                                                                                 \n  public toMebibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Mebibytes, opts);\n  }\n\n                                                                                                                                                                                 \n  public toGibibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Gibibytes, opts);\n  }\n\n                                                                                                                                                                                 \n  public toTebibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Tebibytes, opts);\n  }\n\n                                                                                                                                                                                 \n  public toPebibytes(opts: SizeConversionOptions = {}): number {\n    return convert(this.amount, this.unit, StorageUnit.Pebibytes, opts);\n  }\n}\n\n                                                                      \nexport enum SizeRoundingBehavior {\n                                                             \n  FAIL,\n                                                                                              \n  FLOOR,\n                                                              \n  NONE,\n}\n\n                                                               \nexport interface SizeConversionOptions {\n                                                                                                                              \n  readonly rounding?: SizeRoundingBehavior;\n}\n\nclass StorageUnit {\n  public static readonly Kibibytes = new StorageUnit('kibibytes', 1);\n  public static readonly Mebibytes = new StorageUnit('mebibytes', 1024);\n  public static readonly Gibibytes = new StorageUnit('gibibytes', 1024 * 1024);\n  public static readonly Tebibytes = new StorageUnit('tebibytes', 1024 * 1024 * 1024);\n  public static readonly Pebibytes = new StorageUnit('pebibytes', 1024 * 1024 * 1024 * 1024);\n\n  private constructor(public readonly label: string, public readonly inKibiBytes: number) {\n    // MAX_SAFE_INTEGER is 2^53, so by representing storage in kibibytes,\n    // the highest storage we can represent is 8 exbibytes.\n  }\n\n  public toString() {\n    return this.label;\n  }\n}\n\nfunction convert(amount: number, fromUnit: StorageUnit, toUnit: StorageUnit, options: SizeConversionOptions = {}) {\n  const rounding = options.rounding ?? SizeRoundingBehavior.FAIL;\n  if (fromUnit.inKibiBytes === toUnit.inKibiBytes) { return amount; }\n  if (Token.isUnresolved(amount)) {\n    throw new Error(`Unable to perform time unit conversion on un-resolved token ${amount}.`);\n  }\n\n  const multiplier = fromUnit.inKibiBytes / toUnit.inKibiBytes;\n  const value = amount * multiplier;\n  switch (rounding) {\n    case SizeRoundingBehavior.NONE:\n      return value;\n    case SizeRoundingBehavior.FLOOR:\n      return Math.floor(value);\n    default:\n    case SizeRoundingBehavior.FAIL:\n      if (!Number.isInteger(value)) {\n        throw new Error(`'${amount} ${fromUnit}' cannot be converted into a whole number of ${toUnit}.`);\n      }\n      return value;\n  }\n}\n"],
  "mappings": "wOAAA,QAAA,QAAA,WAGA,UAAiB,CAkCf,YAAoB,OAAgB,KAAiB,CACnD,GAAI,CAAC,QAAA,MAAM,aAAa,SAAW,OAAS,EAC1C,KAAM,IAAI,OAAM,iDAAiD,UAEnE,KAAK,OAAS,OACd,KAAK,KAAO,WArCA,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,iBAIxB,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,iBAIxB,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,iBAIxB,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,iBAIxB,UAAS,OAAc,CACnC,MAAO,MAAK,UAAU,cAIV,WAAU,OAAc,CACpC,MAAO,IAAI,MAAK,OAAQ,YAAY,WAe/B,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,MAIzD,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,MAIzD,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,MAIzD,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,MAIzD,YAAY,KAA8B,GAAE,wEAC1C,QAAQ,KAAK,OAAQ,KAAK,KAAM,YAAY,UAAW,OAhElE,QAAA,KAAA,8EAqEA,GAAY,sBAAZ,AAAA,UAAY,sBAAoB,CAE9B,sBAAA,sBAAA,KAAA,GAAA,OAEA,sBAAA,sBAAA,MAAA,GAAA,QAEA,sBAAA,sBAAA,KAAA,GAAA,SANU,qBAAA,QAAA,sBAAA,SAAA,qBAAoB,KAehC,iBAAiB,CAOf,YAAoC,MAA+B,YAAmB,CAAlD,KAAA,MAAA,MAA+B,KAAA,YAAA,YAK5D,UAAQ,CACb,MAAO,MAAK,OAZS,YAAA,UAAY,GAAI,aAAY,YAAa,GACzC,YAAA,UAAY,GAAI,aAAY,YAAa,MACzC,YAAA,UAAY,GAAI,aAAY,YAAa,KAAO,MAChD,YAAA,UAAY,GAAI,aAAY,YAAa,KAAO,KAAO,MACvD,YAAA,UAAY,GAAI,aAAY,YAAa,KAAO,KAAO,KAAO,MAYvF,iBAAiB,OAAgB,SAAuB,OAAqB,QAAiC,GAAE,QAC9G,KAAM,UAAQ,IAAG,QAAQ,YAAQ,MAAA,KAAA,OAAA,GAAI,qBAAqB,KAC1D,GAAI,SAAS,cAAgB,OAAO,YAAe,MAAO,QAC1D,GAAI,QAAA,MAAM,aAAa,QACrB,KAAM,IAAI,OAAM,+DAA+D,WAGjF,KAAM,YAAa,SAAS,YAAc,OAAO,YAC3C,MAAQ,OAAS,WACvB,OAAQ,cACD,sBAAqB,KACxB,MAAO,WACJ,sBAAqB,MACxB,MAAO,MAAK,MAAM,mBAEf,sBAAqB,KACxB,GAAI,CAAC,OAAO,UAAU,OACpB,KAAM,IAAI,OAAM,IAAI,UAAU,wDAAwD,WAExF,MAAO",
  "names": []
}
