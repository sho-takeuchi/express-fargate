{
  "version": 3,
  "sources": ["_shared.ts"],
  "sourcesContent": ["import * as crypto from 'crypto';\nimport * as cxschema from '../../../cloud-assembly-schema';\nimport { Node, IConstruct } from 'constructs';\nimport { Stack } from '../stack';\nimport { ISynthesisSession } from './types';\n\n/**\n * Shared logic of writing stack artifact to the Cloud Assembly\n *\n * This logic is shared between StackSyntheses.\n *\n * It could have been a protected method on a base class, but it\n * uses `Partial<cxapi.AwsCloudFormationStackProperties>` in the\n * parameters (which is convenient so I can remain typesafe without\n * copy/pasting), and jsii will choke on this type.\n */\nexport function addStackArtifactToAssembly(\n  session: ISynthesisSession,\n  stack: Stack,\n  stackProps: Partial<cxschema.AwsCloudFormationStackProperties>,\n  additionalStackDependencies: string[]) {\n\n  // nested stack tags are applied at the AWS::CloudFormation::Stack resource\n  // level and are not needed in the cloud assembly.\n  if (stack.tags.hasTags()) {\n    stack.node.addMetadata(cxschema.ArtifactMetadataEntryType.STACK_TAGS, stack.tags.renderTags());\n  }\n\n  const deps = [\n    ...stack.dependencies.map(s => s.artifactId),\n    ...additionalStackDependencies,\n  ];\n  const meta = collectStackMetadata(stack);\n\n  // backwards compatibility since originally artifact ID was always equal to\n  // stack name the stackName attribute is optional and if it is not specified\n  // the CLI will use the artifact ID as the stack name. we *could have*\n  // always put the stack name here but wanted to minimize the risk around\n  // changes to the assembly manifest. so this means that as long as stack\n  // name and artifact ID are the same, the cloud assembly manifest will not\n  // change.\n  const stackNameProperty = stack.stackName === stack.artifactId\n    ? { }\n    : { stackName: stack.stackName };\n\n  const properties: cxschema.AwsCloudFormationStackProperties = {\n    templateFile: stack.templateFile,\n    terminationProtection: stack.terminationProtection,\n    tags: nonEmptyDict(stack.tags.tagValues()),\n    validateOnSynth: session.validateOnSynth,\n    ...stackProps,\n    ...stackNameProperty,\n  };\n\n  // add an artifact that represents this stack\n  session.assembly.addArtifact(stack.artifactId, {\n    type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,\n    environment: stack.environment,\n    properties,\n    dependencies: deps.length > 0 ? deps : undefined,\n    metadata: Object.keys(meta).length > 0 ? meta : undefined,\n    displayName: stack.node.path,\n  });\n}\n\n/**\n * Collect the metadata from a stack\n */\nfunction collectStackMetadata(stack: Stack) {\n  const output: { [id: string]: cxschema.MetadataEntry[] } = { };\n\n  visit(stack);\n\n  return output;\n\n  function visit(node: IConstruct) {\n    // break off if we reached a node that is not a child of this stack\n    const parent = findParentStack(node);\n    if (parent !== stack) {\n      return;\n    }\n\n    if (node.node.metadata.length > 0) {\n      // Make the path absolute\n      output[Node.PATH_SEP + node.node.path] = node.node.metadata.map(md => stack.resolve(md) as cxschema.MetadataEntry);\n    }\n\n    for (const child of node.node.children) {\n      visit(child);\n    }\n  }\n\n  function findParentStack(node: IConstruct): Stack | undefined {\n    if (node instanceof Stack && node.nestedStackParent === undefined) {\n      return node;\n    }\n\n    if (!node.node.scope) {\n      return undefined;\n    }\n\n    return findParentStack(node.node.scope);\n  }\n}\n\n/**\n * Hash a string\n */\nexport function contentHash(content: string) {\n  return crypto.createHash('sha256').update(content).digest('hex');\n}\n\n/**\n * Throw an error message about binding() if we don't have a value for x.\n *\n * This replaces the ! assertions we would need everywhere otherwise.\n */\nexport function assertBound<A>(x: A | undefined): asserts x is NonNullable<A> {\n  if (x === null && x === undefined) {\n    throw new Error('You must call bindStack() first');\n  }\n}\n\nfunction nonEmptyDict<A>(xs: Record<string, A>) {\n  return Object.keys(xs).length > 0 ? xs : undefined;\n}\n"],
  "mappings": "sJAAA,KAAA,QAAA,QAAA,UACA,SAAA,QAAA,kCACA,aAAA,QAAA,cACA,QAAA,QAAA,YAaA,oCACE,QACA,MACA,WACA,4BAAqC,CAIrC,AAAI,MAAM,KAAK,WACb,MAAM,KAAK,YAAY,SAAS,0BAA0B,WAAY,MAAM,KAAK,cAGnF,KAAM,MAAO,CACX,GAAG,MAAM,aAAa,IAAI,GAAK,EAAE,YACjC,GAAG,6BAEC,KAAO,qBAAqB,OAS5B,kBAAoB,MAAM,YAAc,MAAM,WAChD,GACA,CAAE,UAAW,MAAM,WAEjB,WAAwD,CAC5D,aAAc,MAAM,aACpB,sBAAuB,MAAM,sBAC7B,KAAM,aAAa,MAAM,KAAK,aAC9B,gBAAiB,QAAQ,mBACtB,cACA,mBAIL,QAAQ,SAAS,YAAY,MAAM,WAAY,CAC7C,KAAM,SAAS,aAAa,yBAC5B,YAAa,MAAM,YACnB,WACA,aAAc,KAAK,OAAS,EAAI,KAAO,OACvC,SAAU,OAAO,KAAK,MAAM,OAAS,EAAI,KAAO,OAChD,YAAa,MAAM,KAAK,OA7C5B,QAAA,2BAAA,2BAoDA,8BAA8B,MAAY,CACxC,KAAM,QAAqD,GAE3D,aAAM,OAEC,OAEP,eAAe,KAAgB,CAG7B,GAAI,AADW,gBAAgB,QAChB,MAIf,CAAI,KAAK,KAAK,SAAS,OAAS,GAE9B,QAAO,aAAA,KAAK,SAAW,KAAK,KAAK,MAAQ,KAAK,KAAK,SAAS,IAAI,IAAM,MAAM,QAAQ,MAGtF,SAAW,SAAS,MAAK,KAAK,SAC5B,MAAM,QAIV,yBAAyB,KAAgB,CACvC,GAAI,eAAgB,SAAA,OAAS,KAAK,oBAAsB,OACtD,MAAO,MAGT,GAAI,EAAC,KAAK,KAAK,MAIf,MAAO,iBAAgB,KAAK,KAAK,QAOrC,qBAA4B,QAAe,CACzC,MAAO,QAAO,WAAW,UAAU,OAAO,SAAS,OAAO,OAD5D,QAAA,YAAA,YASA,qBAA+B,EAAgB,CAC7C,GAAI,IAAM,MAAQ,IAAM,OACtB,KAAM,IAAI,OAAM,mCAFpB,QAAA,YAAA,YAMA,sBAAyB,GAAqB,CAC5C,MAAO,QAAO,KAAK,IAAI,OAAS,EAAI,GAAK",
  "names": []
}
