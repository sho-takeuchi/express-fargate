{
  "version": 3,
  "sources": ["stack.ts"],
  "sourcesContent": ["import * as fs from 'fs';\nimport * as path from 'path';\nimport * as cxschema from '../../cloud-assembly-schema';\nimport * as cxapi from '../../cx-api';\nimport { IConstruct, Construct, Node } from 'constructs';\nimport { Annotations } from './annotations';\nimport { App } from './app';\nimport { Arn, ArnComponents, ArnFormat } from './arn';\nimport { DockerImageAssetLocation, DockerImageAssetSource, FileAssetLocation, FileAssetSource } from './assets';\nimport { CfnElement } from './cfn-element';\nimport { Fn } from './cfn-fn';\nimport { Aws, ScopedAws } from './cfn-pseudo';\nimport { CfnResource, TagType } from './cfn-resource';\nimport { ContextProvider } from './context-provider';\nimport { Environment } from './environment';\nimport { FeatureFlags } from './feature-flags';\nimport { CLOUDFORMATION_TOKEN_RESOLVER, CloudFormationLang } from './private/cloudformation-lang';\nimport { LogicalIDs } from './private/logical-id';\nimport { resolve } from './private/resolve';\nimport { makeUniqueId } from './private/uniqueid';\n\nconst STACK_SYMBOL = Symbol.for('@aws-cdk/core.Stack');\nconst MY_STACK_CACHE = Symbol.for('@aws-cdk/core.Stack.myStack');\n\nexport const STACK_RESOURCE_LIMIT_CONTEXT = '@aws-cdk/core:stackResourceLimit';\n\nconst VALID_STACK_NAME_REGEX = /^[A-Za-z][A-Za-z0-9-]*$/;\n\nconst MAX_RESOURCES = 500;\n\nexport interface StackProps {\n                                                                                 \n  readonly description?: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  readonly env?: Environment;\n\n                                                                                                \n  readonly stackName?: string;\n\n                                                                                                                          \n  readonly tags?: { [key: string]: string };\n\n                                                                                                                                                                                                                              \n  readonly synthesizer?: IStackSynthesizer;\n\n                                                                                                  \n  readonly terminationProtection?: boolean;\n\n                                                                                                                                                                                                   \n  readonly analyticsReporting?: boolean;\n}\n\n                                                                           \nexport class Stack extends Construct implements ITaggable {\n                                                                                                                                          \n  public static isStack(x: any): x is Stack {\n    return x !== null && typeof(x) === 'object' && STACK_SYMBOL in x;\n  }\n\n                                                                                                                                                                                      \n  public static of(construct: IConstruct): Stack {\n    // we want this to be as cheap as possible. cache this result by mutating\n    // the object. anecdotally, at the time of this writing, @aws-cdk/core unit\n    // tests hit this cache 1,112 times, @aws-cdk/aws-cloudformation unit tests\n    // hit this 2,435 times).\n    const cache = (construct as any)[MY_STACK_CACHE] as Stack | undefined;\n    if (cache) {\n      return cache;\n    } else {\n      const value = _lookup(construct);\n      Object.defineProperty(construct, MY_STACK_CACHE, {\n        enumerable: false,\n        writable: false,\n        configurable: false,\n        value,\n      });\n      return value;\n    }\n\n    function _lookup(c: IConstruct): Stack {\n      if (Stack.isStack(c)) {\n        return c;\n      }\n\n      const _scope = Node.of(c).scope;\n      if (Stage.isStage(c) || !_scope) {\n        throw new Error(`${construct.constructor?.name ?? 'Construct'} at '${Node.of(construct).path}' should be created in the scope of a Stack, but no Stack found`);\n      }\n\n      return _lookup(_scope);\n    }\n  }\n\n                                                 \n  public readonly tags: TagManager;\n\n                                                                                            \n  public readonly templateOptions: ITemplateOptions;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  public readonly region: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 \n  public readonly account: string;\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n  public readonly environment: string;\n\n                                                                          \n  public readonly terminationProtection?: boolean;\n\n                                                                                                                                                               \n  public readonly nestedStackResource?: CfnResource;\n\n                                                                                                                                                                     \n  public readonly templateFile: string;\n\n                                                                      \n  public readonly artifactId: string;\n\n                                                     \n  public readonly synthesizer: IStackSynthesizer;\n\n  /**\n   * Whether version reporting is enabled for this stack\n   *\n   * Controls whether the CDK Metadata resource is injected\n   *\n   * @internal\n   */\n  public readonly _versionReportingEnabled: boolean;\n\n  /**\n   * Logical ID generation strategy\n   */\n  private readonly _logicalIds: LogicalIDs;\n\n  /**\n   * Other stacks this stack depends on\n   */\n  private readonly _stackDependencies: { [uniqueId: string]: StackDependency };\n\n  /**\n   * Lists all missing contextual information.\n   * This is returned when the stack is synthesized under the 'missing' attribute\n   * and allows tooling to obtain the context and re-synthesize.\n   */\n  private readonly _missingContext: cxschema.MissingContext[];\n\n  private readonly _stackName: string;\n\n                                                                                                                                                                                                                                                                                                                                                                         \n  public constructor(scope?: Construct, id?: string, props: StackProps = {}) {\n    // For unit test scope and id are optional for stacks, but we still want an App\n    // as the parent because apps implement much of the synthesis logic.\n    scope = scope ?? new App({\n      autoSynth: false,\n      outdir: FileSystem.mkdtemp('cdk-test-app-'),\n    });\n\n    // \"Default\" is a \"hidden id\" from a `node.uniqueId` perspective\n    id = id ?? 'Default';\n\n    super(scope, id);\n\n    this._missingContext = new Array<cxschema.MissingContext>();\n    this._stackDependencies = { };\n    this.templateOptions = { };\n\n    Object.defineProperty(this, STACK_SYMBOL, { value: true });\n\n    this._logicalIds = new LogicalIDs();\n\n    const { account, region, environment } = this.parseEnvironment(props.env);\n\n    this.account = account;\n    this.region = region;\n    this.environment = environment;\n    this.terminationProtection = props.terminationProtection;\n\n    if (props.description !== undefined) {\n      // Max length 1024 bytes\n      // Typically 2 bytes per character, may be more for more exotic characters\n      if (props.description.length > 512) {\n        throw new Error(`Stack description must be <= 1024 bytes. Received description: '${props.description}'`);\n      }\n      this.templateOptions.description = props.description;\n    }\n\n    this._stackName = props.stackName ?? this.generateStackName();\n    this.tags = new TagManager(TagType.KEY_VALUE, 'aws:cdk:stack', props.tags);\n\n    if (!VALID_STACK_NAME_REGEX.test(this.stackName)) {\n      throw new Error(`Stack name must match the regular expression: ${VALID_STACK_NAME_REGEX.toString()}, got '${this.stackName}'`);\n    }\n\n    // the preferred behavior is to generate a unique id for this stack and use\n    // it as the artifact ID in the assembly. this allows multiple stacks to use\n    // the same name. however, this behavior is breaking for 1.x so it's only\n    // applied under a feature flag which is applied automatically for new\n    // projects created using `cdk init`.\n    //\n    // Also use the new behavior if we are using the new CI/CD-ready synthesizer; that way\n    // people only have to flip one flag.\n    const featureFlags = FeatureFlags.of(this);\n    const stackNameDupeContext = featureFlags.isEnabled(cxapi.ENABLE_STACK_NAME_DUPLICATES_CONTEXT);\n    const newStyleSynthesisContext = featureFlags.isEnabled(cxapi.NEW_STYLE_STACK_SYNTHESIS_CONTEXT);\n    this.artifactId = (stackNameDupeContext || newStyleSynthesisContext)\n      ? this.generateStackArtifactId()\n      : this.stackName;\n\n    this.templateFile = `${this.artifactId}.template.json`;\n\n    // Not for nested stacks\n    this._versionReportingEnabled = (props.analyticsReporting ?? this.node.tryGetContext(cxapi.ANALYTICS_REPORTING_ENABLED_CONTEXT))\n      && !this.nestedStackParent;\n\n    this.synthesizer = props.synthesizer ?? (newStyleSynthesisContext\n      ? new DefaultStackSynthesizer()\n      : new LegacyStackSynthesizer());\n    this.synthesizer.bind(this);\n  }\n\n                                                                               \n  public resolve(obj: any): any {\n    return resolve(obj, {\n      scope: this,\n      prefix: [],\n      resolver: CLOUDFORMATION_TOKEN_RESOLVER,\n      preparing: false,\n    });\n  }\n\n                                                                                   \n  public toJsonString(obj: any, space?: number): string {\n    return CloudFormationLang.toJSON(obj, space).toString();\n  }\n\n                                                                            \n  public reportMissingContext(report: cxapi.MissingContext) {\n    if (!Object.values(cxschema.ContextProvider).includes(report.provider as cxschema.ContextProvider)) {\n      throw new Error(`Unknown context provider requested in: ${JSON.stringify(report)}`);\n    }\n    this.reportMissingContextKey(report as cxschema.MissingContext);\n  }\n\n                                                                                                                                                                                                                                                          \n  public reportMissingContextKey(report: cxschema.MissingContext) {\n    this._missingContext.push(report);\n  }\n\n                                                                                                                                                                                 \n  public renameLogicalId(oldId: string, newId: string) {\n    this._logicalIds.addRename(oldId, newId);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n  public getLogicalId(element: CfnElement): string {\n    const logicalId = this.allocateLogicalId(element);\n    return this._logicalIds.applyRename(logicalId);\n  }\n\n                                                                                                                                                                                                     \n  public addDependency(target: Stack, reason?: string) {\n    addDependency(this, target, reason);\n  }\n\n                                                        \n  public get dependencies(): Stack[] {\n    return Object.values(this._stackDependencies).map(x => x.stack);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  public get stackName(): string {\n    return this._stackName;\n  }\n\n                                                             \n  public get partition(): string {\n    // Always return a non-scoped partition intrinsic. These will usually\n    // be used to construct an ARN, but there are no cross-partition\n    // calls anyway.\n    return Aws.PARTITION;\n  }\n\n                                                                                       \n  public get urlSuffix(): string {\n    // Since URL Suffix always follows partition, it is unscoped like partition is.\n    return Aws.URL_SUFFIX;\n  }\n\n                                                                                                                                                                                                     \n  public get stackId(): string {\n    return new ScopedAws(this).stackId;\n  }\n\n                                                                                                     \n  public get notificationArns(): string[] {\n    return new ScopedAws(this).notificationArns;\n  }\n\n                                                                                                                          \n  public get nested(): boolean {\n    return this.nestedStackResource !== undefined;\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       \n  public formatArn(components: ArnComponents): string {\n    return Arn.format(components, this);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   \n  public parseArn(arn: string, sepIfToken: string = '/', hasName: boolean = true): ArnComponents {\n    return Arn.parse(arn, sepIfToken, hasName);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  public splitArn(arn: string, arnFormat: ArnFormat): ArnComponents {\n    return Arn.split(arn, arnFormat);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                \n  public get availabilityZones(): string[] {\n    // if account/region are tokens, we can't obtain AZs through the context\n    // provider, so we fallback to use Fn::GetAZs. the current lowest common\n    // denominator is 2 AZs across all AWS regions.\n    const agnostic = Token.isUnresolved(this.account) || Token.isUnresolved(this.region);\n    if (agnostic) {\n      return this.node.tryGetContext(cxapi.AVAILABILITY_ZONE_FALLBACK_CONTEXT_KEY) || [\n        Fn.select(0, Fn.getAzs()),\n        Fn.select(1, Fn.getAzs()),\n      ];\n    }\n\n    const value = ContextProvider.getValue(this, {\n      provider: cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER,\n      dummyValue: ['dummy1a', 'dummy1b', 'dummy1c'],\n    }).value;\n\n    if (!Array.isArray(value)) {\n      throw new Error(`Provider ${cxschema.ContextProvider.AVAILABILITY_ZONE_PROVIDER} expects a list`);\n    }\n\n    return value;\n  }\n\n                                                                                                                                                                                                           \n  public addFileAsset(asset: FileAssetSource): FileAssetLocation {\n    return this.synthesizer.addFileAsset(asset);\n  }\n\n                                                                                                                                                                                                                            \n  public addDockerImageAsset(asset: DockerImageAssetSource): DockerImageAssetLocation {\n    return this.synthesizer.addDockerImageAsset(asset);\n  }\n\n                                                                      \n  public get nestedStackParent() {\n    return this.nestedStackResource && Stack.of(this.nestedStackResource);\n  }\n\n                                                                                                    \n  public get parentStack() {\n    return this.nestedStackParent;\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n  public addTransform(transform: string) {\n    if (!this.templateOptions.transforms) {\n      this.templateOptions.transforms = [];\n    }\n    this.templateOptions.transforms.push(transform);\n  }\n\n  /**\n   * Called implicitly by the `addDependency` helper function in order to\n   * realize a dependency between two top-level stacks at the assembly level.\n   *\n   * Use `stack.addDependency` to define the dependency between any two stacks,\n   * and take into account nested stack relationships.\n   *\n   * @internal\n   */\n  public _addAssemblyDependency(target: Stack, reason?: string) {\n    // defensive: we should never get here for nested stacks\n    if (this.nested || target.nested) {\n      throw new Error('Cannot add assembly-level dependencies for nested stacks');\n    }\n\n    reason = reason || 'dependency added using stack.addDependency()';\n    const cycle = target.stackDependencyReasons(this);\n    if (cycle !== undefined) {\n      // eslint-disable-next-line max-len\n      throw new Error(`'${target.node.path}' depends on '${this.node.path}' (${cycle.join(', ')}). Adding this dependency (${reason}) would create a cyclic reference.`);\n    }\n\n    let dep = this._stackDependencies[Names.uniqueId(target)];\n    if (!dep) {\n      dep = this._stackDependencies[Names.uniqueId(target)] = {\n        stack: target,\n        reasons: [],\n      };\n    }\n\n    dep.reasons.push(reason);\n\n    if (process.env.CDK_DEBUG_DEPS) {\n      // eslint-disable-next-line no-console\n      console.error(`[CDK_DEBUG_DEPS] stack \"${this.node.path}\" depends on \"${target.node.path}\" because: ${reason}`);\n    }\n  }\n\n  /**\n   * Synthesizes the cloudformation template into a cloud assembly.\n   * @internal\n   */\n  public _synthesizeTemplate(session: ISynthesisSession, lookupRoleArn?: string): void {\n    // In principle, stack synthesis is delegated to the\n    // StackSynthesis object.\n    //\n    // However, some parts of synthesis currently use some private\n    // methods on Stack, and I don't really see the value in refactoring\n    // this right now, so some parts still happen here.\n    const builder = session.assembly;\n\n    const template = this._toCloudFormation();\n\n    // write the CloudFormation template as a JSON file\n    const outPath = path.join(builder.outdir, this.templateFile);\n\n    if (this.maxResources > 0) {\n      const resources = template.Resources || {};\n      const numberOfResources = Object.keys(resources).length;\n\n      if (numberOfResources > this.maxResources) {\n        throw new Error(`Number of resources in stack '${this.node.path}': ${numberOfResources} is greater than allowed maximum of ${this.maxResources}`);\n      } else if (numberOfResources >= (this.maxResources * 0.8)) {\n        Annotations.of(this).addInfo(`Number of resources: ${numberOfResources} is approaching allowed maximum of ${this.maxResources}`);\n      }\n    }\n    fs.writeFileSync(outPath, JSON.stringify(template, undefined, 2));\n\n    for (const ctx of this._missingContext) {\n      if (lookupRoleArn != null) {\n        builder.addMissing({ ...ctx, props: { ...ctx.props, lookupRoleArn } });\n      } else {\n        builder.addMissing(ctx);\n      }\n    }\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n  public regionalFact(factName: string, defaultValue?: string): string {\n    if (!Token.isUnresolved(this.region)) {\n      const ret = Fact.find(this.region, factName) ?? defaultValue;\n      if (ret === undefined) {\n        throw new Error(`region-info: don't know ${factName} for region ${this.region}. Use 'Fact.register' to provide this value.`);\n      }\n      return ret;\n    }\n\n    const partitions = Node.of(this).tryGetContext(cxapi.TARGET_PARTITIONS);\n    if (partitions !== undefined && !Array.isArray(partitions)) {\n      throw new Error(`Context value '${cxapi.TARGET_PARTITIONS}' should be a list of strings, got: ${JSON.stringify(cxapi.TARGET_PARTITIONS)}`);\n    }\n\n    const lookupMap = partitions ? RegionInfo.limitedRegionMap(factName, partitions) : RegionInfo.regionMap(factName);\n\n    return deployTimeLookup(this, factName, lookupMap, defaultValue);\n  }\n\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n  public exportValue(exportedValue: any, options: ExportValueOptions = {}) {\n    if (options.name) {\n      new CfnOutput(this, `Export${options.name}`, {\n        value: exportedValue,\n        exportName: options.name,\n      });\n      return Fn.importValue(options.name);\n    }\n\n    const resolvable = Tokenization.reverse(exportedValue);\n    if (!resolvable || !Reference.isReference(resolvable)) {\n      throw new Error('exportValue: either supply \\'name\\' or make sure to export a resource attribute (like \\'bucket.bucketName\\')');\n    }\n\n    // \"teleport\" the value here, in case it comes from a nested stack. This will also\n    // ensure the value is from our own scope.\n    const exportable = referenceNestedStackValueInParent(resolvable, this);\n\n    // Ensure a singleton \"Exports\" scoping Construct\n    // This mostly exists to trigger LogicalID munging, which would be\n    // disabled if we parented constructs directly under Stack.\n    // Also it nicely prevents likely construct name clashes\n    const exportsScope = getCreateExportsScope(this);\n\n    // Ensure a singleton CfnOutput for this value\n    const resolved = this.resolve(exportable);\n    const id = 'Output' + JSON.stringify(resolved);\n    const exportName = generateExportName(exportsScope, id);\n\n    if (Token.isUnresolved(exportName)) {\n      throw new Error(`unresolved token in generated export name: ${JSON.stringify(this.resolve(exportName))}`);\n    }\n\n    const output = exportsScope.node.tryFindChild(id) as CfnOutput;\n    if (!output) {\n      new CfnOutput(exportsScope, id, { value: Token.asString(exportable), exportName });\n    }\n\n    return Fn.importValue(exportName);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      \n  protected allocateLogicalId(cfnElement: CfnElement): string {\n    const scopes = cfnElement.node.scopes;\n    const stackIndex = scopes.indexOf(cfnElement.stack);\n    const pathComponents = scopes.slice(stackIndex + 1).map(x => x.node.id);\n    return makeUniqueId(pathComponents);\n  }\n\n  /**\n   * Validate stack name\n   *\n   * CloudFormation stack names can include dashes in addition to the regular identifier\n   * character classes, and we don't allow one of the magic markers.\n   *\n   * @internal\n   */\n  protected _validateId(name: string) {\n    if (name && !VALID_STACK_NAME_REGEX.test(name)) {\n      throw new Error(`Stack name must match the regular expression: ${VALID_STACK_NAME_REGEX.toString()}, got '${name}'`);\n    }\n  }\n\n  /**\n   * Returns the CloudFormation template for this stack by traversing\n   * the tree and invoking _toCloudFormation() on all Entity objects.\n   *\n   * @internal\n   */\n  protected _toCloudFormation() {\n    let transform: string | string[] | undefined;\n\n    if (this.templateOptions.transform) {\n      // eslint-disable-next-line max-len\n      Annotations.of(this).addWarning('This stack is using the deprecated `templateOptions.transform` property. Consider switching to `addTransform()`.');\n      this.addTransform(this.templateOptions.transform);\n    }\n\n    if (this.templateOptions.transforms) {\n      if (this.templateOptions.transforms.length === 1) { // Extract single value\n        transform = this.templateOptions.transforms[0];\n      } else { // Remove duplicate values\n        transform = Array.from(new Set(this.templateOptions.transforms));\n      }\n    }\n\n    const template: any = {\n      Description: this.templateOptions.description,\n      Transform: transform,\n      AWSTemplateFormatVersion: this.templateOptions.templateFormatVersion,\n      Metadata: this.templateOptions.metadata,\n    };\n\n    const elements = cfnElements(this);\n    const fragments = elements.map(e => this.resolve(e._toCloudFormation()));\n\n    // merge in all CloudFormation fragments collected from the tree\n    for (const fragment of fragments) {\n      merge(template, fragment);\n    }\n\n    // resolve all tokens and remove all empties\n    const ret = this.resolve(template) || {};\n\n    this._logicalIds.assertAllRenamesApplied();\n\n    return ret;\n  }\n\n                                                                                                                                                                                                                   \n  protected prepareCrossReference(_sourceStack: Stack, reference: Reference): IResolvable {\n    return reference;\n  }\n\n  /**\n   * Determine the various stack environment attributes.\n   *\n   */\n  private parseEnvironment(env: Environment = {}) {\n    // if an environment property is explicitly specified when the stack is\n    // created, it will be used. if not, use tokens for account and region.\n    //\n    // (They do not need to be anchored to any construct like resource attributes\n    // are, because we'll never Export/Fn::ImportValue them -- the only situation\n    // in which Export/Fn::ImportValue would work is if the value are the same\n    // between producer and consumer anyway, so we can just assume that they are).\n    const containingAssembly = Stage.of(this);\n    const account = env.account ?? containingAssembly?.account ?? Aws.ACCOUNT_ID;\n    const region = env.region ?? containingAssembly?.region ?? Aws.REGION;\n\n    // this is the \"aws://\" env specification that will be written to the cloud assembly\n    // manifest. it will use \"unknown-account\" and \"unknown-region\" to indicate\n    // environment-agnosticness.\n    const envAccount = !Token.isUnresolved(account) ? account : cxapi.UNKNOWN_ACCOUNT;\n    const envRegion = !Token.isUnresolved(region) ? region : cxapi.UNKNOWN_REGION;\n\n    return {\n      account,\n      region,\n      environment: cxapi.EnvironmentUtils.format(envAccount, envRegion),\n    };\n  }\n\n  /**\n   * Maximum number of resources in the stack\n   *\n   * Set to 0 to mean \"unlimited\".\n   */\n  private get maxResources(): number {\n    const contextLimit = this.node.tryGetContext(STACK_RESOURCE_LIMIT_CONTEXT);\n    return contextLimit !== undefined ? parseInt(contextLimit, 10) : MAX_RESOURCES;\n  }\n\n  /**\n   * Check whether this stack has a (transitive) dependency on another stack\n   *\n   * Returns the list of reasons on the dependency path, or undefined\n   * if there is no dependency.\n   */\n  private stackDependencyReasons(other: Stack): string[] | undefined {\n    if (this === other) { return []; }\n    for (const dep of Object.values(this._stackDependencies)) {\n      const ret = dep.stack.stackDependencyReasons(other);\n      if (ret !== undefined) {\n        return [...dep.reasons, ...ret];\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Calculate the stack name based on the construct path\n   *\n   * The stack name is the name under which we'll deploy the stack,\n   * and incorporates containing Stage names by default.\n   *\n   * Generally this looks a lot like how logical IDs are calculated.\n   * The stack name is calculated based on the construct root path,\n   * as follows:\n   *\n   * - Path is calculated with respect to containing App or Stage (if any)\n   * - If the path is one component long just use that component, otherwise\n   *   combine them with a hash.\n   *\n   * Since the hash is quite ugly and we'd like to avoid it if possible -- but\n   * we can't anymore in the general case since it has been written into legacy\n   * stacks. The introduction of Stages makes it possible to make this nicer however.\n   * When a Stack is nested inside a Stage, we use the path components below the\n   * Stage, and prefix the path components of the Stage before it.\n   */\n  private generateStackName() {\n    const assembly = Stage.of(this);\n    const prefix = (assembly && assembly.stageName) ? `${assembly.stageName}-` : '';\n    return `${prefix}${this.generateStackId(assembly)}`;\n  }\n\n  /**\n   * The artifact ID for this stack\n   *\n   * Stack artifact ID is unique within the App's Cloud Assembly.\n   */\n  private generateStackArtifactId() {\n    return this.generateStackId(this.node.root);\n  }\n\n  /**\n   * Generate an ID with respect to the given container construct.\n   */\n  private generateStackId(container: IConstruct | undefined) {\n    const rootPath = rootPathTo(this, container);\n    const ids = rootPath.map(c => Node.of(c).id);\n\n    // In unit tests our Stack (which is the only component) may not have an\n    // id, so in that case just pretend it's \"Stack\".\n    if (ids.length === 1 && !ids[0]) {\n      throw new Error('unexpected: stack id must always be defined');\n    }\n\n    return makeStackName(ids);\n  }\n}\n\nfunction merge(template: any, fragment: any): void {\n  for (const section of Object.keys(fragment)) {\n    const src = fragment[section];\n\n    // create top-level section if it doesn't exist\n    const dest = template[section];\n    if (!dest) {\n      template[section] = src;\n    } else {\n      template[section] = mergeSection(section, dest, src);\n    }\n  }\n}\n\nfunction mergeSection(section: string, val1: any, val2: any): any {\n  switch (section) {\n    case 'Description':\n      return `${val1}\\n${val2}`;\n    case 'AWSTemplateFormatVersion':\n      if (val1 != null && val2 != null && val1 !== val2) {\n        throw new Error(`Conflicting CloudFormation template versions provided: '${val1}' and '${val2}`);\n      }\n      return val1 ?? val2;\n    case 'Transform':\n      return mergeSets(val1, val2);\n    default:\n      return mergeObjectsWithoutDuplicates(section, val1, val2);\n  }\n}\n\nfunction mergeSets(val1: any, val2: any): any {\n  const array1 = val1 == null ? [] : (Array.isArray(val1) ? val1 : [val1]);\n  const array2 = val2 == null ? [] : (Array.isArray(val2) ? val2 : [val2]);\n  for (const value of array2) {\n    if (!array1.includes(value)) {\n      array1.push(value);\n    }\n  }\n  return array1.length === 1 ? array1[0] : array1;\n}\n\nfunction mergeObjectsWithoutDuplicates(section: string, dest: any, src: any): any {\n  if (typeof dest !== 'object') {\n    throw new Error(`Expecting ${JSON.stringify(dest)} to be an object`);\n  }\n  if (typeof src !== 'object') {\n    throw new Error(`Expecting ${JSON.stringify(src)} to be an object`);\n  }\n\n  // add all entities from source section to destination section\n  for (const id of Object.keys(src)) {\n    if (id in dest) {\n      throw new Error(`section '${section}' already contains '${id}'`);\n    }\n    dest[id] = src[id];\n  }\n\n  return dest;\n}\n\n                                                       \nexport interface ITemplateOptions {\n                                                                                                                                                            \n  description?: string;\n\n                                                                                                \n  templateFormatVersion?: string;\n\n                                                                                                                                                                  \n  transform?: string;\n\n                                                                                                                         \n  transforms?: string[];\n\n                                                                      \n  metadata?: { [key: string]: any };\n}\n\n/**\n * Collect all CfnElements from a Stack.\n *\n * @param node Root node to collect all CfnElements from\n * @param into Array to append CfnElements to\n * @returns The same array as is being collected into\n */\nfunction cfnElements(node: IConstruct, into: CfnElement[] = []): CfnElement[] {\n  if (CfnElement.isCfnElement(node)) {\n    into.push(node);\n  }\n\n  for (const child of Node.of(node).children) {\n    // Don't recurse into a substack\n    if (Stack.isStack(child)) { continue; }\n\n    cfnElements(child, into);\n  }\n\n  return into;\n}\n\n/**\n * Return the construct root path of the given construct relative to the given ancestor\n *\n * If no ancestor is given or the ancestor is not found, return the entire root path.\n */\nexport function rootPathTo(construct: IConstruct, ancestor?: IConstruct): IConstruct[] {\n  const scopes = Node.of(construct).scopes;\n  for (let i = scopes.length - 2; i >= 0; i--) {\n    if (scopes[i] === ancestor) {\n      return scopes.slice(i + 1);\n    }\n  }\n  return scopes;\n}\n\n/**\n * makeUniqueId, specialized for Stack names\n *\n * Stack names may contain '-', so we allow that character if the stack name\n * has only one component. Otherwise we fall back to the regular \"makeUniqueId\"\n * behavior.\n */\nfunction makeStackName(components: string[]) {\n  if (components.length === 1) { return components[0]; }\n  return makeUniqueId(components);\n}\n\nfunction getCreateExportsScope(stack: Stack) {\n  const exportsName = 'Exports';\n  let stackExports = stack.node.tryFindChild(exportsName) as Construct;\n  if (stackExports === undefined) {\n    stackExports = new Construct(stack, exportsName);\n  }\n\n  return stackExports;\n}\n\nfunction generateExportName(stackExports: Construct, id: string) {\n  const stackRelativeExports = FeatureFlags.of(stackExports).isEnabled(cxapi.STACK_RELATIVE_EXPORTS_CONTEXT);\n  const stack = Stack.of(stackExports);\n\n  const components = [\n    ...stackExports.node.scopes\n      .slice(stackRelativeExports ? stack.node.scopes.length : 2)\n      .map(c => c.node.id),\n    id,\n  ];\n  const prefix = stack.stackName ? stack.stackName + ':' : '';\n  const localPart = makeUniqueId(components);\n  const maxLength = 255;\n  return prefix + localPart.slice(Math.max(0, localPart.length - maxLength + prefix.length));\n}\n\ninterface StackDependency {\n  stack: Stack;\n  reasons: string[];\n}\n\n\n                                                       \nexport interface ExportValueOptions {\n                                                                                                     \n  readonly name?: string;\n}\n\n// These imports have to be at the end to prevent circular imports\nimport { CfnOutput } from './cfn-output';\nimport { addDependency } from './deps';\nimport { FileSystem } from './fs';\nimport { Names } from './names';\nimport { Reference } from './reference';\nimport { IResolvable } from './resolvable';\nimport { DefaultStackSynthesizer, IStackSynthesizer, ISynthesisSession, LegacyStackSynthesizer } from './stack-synthesizers';\nimport { Stage } from './stage';\nimport { ITaggable, TagManager } from './tag-manager';\nimport { Token, Tokenization } from './token';\nimport { referenceNestedStackValueInParent } from './private/refs';\nimport { Fact, RegionInfo } from '../../region-info';\nimport { deployTimeLookup } from './private/region-lookup';\n\n"],
  "mappings": "oQAAA,GAAA,QAAA,MACA,KAAA,QAAA,QACA,SAAA,QAAA,+BACA,MAAA,QAAA,gBACA,aAAA,QAAA,cACA,cAAA,QAAA,iBACA,MAAA,QAAA,SACA,MAAA,QAAA,SAEA,cAAA,QAAA,iBACA,SAAA,QAAA,YACA,aAAA,QAAA,gBACA,eAAA,QAAA,kBACA,mBAAA,QAAA,sBAEA,gBAAA,QAAA,mBACA,sBAAA,QAAA,iCACA,aAAA,QAAA,wBACA,UAAA,QAAA,qBACA,WAAA,QAAA,sBAEM,aAAe,OAAO,IAAI,uBAC1B,eAAiB,OAAO,IAAI,+BAErB,QAAA,6BAA+B,mCAE5C,KAAM,wBAAyB,0BAEzB,cAAgB,IA0BtB,mBAA2B,cAAA,SAAS,CAmGlC,YAAmB,MAAmB,GAAa,MAAoB,GAAE,oEAGvE,MAAQ,OAAK,KAAL,MAAS,GAAI,OAAA,IAAI,CACvB,UAAW,GACX,OAAQ,KAAA,WAAW,QAAQ,mBAI7B,GAAK,IAAE,KAAF,GAAM,UAEX,MAAM,MAAO,IAEb,KAAK,gBAAkB,GAAI,OAC3B,KAAK,mBAAqB,GAC1B,KAAK,gBAAkB,GAEvB,OAAO,eAAe,KAAM,aAAc,CAAE,MAAO,KAEnD,KAAK,YAAc,GAAI,cAAA,WAEvB,KAAM,CAAE,QAAS,OAAQ,aAAgB,KAAK,iBAAiB,MAAM,KAOrE,GALA,KAAK,QAAU,QACf,KAAK,OAAS,OACd,KAAK,YAAc,YACnB,KAAK,sBAAwB,MAAM,sBAE/B,MAAM,cAAgB,OAAW,CAGnC,GAAI,MAAM,YAAY,OAAS,IAC7B,KAAM,IAAI,OAAM,mEAAmE,MAAM,gBAE3F,KAAK,gBAAgB,YAAc,MAAM,YAM3C,GAHA,KAAK,WAAU,IAAG,MAAM,aAAS,MAAA,KAAA,OAAA,GAAI,KAAK,oBAC1C,KAAK,KAAO,GAAI,eAAA,WAAW,eAAA,QAAQ,UAAW,gBAAiB,MAAM,MAEjE,CAAC,uBAAuB,KAAK,KAAK,WACpC,KAAM,IAAI,OAAM,iDAAiD,uBAAuB,oBAAoB,KAAK,cAWnH,KAAM,cAAe,gBAAA,aAAa,GAAG,MAC/B,qBAAuB,aAAa,UAAU,MAAM,sCACpD,yBAA2B,aAAa,UAAU,MAAM,mCAC9D,KAAK,WAAc,sBAAwB,yBACvC,KAAK,0BACL,KAAK,UAET,KAAK,aAAe,GAAG,KAAK,2BAG5B,KAAK,yBAA2B,KAAC,MAAM,sBAAkB,MAAA,KAAA,OAAA,GAAI,KAAK,KAAK,cAAc,MAAM,uCACtF,CAAC,KAAK,kBAEX,KAAK,YAAW,IAAG,MAAM,eAAW,MAAA,KAAA,OAAA,GAAK,yBACrC,GAAI,sBAAA,wBACJ,GAAI,sBAAA,uBACR,KAAK,YAAY,KAAK,YArKV,SAAQ,EAAM,CAC1B,MAAO,KAAM,MAAQ,MAAO,IAAO,UAAY,eAAgB,SAInD,IAAG,UAAqB,CAKpC,KAAM,OAAS,UAAkB,gBACjC,GAAI,MACF,MAAO,OACF,CACL,KAAM,OAAQ,QAAQ,WACtB,cAAO,eAAe,UAAW,eAAgB,CAC/C,WAAY,GACZ,SAAU,GACV,aAAc,GACd,QAEK,MAGT,iBAAiB,EAAa,WAC5B,GAAI,MAAM,QAAQ,GAChB,MAAO,GAGT,KAAM,QAAS,aAAA,KAAK,GAAG,GAAG,MAC1B,GAAI,QAAA,MAAM,QAAQ,IAAM,CAAC,OACvB,KAAM,IAAI,OAAM,GAAG,IAAA,IAAA,UAAU,eAAW,MAAA,KAAA,OAAA,OAAA,GAAE,QAAI,MAAA,KAAA,OAAA,GAAI,mBAAmB,aAAA,KAAK,GAAG,WAAW,uEAG1F,MAAO,SAAQ,SAuIZ,QAAQ,IAAQ,CACrB,MAAO,WAAA,QAAQ,IAAK,CAClB,MAAO,KACP,OAAQ,GACR,SAAU,sBAAA,8BACV,UAAW,KAKR,aAAa,IAAU,MAAc,CAC1C,MAAO,uBAAA,mBAAmB,OAAO,IAAK,OAAO,WAIxC,qBAAqB,OAA4B,CACtD,GAAI,CAAC,OAAO,OAAO,SAAS,iBAAiB,SAAS,OAAO,UAC3D,KAAM,IAAI,OAAM,0CAA0C,KAAK,UAAU,WAE3E,KAAK,wBAAwB,QAIxB,wBAAwB,OAA+B,kFAC5D,KAAK,gBAAgB,KAAK,QAIrB,gBAAgB,MAAe,MAAa,CACjD,KAAK,YAAY,UAAU,MAAO,OAI7B,aAAa,QAAmB,yDACrC,KAAM,WAAY,KAAK,kBAAkB,SACzC,MAAO,MAAK,YAAY,YAAY,WAI/B,cAAc,OAAe,OAAe,mDACjD,OAAA,cAAc,KAAM,OAAQ,WAInB,eAAY,CACrB,MAAO,QAAO,OAAO,KAAK,oBAAoB,IAAI,GAAK,EAAE,UAIhD,YAAS,CAClB,MAAO,MAAK,cAIH,YAAS,CAIlB,MAAO,cAAA,IAAI,aAIF,YAAS,CAElB,MAAO,cAAA,IAAI,cAIF,UAAO,CAChB,MAAO,IAAI,cAAA,UAAU,MAAM,WAIlB,mBAAgB,CACzB,MAAO,IAAI,cAAA,UAAU,MAAM,oBAIlB,SAAM,CACf,MAAO,MAAK,sBAAwB,OAI/B,UAAU,WAAyB,sEACjC,MAAA,IAAI,OAAO,WAAY,MAIzB,SAAS,IAAa,WAAqB,IAAK,QAAmB,GAAI,CAC5E,MAAO,OAAA,IAAI,MAAM,IAAK,WAAY,SAI7B,SAAS,IAAa,UAAoB,iEACxC,MAAA,IAAI,MAAM,IAAK,cAIb,oBAAiB,CAK1B,GADiB,QAAA,MAAM,aAAa,KAAK,UAAY,QAAA,MAAM,aAAa,KAAK,QAE3E,MAAO,MAAK,KAAK,cAAc,MAAM,yCAA2C,CAC9E,SAAA,GAAG,OAAO,EAAG,SAAA,GAAG,UAChB,SAAA,GAAG,OAAO,EAAG,SAAA,GAAG,WAIpB,KAAM,OAAQ,mBAAA,gBAAgB,SAAS,KAAM,CAC3C,SAAU,SAAS,gBAAgB,2BACnC,WAAY,CAAC,UAAW,UAAW,aAClC,MAEH,GAAI,CAAC,MAAM,QAAQ,OACjB,KAAM,IAAI,OAAM,YAAY,SAAS,gBAAgB,6CAGvD,MAAO,OAIF,aAAa,MAAsB,CACxC,MAAO,MAAK,YAAY,aAAa,OAIhC,oBAAoB,MAA6B,CACtD,MAAO,MAAK,YAAY,oBAAoB,UAInC,oBAAiB,CAC1B,MAAO,MAAK,qBAAuB,MAAM,GAAG,KAAK,wBAIxC,cAAW,CACpB,MAAO,MAAK,kBAIP,aAAa,UAAiB,CACnC,AAAK,KAAK,gBAAgB,YACxB,MAAK,gBAAgB,WAAa,IAEpC,KAAK,gBAAgB,WAAW,KAAK,WAYhC,uBAAuB,OAAe,OAAe,CAE1D,GAAI,KAAK,QAAU,OAAO,OACxB,KAAM,IAAI,OAAM,4DAGlB,OAAS,QAAU,+CACnB,KAAM,OAAQ,OAAO,uBAAuB,MAC5C,GAAI,QAAU,OAEZ,KAAM,IAAI,OAAM,IAAI,OAAO,KAAK,qBAAqB,KAAK,KAAK,UAAU,MAAM,KAAK,mCAAmC,4CAGzH,GAAI,KAAM,KAAK,mBAAmB,QAAA,MAAM,SAAS,SACjD,AAAK,KACH,KAAM,KAAK,mBAAmB,QAAA,MAAM,SAAS,SAAW,CACtD,MAAO,OACP,QAAS,KAIb,IAAI,QAAQ,KAAK,QAEb,QAAQ,IAAI,gBAEd,QAAQ,MAAM,2BAA2B,KAAK,KAAK,qBAAqB,OAAO,KAAK,kBAAkB,UAQnG,oBAAoB,QAA4B,cAAsB,CAO3E,KAAM,SAAU,QAAQ,SAElB,SAAW,KAAK,oBAGhB,QAAU,KAAK,KAAK,QAAQ,OAAQ,KAAK,cAE/C,GAAI,KAAK,aAAe,EAAG,CACzB,KAAM,WAAY,SAAS,WAAa,GAClC,kBAAoB,OAAO,KAAK,WAAW,OAEjD,GAAI,kBAAoB,KAAK,aAC3B,KAAM,IAAI,OAAM,iCAAiC,KAAK,KAAK,UAAU,wDAAwD,KAAK,gBAC7H,AAAI,mBAAsB,KAAK,aAAe,IACnD,cAAA,YAAY,GAAG,MAAM,QAAQ,wBAAwB,uDAAuD,KAAK,gBAGrH,GAAG,cAAc,QAAS,KAAK,UAAU,SAAU,OAAW,IAE9D,SAAW,OAAO,MAAK,gBACrB,AAAI,eAAiB,KACnB,QAAQ,WAAW,IAAK,IAAK,MAAO,IAAK,IAAI,MAAO,iBAEpD,QAAQ,WAAW,KAMlB,aAAa,SAAkB,aAAqB,QACzD,GAAI,CAAC,QAAA,MAAM,aAAa,KAAK,QAAS,CACpC,KAAM,KAAG,IAAG,cAAA,KAAK,KAAK,KAAK,OAAQ,aAAS,MAAA,KAAA,OAAA,GAAI,aAChD,GAAI,MAAQ,OACV,KAAM,IAAI,OAAM,2BAA2B,uBAAuB,KAAK,sDAEzE,MAAO,KAGT,KAAM,YAAa,aAAA,KAAK,GAAG,MAAM,cAAc,MAAM,mBACrD,GAAI,aAAe,QAAa,CAAC,MAAM,QAAQ,YAC7C,KAAM,IAAI,OAAM,kBAAkB,MAAM,wDAAwD,KAAK,UAAU,MAAM,sBAGvH,KAAM,WAAY,WAAa,cAAA,WAAW,iBAAiB,SAAU,YAAc,cAAA,WAAW,UAAU,UAExG,MAAO,iBAAA,iBAAiB,KAAM,SAAU,UAAW,cAK9C,YAAY,cAAoB,QAA8B,GAAE,CACrE,mEAAI,QAAQ,KACV,UAAI,cAAA,UAAU,KAAM,SAAS,QAAQ,OAAQ,CAC3C,MAAO,cACP,WAAY,QAAQ,OAEf,SAAA,GAAG,YAAY,QAAQ,MAGhC,KAAM,YAAa,QAAA,aAAa,QAAQ,eACxC,GAAI,CAAC,YAAc,CAAC,YAAA,UAAU,YAAY,YACxC,KAAM,IAAI,OAAM,4GAKlB,KAAM,YAAa,OAAA,kCAAkC,WAAY,MAM3D,aAAe,sBAAsB,MAGrC,SAAW,KAAK,QAAQ,YACxB,GAAK,SAAW,KAAK,UAAU,UAC/B,WAAa,mBAAmB,aAAc,IAEpD,GAAI,QAAA,MAAM,aAAa,YACrB,KAAM,IAAI,OAAM,8CAA8C,KAAK,UAAU,KAAK,QAAQ,gBAI5F,MAAK,AADU,cAAa,KAAK,aAAa,KAE5C,GAAI,cAAA,UAAU,aAAc,GAAI,CAAE,MAAO,QAAA,MAAM,SAAS,YAAa,aAGhE,SAAA,GAAG,YAAY,YAId,kBAAkB,WAAsB,4DAChD,KAAM,QAAS,WAAW,KAAK,OACzB,WAAa,OAAO,QAAQ,WAAW,OACvC,eAAiB,OAAO,MAAM,WAAa,GAAG,IAAI,GAAK,EAAE,KAAK,IACpE,MAAO,YAAA,aAAa,gBAWZ,YAAY,KAAY,CAChC,GAAI,MAAQ,CAAC,uBAAuB,KAAK,MACvC,KAAM,IAAI,OAAM,iDAAiD,uBAAuB,oBAAoB,SAUtG,mBAAiB,CACzB,GAAI,WAEJ,AAAI,KAAK,gBAAgB,WAEvB,eAAA,YAAY,GAAG,MAAM,WAAW,oHAChC,KAAK,aAAa,KAAK,gBAAgB,YAGrC,KAAK,gBAAgB,YACvB,CAAI,KAAK,gBAAgB,WAAW,SAAW,EAC7C,UAAY,KAAK,gBAAgB,WAAW,GAE5C,UAAY,MAAM,KAAK,GAAI,KAAI,KAAK,gBAAgB,cAIxD,KAAM,UAAgB,CACpB,YAAa,KAAK,gBAAgB,YAClC,UAAW,UACX,yBAA0B,KAAK,gBAAgB,sBAC/C,SAAU,KAAK,gBAAgB,UAI3B,UAAY,AADD,YAAY,MACF,IAAI,GAAK,KAAK,QAAQ,EAAE,sBAGnD,SAAW,YAAY,WACrB,MAAM,SAAU,UAIlB,KAAM,KAAM,KAAK,QAAQ,WAAa,GAEtC,YAAK,YAAY,0BAEV,IAIC,sBAAsB,aAAqB,UAAoB,CACvE,MAAO,WAOD,iBAAiB,IAAmB,GAAE,iBAQ5C,KAAM,oBAAqB,QAAA,MAAM,GAAG,MAC9B,QAAO,IAAA,IAAG,IAAI,WAAO,MAAA,KAAA,OAAA,GAAI,oBAAkB,KAAA,OAAlB,mBAAoB,WAAO,MAAA,KAAA,OAAA,GAAI,aAAA,IAAI,WAC5D,OAAM,IAAA,IAAG,IAAI,UAAM,MAAA,KAAA,OAAA,GAAI,oBAAkB,KAAA,OAAlB,mBAAoB,UAAM,MAAA,KAAA,OAAA,GAAI,aAAA,IAAI,OAKzD,WAAa,AAAC,QAAA,MAAM,aAAa,SAAqB,MAAM,gBAAhB,QAC5C,UAAY,AAAC,QAAA,MAAM,aAAa,QAAmB,MAAM,eAAf,OAEhD,MAAO,CACL,QACA,OACA,YAAa,MAAM,iBAAiB,OAAO,WAAY,eAS/C,eAAY,CACtB,KAAM,cAAe,KAAK,KAAK,cAAc,QAAA,8BAC7C,MAAO,gBAAiB,OAAY,SAAS,aAAc,IAAM,cAS3D,uBAAuB,MAAY,CACzC,GAAI,OAAS,MAAS,MAAO,GAC7B,SAAW,OAAO,QAAO,OAAO,KAAK,oBAAqB,CACxD,KAAM,KAAM,IAAI,MAAM,uBAAuB,OAC7C,GAAI,MAAQ,OACV,MAAO,CAAC,GAAG,IAAI,QAAS,GAAG,MA0BzB,mBAAiB,CACvB,KAAM,UAAW,QAAA,MAAM,GAAG,MAE1B,MAAO,GADS,UAAY,SAAS,UAAa,GAAG,SAAS,aAAe,KAC1D,KAAK,gBAAgB,YAQlC,yBAAuB,CAC7B,MAAO,MAAK,gBAAgB,KAAK,KAAK,MAMhC,gBAAgB,UAAiC,CAEvD,KAAM,KAAM,AADK,WAAW,KAAM,WACb,IAAI,GAAK,aAAA,KAAK,GAAG,GAAG,IAIzC,GAAI,IAAI,SAAW,GAAK,CAAC,IAAI,GAC3B,KAAM,IAAI,OAAM,+CAGlB,MAAO,eAAc,MA9nBzB,QAAA,MAAA,iFAkoBA,eAAe,SAAe,SAAa,CACzC,SAAW,WAAW,QAAO,KAAK,UAAW,CAC3C,KAAM,KAAM,SAAS,SAGf,KAAO,SAAS,SACtB,AAAK,KAGH,SAAS,SAAW,aAAa,QAAS,KAAM,KAFhD,SAAS,SAAW,KAO1B,sBAAsB,QAAiB,KAAW,KAAS,CACzD,OAAQ,aACD,cACH,MAAO,GAAG;EAAS,WAChB,2BACH,GAAI,MAAQ,MAAQ,MAAQ,MAAQ,OAAS,KAC3C,KAAM,IAAI,OAAM,2DAA2D,cAAc,QAE3F,MAAO,OAAI,KAAJ,KAAQ,SACZ,YACH,MAAO,WAAU,KAAM,cAEvB,MAAO,+BAA8B,QAAS,KAAM,OAI1D,mBAAmB,KAAW,KAAS,CACrC,KAAM,QAAS,MAAQ,KAAO,GAAM,MAAM,QAAQ,MAAQ,KAAO,CAAC,MAC5D,OAAS,MAAQ,KAAO,GAAM,MAAM,QAAQ,MAAQ,KAAO,CAAC,MAClE,SAAW,SAAS,QAClB,AAAK,OAAO,SAAS,QACnB,OAAO,KAAK,OAGhB,MAAO,QAAO,SAAW,EAAI,OAAO,GAAK,OAG3C,uCAAuC,QAAiB,KAAW,IAAQ,CACzE,GAAI,MAAO,OAAS,SAClB,KAAM,IAAI,OAAM,aAAa,KAAK,UAAU,yBAE9C,GAAI,MAAO,MAAQ,SACjB,KAAM,IAAI,OAAM,aAAa,KAAK,UAAU,wBAI9C,SAAW,MAAM,QAAO,KAAK,KAAM,CACjC,GAAI,KAAM,MACR,KAAM,IAAI,OAAM,YAAY,8BAA8B,OAE5D,KAAK,IAAM,IAAI,IAGjB,MAAO,MA4BT,qBAAqB,KAAkB,KAAqB,GAAE,CAC5D,AAAI,cAAA,WAAW,aAAa,OAC1B,KAAK,KAAK,MAGZ,SAAW,SAAS,cAAA,KAAK,GAAG,MAAM,SAEhC,AAAI,MAAM,QAAQ,QAElB,YAAY,MAAO,MAGrB,MAAO,MAQT,oBAA2B,UAAuB,SAAqB,CACrE,KAAM,QAAS,aAAA,KAAK,GAAG,WAAW,OAClC,OAAS,GAAI,OAAO,OAAS,EAAG,GAAK,EAAG,IACtC,GAAI,OAAO,KAAO,SAChB,MAAO,QAAO,MAAM,EAAI,GAG5B,MAAO,QAPT,QAAA,WAAA,WAiBA,uBAAuB,WAAoB,CACzC,MAAI,YAAW,SAAW,EAAY,WAAW,GAC1C,WAAA,aAAa,YAGtB,+BAA+B,MAAY,CACzC,KAAM,aAAc,UACpB,GAAI,cAAe,MAAM,KAAK,aAAa,aAC3C,MAAI,gBAAiB,QACnB,cAAe,GAAI,cAAA,UAAU,MAAO,cAG/B,aAGT,4BAA4B,aAAyB,GAAU,CAC7D,KAAM,sBAAuB,gBAAA,aAAa,GAAG,cAAc,UAAU,MAAM,gCACrE,MAAQ,MAAM,GAAG,cAEjB,WAAa,CACjB,GAAG,aAAa,KAAK,OAClB,MAAM,qBAAuB,MAAM,KAAK,OAAO,OAAS,GACxD,IAAI,GAAK,EAAE,KAAK,IACnB,IAEI,OAAS,MAAM,UAAY,MAAM,UAAY,IAAM,GACnD,UAAY,WAAA,aAAa,YACzB,UAAY,IAClB,MAAO,QAAS,UAAU,MAAM,KAAK,IAAI,EAAG,UAAU,OAAS,UAAY,OAAO,SAgBpF,KAAA,cAAA,QAAA,gBACA,OAAA,QAAA,UACA,KAAA,QAAA,QACA,QAAA,QAAA,WACA,YAAA,QAAA,eAEA,qBAAA,QAAA,wBACA,QAAA,QAAA,WACA,cAAA,QAAA,iBACA,QAAA,QAAA,WACA,OAAA,QAAA,kBACA,cAAA,QAAA,qBACA,gBAAA,QAAA",
  "names": []
}
