{
  "version": 3,
  "sources": ["token.ts"],
  "sourcesContent": ["import { IConstruct } from 'constructs';\nimport { Lazy } from './lazy';\nimport { unresolved } from './private/encoding';\nimport { Intrinsic } from './private/intrinsic';\nimport { resolve } from './private/resolve';\nimport { TokenMap } from './private/token-map';\nimport { IResolvable, ITokenResolver } from './resolvable';\nimport { TokenizedStringFragments } from './string-fragments';\n\n                                                                                                                                     \nexport class TokenComparison {\n                                                                                                \n  public static readonly SAME = new TokenComparison();\n\n                                                                                                \n  public static readonly DIFFERENT = new TokenComparison();\n\n                                                             \n  public static readonly ONE_UNRESOLVED = new TokenComparison();\n\n                                               \n  public static readonly BOTH_UNRESOLVED = new TokenComparison();\n\n  private constructor() {\n  }\n}\n\n                                                                                                                                                                                                                                                                                                                                                                                 \nexport class Token {\n                                                                                                                                                                                                                                                                                                                                                                                                               \n  public static isUnresolved(obj: any): boolean {\n    return unresolved(obj);\n  }\n\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n  public static asString(value: any, options: EncodingOptions = {}): string {\n    if (typeof value === 'string') { return value; }\n    return TokenMap.instance().registerString(Token.asAny(value), options.displayHint);\n  }\n\n                                                                        \n  public static asNumber(value: any): number {\n    if (typeof value === 'number') { return value; }\n    return TokenMap.instance().registerNumber(Token.asAny(value));\n  }\n\n                                                                      \n  public static asList(value: any, options: EncodingOptions = {}): string[] {\n    if (Array.isArray(value) && value.every(x => typeof x === 'string')) { return value; }\n    return TokenMap.instance().registerList(Token.asAny(value), options.displayHint);\n  }\n\n                                                                      \n  public static asAny(value: any): IResolvable {\n    return isResolvableObject(value) ? value : new Intrinsic(value);\n  }\n\n                                                                       \n  public static compareStrings(possibleToken1: string, possibleToken2: string): TokenComparison {\n    const firstIsUnresolved = Token.isUnresolved(possibleToken1);\n    const secondIsUnresolved = Token.isUnresolved(possibleToken2);\n\n    if (firstIsUnresolved && secondIsUnresolved) {\n      return TokenComparison.BOTH_UNRESOLVED;\n    }\n    if (firstIsUnresolved || secondIsUnresolved) {\n      return TokenComparison.ONE_UNRESOLVED;\n    }\n\n    return possibleToken1 === possibleToken2 ? TokenComparison.SAME : TokenComparison.DIFFERENT;\n  }\n\n  private constructor() {\n  }\n}\n\n                                                         \nexport class Tokenization {\n                                                                         \n  public static reverseString(s: string): TokenizedStringFragments {\n    return TokenMap.instance().splitString(s);\n  }\n\n                                                                                                                                                                                                                  \n  public static reverseCompleteString(s: string): IResolvable | undefined {\n    const fragments = Tokenization.reverseString(s);\n    if (fragments.length !== 1) {\n      throw new Error(`Tokenzation.reverseCompleteString: argument must not be a concatentation, got '${s}'`);\n    }\n    return fragments.firstToken;\n  }\n\n                                                          \n  public static reverseNumber(n: number): IResolvable | undefined {\n    return TokenMap.instance().lookupNumberToken(n);\n  }\n\n                                                        \n  public static reverseList(l: string[]): IResolvable | undefined {\n    return TokenMap.instance().lookupList(l);\n  }\n\n                                                                                                                                        \n  public static reverse(x: any, options: ReverseOptions = {}): IResolvable | undefined {\n    if (Tokenization.isResolvable(x)) { return x; }\n    if (typeof x === 'string') {\n      if (options.failConcat === false) {\n        // Handle this specially because reverseCompleteString might fail\n        const fragments = Tokenization.reverseString(x);\n        return fragments.length === 1 ? fragments.firstToken : undefined;\n      }\n      return Tokenization.reverseCompleteString(x);\n    }\n    if (Array.isArray(x)) { return Tokenization.reverseList(x); }\n    if (typeof x === 'number') { return Tokenization.reverseNumber(x); }\n    return undefined;\n  }\n\n                                                                                                                                                                                                                                                                                                                                         \n  public static resolve(obj: any, options: ResolveOptions): any {\n    return resolve(obj, {\n      scope: options.scope,\n      resolver: options.resolver,\n      preparing: (options.preparing ?? false),\n      removeEmpty: options.removeEmpty,\n    });\n  }\n\n                                                                                                                                                                                                                                                      \n  public static isResolvable(obj: any): obj is IResolvable {\n    return isResolvableObject(obj);\n  }\n\n                                                                                                                                             \n  public static stringifyNumber(x: number) {\n    // only convert numbers to strings so that Refs, conditions, and other things don't end up synthesizing as [object object]\n\n    if (Token.isUnresolved(x)) {\n      return Lazy.uncachedString({\n        produce: context => {\n          const resolved = context.resolve(x);\n          return typeof resolved !== 'number' ? resolved : `${resolved}`;\n        },\n      });\n    } else {\n      return typeof x !== 'number' ? x : `${x}`;\n    }\n  }\n\n  private constructor() {\n  }\n}\n\n                                                \nexport interface ReverseOptions {\n                                                                                                                                   \n  readonly failConcat?: boolean;\n}\n\n                                                                                                                                                                                                                                                                                                 \nexport interface ResolveOptions {\n                                                             \n  readonly scope: IConstruct;\n\n                                                                     \n  readonly resolver: ITokenResolver;\n\n                                                                                                              \n  readonly preparing?: boolean;\n\n                                                                                                                     \n  readonly removeEmpty?: boolean;\n}\n\n                                         \nexport interface EncodingOptions {\n                                                                    \n  readonly displayHint?: string;\n}\n\nexport function isResolvableObject(x: any): x is IResolvable {\n  return typeof(x) === 'object' && x !== null && typeof x.resolve === 'function';\n}\n\n/**\n * Call the given function only if all given values are resolved\n *\n * Exported as a function since it will be used by TypeScript modules, but\n * can't be exposed via JSII because of the generics.\n */\nexport function withResolved<A>(a: A, fn: (a: A) => void): void;\nexport function withResolved<A, B>(a: A, b: B, fn: (a: A, b: B) => void): void;\nexport function withResolved<A, B, C>(a: A, b: B, c: C, fn: (a: A, b: B, c: C) => void): void;\nexport function withResolved(...args: any[]) {\n  if (args.length < 2) { return; }\n  const argArray = args.slice(0, args.length - 1);\n  if (argArray.some(Token.isUnresolved)) { return; }\n  args[args.length - 1].apply(arguments, argArray);\n}\n"],
  "mappings": "+SACA,OAAA,QAAA,UACA,WAAA,QAAA,sBACA,YAAA,QAAA,uBACA,UAAA,QAAA,qBACA,YAAA,QAAA,uBAKA,qBAA4B,CAa1B,aAAA,GAbF,QAAA,gBAAA,+GAEyB,gBAAA,KAAO,GAAI,iBAGX,gBAAA,UAAY,GAAI,iBAGhB,gBAAA,eAAiB,GAAI,iBAGrB,gBAAA,gBAAkB,GAAI,iBAO/C,WAAkB,CA4ChB,aAAA,QA1Cc,cAAa,IAAQ,CACjC,MAAO,YAAA,WAAW,WAIN,UAAS,MAAY,QAA2B,GAAE,CAC9D,oEAAI,MAAO,QAAU,SAAmB,MACjC,YAAA,SAAS,WAAW,eAAe,MAAM,MAAM,OAAQ,QAAQ,mBAI1D,UAAS,MAAU,CAC/B,MAAI,OAAO,QAAU,SAAmB,MACjC,YAAA,SAAS,WAAW,eAAe,MAAM,MAAM,cAI1C,QAAO,MAAY,QAA2B,GAAE,CAC5D,oEAAI,MAAM,QAAQ,QAAU,MAAM,MAAM,GAAK,MAAO,IAAM,UAAoB,MACvE,YAAA,SAAS,WAAW,aAAa,MAAM,MAAM,OAAQ,QAAQ,mBAIxD,OAAM,MAAU,CAC5B,MAAO,oBAAmB,OAAS,MAAQ,GAAI,aAAA,UAAU,aAI7C,gBAAe,eAAwB,eAAsB,CACzE,KAAM,mBAAoB,MAAM,aAAa,gBACvC,mBAAqB,MAAM,aAAa,gBAE9C,MAAI,oBAAqB,mBAChB,gBAAgB,gBAErB,mBAAqB,mBAChB,gBAAgB,eAGlB,iBAAmB,eAAiB,gBAAgB,KAAO,gBAAgB,WAzCtF,QAAA,MAAA,iFAiDA,kBAAyB,CAwEvB,aAAA,QAtEc,eAAc,EAAS,CACnC,MAAO,aAAA,SAAS,WAAW,YAAY,SAI3B,uBAAsB,EAAS,CAC3C,KAAM,WAAY,aAAa,cAAc,GAC7C,GAAI,UAAU,SAAW,EACvB,KAAM,IAAI,OAAM,kFAAkF,MAEpG,MAAO,WAAU,iBAIL,eAAc,EAAS,CACnC,MAAO,aAAA,SAAS,WAAW,kBAAkB,SAIjC,aAAY,EAAW,CACnC,MAAO,aAAA,SAAS,WAAW,WAAW,SAI1B,SAAQ,EAAQ,QAA0B,GAAE,CACxD,+DAAI,aAAa,aAAa,GAAM,MAAO,GAC3C,GAAI,MAAO,IAAM,SAAU,CACzB,GAAI,QAAQ,aAAe,GAAO,CAEhC,KAAM,WAAY,aAAa,cAAc,GAC7C,MAAO,WAAU,SAAW,EAAI,UAAU,WAAa,OAEzD,MAAO,cAAa,sBAAsB,GAE5C,GAAI,MAAM,QAAQ,GAAM,MAAO,cAAa,YAAY,GACxD,GAAI,MAAO,IAAM,SAAY,MAAO,cAAa,cAAc,SAKnD,SAAQ,IAAU,QAAuB,2EAC9C,UAAA,QAAQ,IAAK,CAClB,MAAO,QAAQ,MACf,SAAU,QAAQ,SAClB,UAAW,IAAC,QAAQ,aAAS,MAAA,KAAA,OAAA,GAAI,GACjC,YAAa,QAAQ,oBAKX,cAAa,IAAQ,CACjC,MAAO,oBAAmB,WAId,iBAAgB,EAAS,CAGrC,MAAI,OAAM,aAAa,GACd,OAAA,KAAK,eAAe,CACzB,QAAS,SAAU,CACjB,KAAM,UAAW,QAAQ,QAAQ,GACjC,MAAO,OAAO,WAAa,SAAW,SAAW,GAAG,cAIjD,MAAO,IAAM,SAAW,EAAI,GAAG,KApE5C,QAAA,aAAA,sGAuGA,4BAAmC,EAAM,CACvC,MAAO,OAAO,IAAO,UAAY,IAAM,MAAQ,MAAO,GAAE,SAAY,WADtE,QAAA,mBAAA,mBAaA,yBAAgC,KAAW,CACzC,GAAI,KAAK,OAAS,EAAK,OACvB,KAAM,UAAW,KAAK,MAAM,EAAG,KAAK,OAAS,GAC7C,AAAI,SAAS,KAAK,MAAM,eACxB,KAAK,KAAK,OAAS,GAAG,MAAM,UAAW,UAJzC,QAAA,aAAA",
  "names": []
}
