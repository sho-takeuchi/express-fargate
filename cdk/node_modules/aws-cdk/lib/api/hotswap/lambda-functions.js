"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = void 0;
const stream_1 = require("stream");
const archiver = require("archiver");
const AWS = require("aws-sdk");
const util_1 = require("../../util");
const evaluate_cloudformation_template_1 = require("../evaluate-cloudformation-template");
const common_1 = require("./common");
/**
 * Returns `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change cannot be short-circuited,
 * `ChangeHotswapImpact.IRRELEVANT` if the change is irrelevant from a short-circuit perspective
 * (like a change to CDKMetadata),
 * or a LambdaFunctionResource if the change can be short-circuited.
 */
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    var _a;
    // if the change is for a Lambda Version,
    // ignore it by returning an empty hotswap operation -
    // we will publish a new version when we get to hotswapping the actual Function this Version points to, below
    // (Versions can't be changed in CloudFormation anyway, they're immutable)
    if (change.newValue.Type === 'AWS::Lambda::Version') {
        return common_1.ChangeHotswapImpact.IRRELEVANT;
    }
    // we handle Aliases specially too
    if (change.newValue.Type === 'AWS::Lambda::Alias') {
        return checkAliasHasVersionOnlyChange(change);
    }
    const lambdaCodeChange = await isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate);
    if (typeof lambdaCodeChange === 'string') {
        return lambdaCodeChange;
    }
    const functionName = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.FunctionName);
    if (!functionName) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const functionArn = await evaluateCfnTemplate.evaluateCfnExpression({
        'Fn::Sub': 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:' + functionName,
    });
    // find all Lambda Versions that reference this Function
    const versionsReferencingFunction = evaluateCfnTemplate.findReferencesTo(logicalId)
        .filter(r => r.Type === 'AWS::Lambda::Version');
    // find all Lambda Aliases that reference the above Versions
    const aliasesReferencingVersions = util_1.flatMap(versionsReferencingFunction, v => evaluateCfnTemplate.findReferencesTo(v.LogicalId));
    const aliasesNames = await Promise.all(aliasesReferencingVersions.map(a => { var _a; return evaluateCfnTemplate.evaluateCfnExpression((_a = a.Properties) === null || _a === void 0 ? void 0 : _a.Name); }));
    return new LambdaFunctionHotswapOperation({
        physicalName: functionName,
        functionArn: functionArn,
        resource: lambdaCodeChange,
        publishVersion: versionsReferencingFunction.length > 0,
        aliasesNames,
    });
}
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
/**
 * Returns  is a given Alias change is only in the 'FunctionVersion' property,
 * and `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` is the change is for any other property.
 */
function checkAliasHasVersionOnlyChange(change) {
    for (const updatedPropName in change.propertyUpdates) {
        if (updatedPropName !== 'FunctionVersion') {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    return common_1.ChangeHotswapImpact.IRRELEVANT;
}
/**
 * Returns `ChangeHotswapImpact.IRRELEVANT` if the change is not for a AWS::Lambda::Function,
 * but doesn't prevent short-circuiting
 * (like a change to CDKMetadata resource),
 * `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change is to a AWS::Lambda::Function,
 * but not only to its Code property,
 * or a LambdaFunctionCode if the change is to a AWS::Lambda::Function,
 * and only affects its Code property.
 */
async function isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate) {
    var _a;
    const newResourceType = change.newValue.Type;
    if (newResourceType !== 'AWS::Lambda::Function') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    /*
     * At first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    const propertyUpdates = change.propertyUpdates;
    let code = undefined;
    let tags = undefined;
    for (const updatedPropName in propertyUpdates) {
        const updatedProp = propertyUpdates[updatedPropName];
        switch (updatedPropName) {
            case 'Code':
                let foundCodeDifference = false;
                let s3Bucket, s3Key, imageUri, functionCodeZip;
                for (const newPropName in updatedProp.newValue) {
                    switch (newPropName) {
                        case 'S3Bucket':
                            foundCodeDifference = true;
                            s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'S3Key':
                            foundCodeDifference = true;
                            s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ImageUri':
                            foundCodeDifference = true;
                            imageUri = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ZipFile':
                            foundCodeDifference = true;
                            // We must create a zip package containing a file with the inline code
                            const functionCode = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            const functionRuntime = await evaluateCfnTemplate.evaluateCfnExpression((_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.Runtime);
                            if (!functionRuntime) {
                                return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
                            }
                            // file extension must be chosen depending on the runtime
                            const codeFileExt = determineCodeFileExtFromRuntime(functionRuntime);
                            functionCodeZip = await zipString(`index.${codeFileExt}`, functionCode);
                            break;
                        default:
                            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
                    }
                }
                if (foundCodeDifference) {
                    code = {
                        s3Bucket,
                        s3Key,
                        imageUri,
                        functionCodeZip,
                    };
                }
                break;
            case 'Tags':
                /*
                 * Tag updates are a bit odd; they manifest as two lists, are flagged only as
                 * `isDifferent`, and we have to reconcile them.
                 */
                const tagUpdates = {};
                if (updatedProp === null || updatedProp === void 0 ? void 0 : updatedProp.isDifferent) {
                    updatedProp.newValue.forEach((tag) => {
                        tagUpdates[tag.Key] = tag.Value;
                    });
                    updatedProp.oldValue.forEach((tag) => {
                        if (tagUpdates[tag.Key] === undefined) {
                            tagUpdates[tag.Key] = TagDeletion.DELETE;
                        }
                    });
                    tags = { tagUpdates };
                }
                break;
            default:
                return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    return code || tags ? { code, tags } : common_1.ChangeHotswapImpact.IRRELEVANT;
}
var TagDeletion;
(function (TagDeletion) {
    TagDeletion[TagDeletion["DELETE"] = -1] = "DELETE";
})(TagDeletion || (TagDeletion = {}));
class LambdaFunctionHotswapOperation {
    constructor(lambdaFunctionResource) {
        this.lambdaFunctionResource = lambdaFunctionResource;
        this.service = 'lambda-function';
        this.resourceNames = [
            `Lambda Function '${lambdaFunctionResource.physicalName}'`,
            // add Version here if we're publishing a new one
            ...(lambdaFunctionResource.publishVersion ? [`Lambda Version for Function '${lambdaFunctionResource.physicalName}'`] : []),
            // add any Aliases that we are hotswapping here
            ...lambdaFunctionResource.aliasesNames.map(alias => `Lambda Alias '${alias}' for Function '${lambdaFunctionResource.physicalName}'`),
        ];
    }
    async apply(sdk) {
        const lambda = sdk.lambda();
        const resource = this.lambdaFunctionResource.resource;
        const operations = [];
        if (resource.code !== undefined) {
            const updateFunctionCodeResponse = await lambda.updateFunctionCode({
                FunctionName: this.lambdaFunctionResource.physicalName,
                S3Bucket: resource.code.s3Bucket,
                S3Key: resource.code.s3Key,
                ImageUri: resource.code.imageUri,
                ZipFile: resource.code.functionCodeZip,
            }).promise();
            await this.waitForLambdasCodeUpdateToFinish(updateFunctionCodeResponse, lambda);
            // only if the code changed is there any point in publishing a new Version
            if (this.lambdaFunctionResource.publishVersion) {
                const publishVersionPromise = lambda.publishVersion({
                    FunctionName: this.lambdaFunctionResource.physicalName,
                }).promise();
                if (this.lambdaFunctionResource.aliasesNames.length > 0) {
                    // we need to wait for the Version to finish publishing
                    const versionUpdate = await publishVersionPromise;
                    for (const alias of this.lambdaFunctionResource.aliasesNames) {
                        operations.push(lambda.updateAlias({
                            FunctionName: this.lambdaFunctionResource.physicalName,
                            Name: alias,
                            FunctionVersion: versionUpdate.Version,
                        }).promise());
                    }
                }
                else {
                    operations.push(publishVersionPromise);
                }
            }
        }
        if (resource.tags !== undefined) {
            const tagsToDelete = Object.entries(resource.tags.tagUpdates)
                .filter(([_key, val]) => val === TagDeletion.DELETE)
                .map(([key, _val]) => key);
            const tagsToSet = {};
            Object.entries(resource.tags.tagUpdates)
                .filter(([_key, val]) => val !== TagDeletion.DELETE)
                .forEach(([tagName, tagValue]) => {
                tagsToSet[tagName] = tagValue;
            });
            if (tagsToDelete.length > 0) {
                operations.push(lambda.untagResource({
                    Resource: this.lambdaFunctionResource.functionArn,
                    TagKeys: tagsToDelete,
                }).promise());
            }
            if (Object.keys(tagsToSet).length > 0) {
                operations.push(lambda.tagResource({
                    Resource: this.lambdaFunctionResource.functionArn,
                    Tags: tagsToSet,
                }).promise());
            }
        }
        // run all of our updates in parallel
        return Promise.all(operations);
    }
    /**
     * After a Lambda Function is updated, it cannot be updated again until the
     * `State=Active` and the `LastUpdateStatus=Successful`.
     *
     * Depending on the configuration of the Lambda Function this could happen relatively quickly
     * or very slowly. For example, Zip based functions _not_ in a VPC can take ~1 second whereas VPC
     * or Container functions can take ~25 seconds (and 'idle' VPC functions can take minutes).
     */
    async waitForLambdasCodeUpdateToFinish(currentFunctionConfiguration, lambda) {
        var _a;
        const functionIsInVpcOrUsesDockerForCode = ((_a = currentFunctionConfiguration.VpcConfig) === null || _a === void 0 ? void 0 : _a.VpcId) ||
            currentFunctionConfiguration.PackageType === 'Image';
        // if the function is deployed in a VPC or if it is a container image function
        // then the update will take much longer and we can wait longer between checks
        // otherwise, the update will be quick, so a 1-second delay is fine
        const delaySeconds = functionIsInVpcOrUsesDockerForCode ? 5 : 1;
        // configure a custom waiter to wait for the function update to complete
        lambda.api.waiters.updateFunctionCodeToFinish = {
            name: 'UpdateFunctionCodeToFinish',
            operation: 'getFunction',
            // equates to 1 minute for zip function not in a VPC and
            // 5 minutes for container functions or function in a VPC
            maxAttempts: 60,
            delay: delaySeconds,
            acceptors: [
                {
                    matcher: 'path',
                    argument: "Configuration.LastUpdateStatus == 'Successful' && Configuration.State == 'Active'",
                    expected: true,
                    state: 'success',
                },
                {
                    matcher: 'path',
                    argument: 'Configuration.LastUpdateStatus',
                    expected: 'Failed',
                    state: 'failure',
                },
            ],
        };
        const updateFunctionCodeWaiter = new AWS.ResourceWaiter(lambda, 'updateFunctionCodeToFinish');
        await updateFunctionCodeWaiter.wait({
            FunctionName: this.lambdaFunctionResource.physicalName,
        }).promise();
    }
}
/**
 * Compress a string as a file, returning a promise for the zip buffer
 * https://github.com/archiverjs/node-archiver/issues/342
 */
function zipString(fileName, rawString) {
    return new Promise((resolve, reject) => {
        const buffers = [];
        const converter = new stream_1.Writable();
        converter._write = (chunk, _, callback) => {
            buffers.push(chunk);
            process.nextTick(callback);
        };
        converter.on('finish', () => {
            resolve(Buffer.concat(buffers));
        });
        const archive = archiver('zip');
        archive.on('error', (err) => {
            reject(err);
        });
        archive.pipe(converter);
        archive.append(rawString, {
            name: fileName,
            date: new Date('1980-01-01T00:00:00.000Z'),
        });
        void archive.finalize();
    });
}
/**
 * Get file extension from Lambda runtime string.
 * We use this extension to create a deployment package from Lambda inline code.
 */
function determineCodeFileExtFromRuntime(runtime) {
    if (runtime.startsWith('node')) {
        return 'js';
    }
    if (runtime.startsWith('python')) {
        return 'py';
    }
    // Currently inline code only supports Node.js and Python, ignoring other runtimes.
    // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#aws-properties-lambda-function-code-properties
    throw new evaluate_cloudformation_template_1.CfnEvaluationException(`runtime ${runtime} is unsupported, only node.js and python runtimes are currently supported.`);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWtDO0FBQ2xDLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0IscUNBQXFDO0FBRXJDLDBGQUE2RztBQUM3RyxxQ0FBbUg7QUFFbkg7Ozs7O0dBS0c7QUFDSSxLQUFLLFVBQVUsa0NBQWtDLENBQ3RELFNBQWlCLEVBQUUsTUFBbUMsRUFBRSxtQkFBbUQ7O0lBRTNHLHlDQUF5QztJQUN6QyxzREFBc0Q7SUFDdEQsNkdBQTZHO0lBQzdHLDBFQUEwRTtJQUMxRSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLHNCQUFzQixFQUFFO1FBQ25ELE9BQU8sNEJBQW1CLENBQUMsVUFBVSxDQUFDO0tBQ3ZDO0lBRUQsa0NBQWtDO0lBQ2xDLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssb0JBQW9CLEVBQUU7UUFDakQsT0FBTyw4QkFBOEIsQ0FBQyxNQUFNLENBQUMsQ0FBQztLQUMvQztJQUVELE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSw4QkFBOEIsQ0FBQyxNQUFNLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUMzRixJQUFJLE9BQU8sZ0JBQWdCLEtBQUssUUFBUSxFQUFFO1FBQ3hDLE9BQU8sZ0JBQWdCLENBQUM7S0FDekI7SUFFRCxNQUFNLFlBQVksR0FBRyxNQUFNLG1CQUFtQixDQUFDLDZCQUE2QixDQUFDLFNBQVMsUUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsMENBQUUsWUFBWSxDQUFDLENBQUM7SUFDbEksSUFBSSxDQUFDLFlBQVksRUFBRTtRQUNqQixPQUFPLDRCQUFtQixDQUFDLHdCQUF3QixDQUFDO0tBQ3JEO0lBRUQsTUFBTSxXQUFXLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQztRQUNsRSxTQUFTLEVBQUUseUVBQXlFLEdBQUcsWUFBWTtLQUNwRyxDQUFDLENBQUM7SUFFSCx3REFBd0Q7SUFDeEQsTUFBTSwyQkFBMkIsR0FBRyxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUM7U0FDaEYsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxzQkFBc0IsQ0FBQyxDQUFDO0lBQ2xELDREQUE0RDtJQUM1RCxNQUFNLDBCQUEwQixHQUFHLGNBQU8sQ0FBQywyQkFBMkIsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUMxRSxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztJQUNyRCxNQUFNLFlBQVksR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQ3hFLE9BQUEsbUJBQW1CLENBQUMscUJBQXFCLE9BQUMsQ0FBQyxDQUFDLFVBQVUsMENBQUUsSUFBSSxDQUFDLENBQUEsRUFBQSxDQUFDLENBQUMsQ0FBQztJQUVsRSxPQUFPLElBQUksOEJBQThCLENBQUM7UUFDeEMsWUFBWSxFQUFFLFlBQVk7UUFDMUIsV0FBVyxFQUFFLFdBQVc7UUFDeEIsUUFBUSxFQUFFLGdCQUFnQjtRQUMxQixjQUFjLEVBQUUsMkJBQTJCLENBQUMsTUFBTSxHQUFHLENBQUM7UUFDdEQsWUFBWTtLQUNiLENBQUMsQ0FBQztBQUNMLENBQUM7QUE5Q0QsZ0ZBOENDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBUyw4QkFBOEIsQ0FBQyxNQUFtQztJQUN6RSxLQUFLLE1BQU0sZUFBZSxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUU7UUFDcEQsSUFBSSxlQUFlLEtBQUssaUJBQWlCLEVBQUU7WUFDekMsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQztTQUNyRDtLQUNGO0lBQ0QsT0FBTyw0QkFBbUIsQ0FBQyxVQUFVLENBQUM7QUFDeEMsQ0FBQztBQUVEOzs7Ozs7OztHQVFHO0FBQ0gsS0FBSyxVQUFVLDhCQUE4QixDQUMzQyxNQUFtQyxFQUFFLG1CQUFtRDs7SUFFeEYsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7SUFDN0MsSUFBSSxlQUFlLEtBQUssdUJBQXVCLEVBQUU7UUFDL0MsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQztLQUNyRDtJQUVEOzs7Ozs7Ozs7O09BVUc7SUFDSCxNQUFNLGVBQWUsR0FBRyxNQUFNLENBQUMsZUFBZSxDQUFDO0lBQy9DLElBQUksSUFBSSxHQUFtQyxTQUFTLENBQUM7SUFDckQsSUFBSSxJQUFJLEdBQW1DLFNBQVMsQ0FBQztJQUVyRCxLQUFLLE1BQU0sZUFBZSxJQUFJLGVBQWUsRUFBRTtRQUM3QyxNQUFNLFdBQVcsR0FBRyxlQUFlLENBQUMsZUFBZSxDQUFDLENBQUM7UUFFckQsUUFBUSxlQUFlLEVBQUU7WUFDdkIsS0FBSyxNQUFNO2dCQUNULElBQUksbUJBQW1CLEdBQUcsS0FBSyxDQUFDO2dCQUNoQyxJQUFJLFFBQVEsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLGVBQWUsQ0FBQztnQkFFL0MsS0FBSyxNQUFNLFdBQVcsSUFBSSxXQUFXLENBQUMsUUFBUSxFQUFFO29CQUM5QyxRQUFRLFdBQVcsRUFBRTt3QkFDbkIsS0FBSyxVQUFVOzRCQUNiLG1CQUFtQixHQUFHLElBQUksQ0FBQzs0QkFDM0IsUUFBUSxHQUFHLE1BQU0sbUJBQW1CLENBQUMscUJBQXFCLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDOzRCQUM5RixNQUFNO3dCQUNSLEtBQUssT0FBTzs0QkFDVixtQkFBbUIsR0FBRyxJQUFJLENBQUM7NEJBQzNCLEtBQUssR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQzs0QkFDM0YsTUFBTTt3QkFDUixLQUFLLFVBQVU7NEJBQ2IsbUJBQW1CLEdBQUcsSUFBSSxDQUFDOzRCQUMzQixRQUFRLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUM7NEJBQzlGLE1BQU07d0JBQ1IsS0FBSyxTQUFTOzRCQUNaLG1CQUFtQixHQUFHLElBQUksQ0FBQzs0QkFDM0Isc0VBQXNFOzRCQUN0RSxNQUFNLFlBQVksR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDLFdBQVcsQ0FBQyxRQUFRLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQzs0QkFDeEcsTUFBTSxlQUFlLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxxQkFBcUIsT0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLFVBQVUsMENBQUUsT0FBTyxDQUFDLENBQUM7NEJBQzdHLElBQUksQ0FBQyxlQUFlLEVBQUU7Z0NBQ3BCLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7NkJBQ3JEOzRCQUNELHlEQUF5RDs0QkFDekQsTUFBTSxXQUFXLEdBQUcsK0JBQStCLENBQUMsZUFBZSxDQUFDLENBQUM7NEJBQ3JFLGVBQWUsR0FBRyxNQUFNLFNBQVMsQ0FBQyxTQUFTLFdBQVcsRUFBRSxFQUFFLFlBQVksQ0FBQyxDQUFDOzRCQUN4RSxNQUFNO3dCQUNSOzRCQUNFLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7cUJBQ3ZEO2lCQUNGO2dCQUNELElBQUksbUJBQW1CLEVBQUU7b0JBQ3ZCLElBQUksR0FBRzt3QkFDTCxRQUFRO3dCQUNSLEtBQUs7d0JBQ0wsUUFBUTt3QkFDUixlQUFlO3FCQUNoQixDQUFDO2lCQUNIO2dCQUNELE1BQU07WUFDUixLQUFLLE1BQU07Z0JBQ1Q7OzttQkFHRztnQkFDSCxNQUFNLFVBQVUsR0FBNEMsRUFBRSxDQUFDO2dCQUMvRCxJQUFJLFdBQVcsYUFBWCxXQUFXLHVCQUFYLFdBQVcsQ0FBRSxXQUFXLEVBQUU7b0JBQzVCLFdBQVcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBb0IsRUFBRSxFQUFFO3dCQUNwRCxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUM7b0JBQ2xDLENBQUMsQ0FBQyxDQUFDO29CQUVILFdBQVcsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBb0IsRUFBRSxFQUFFO3dCQUNwRCxJQUFJLFVBQVUsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssU0FBUyxFQUFFOzRCQUNyQyxVQUFVLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxNQUFNLENBQUM7eUJBQzFDO29CQUNILENBQUMsQ0FBQyxDQUFDO29CQUVILElBQUksR0FBRyxFQUFFLFVBQVUsRUFBRSxDQUFDO2lCQUN2QjtnQkFDRCxNQUFNO1lBQ1I7Z0JBQ0UsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQztTQUN2RDtLQUNGO0lBRUQsT0FBTyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUMsNEJBQW1CLENBQUMsVUFBVSxDQUFDO0FBQ3hFLENBQUM7QUFjRCxJQUFLLFdBRUo7QUFGRCxXQUFLLFdBQVc7SUFDZCxrREFBVyxDQUFBO0FBQ2IsQ0FBQyxFQUZJLFdBQVcsS0FBWCxXQUFXLFFBRWY7QUFtQkQsTUFBTSw4QkFBOEI7SUFJbEMsWUFBNkIsc0JBQThDO1FBQTlDLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFIM0QsWUFBTyxHQUFHLGlCQUFpQixDQUFDO1FBSTFDLElBQUksQ0FBQyxhQUFhLEdBQUc7WUFDbkIsb0JBQW9CLHNCQUFzQixDQUFDLFlBQVksR0FBRztZQUMxRCxpREFBaUQ7WUFDakQsR0FBRyxDQUFDLHNCQUFzQixDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxnQ0FBZ0Msc0JBQXNCLENBQUMsWUFBWSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO1lBQzFILCtDQUErQztZQUMvQyxHQUFHLHNCQUFzQixDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxpQkFBaUIsS0FBSyxtQkFBbUIsc0JBQXNCLENBQUMsWUFBWSxHQUFHLENBQUM7U0FDckksQ0FBQztJQUNKLENBQUM7SUFFTSxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQVM7UUFDMUIsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBQzVCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxRQUFRLENBQUM7UUFDdEQsTUFBTSxVQUFVLEdBQW1CLEVBQUUsQ0FBQztRQUV0QyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQy9CLE1BQU0sMEJBQTBCLEdBQUcsTUFBTSxNQUFNLENBQUMsa0JBQWtCLENBQUM7Z0JBQ2pFLFlBQVksRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsWUFBWTtnQkFDdEQsUUFBUSxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUTtnQkFDaEMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSztnQkFDMUIsUUFBUSxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUTtnQkFDaEMsT0FBTyxFQUFFLFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZTthQUN2QyxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7WUFFYixNQUFNLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQywwQkFBMEIsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUVoRiwwRUFBMEU7WUFDMUUsSUFBSSxJQUFJLENBQUMsc0JBQXNCLENBQUMsY0FBYyxFQUFFO2dCQUM5QyxNQUFNLHFCQUFxQixHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUM7b0JBQ2xELFlBQVksRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsWUFBWTtpQkFDdkQsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUViLElBQUksSUFBSSxDQUFDLHNCQUFzQixDQUFDLFlBQVksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO29CQUN2RCx1REFBdUQ7b0JBQ3ZELE1BQU0sYUFBYSxHQUFHLE1BQU0scUJBQXFCLENBQUM7b0JBRWxELEtBQUssTUFBTSxLQUFLLElBQUksSUFBSSxDQUFDLHNCQUFzQixDQUFDLFlBQVksRUFBRTt3QkFDNUQsVUFBVSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDOzRCQUNqQyxZQUFZLEVBQUUsSUFBSSxDQUFDLHNCQUFzQixDQUFDLFlBQVk7NEJBQ3RELElBQUksRUFBRSxLQUFLOzRCQUNYLGVBQWUsRUFBRSxhQUFhLENBQUMsT0FBTzt5QkFDdkMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7cUJBQ2Y7aUJBQ0Y7cUJBQU07b0JBQ0wsVUFBVSxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO2lCQUN4QzthQUNGO1NBQ0Y7UUFFRCxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssU0FBUyxFQUFFO1lBQy9CLE1BQU0sWUFBWSxHQUFhLE1BQU0sQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7aUJBQ3BFLE1BQU0sQ0FBQyxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLEtBQUssV0FBVyxDQUFDLE1BQU0sQ0FBQztpQkFDbkQsR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1lBRTdCLE1BQU0sU0FBUyxHQUE4QixFQUFFLENBQUM7WUFDaEQsTUFBTSxDQUFDLE9BQU8sQ0FBQyxRQUFRLENBQUMsSUFBSyxDQUFDLFVBQVUsQ0FBQztpQkFDdEMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLEVBQUUsRUFBRSxDQUFDLEdBQUcsS0FBSyxXQUFXLENBQUMsTUFBTSxDQUFDO2lCQUNuRCxPQUFPLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsRUFBRSxFQUFFO2dCQUMvQixTQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsUUFBa0IsQ0FBQztZQUMxQyxDQUFDLENBQUMsQ0FBQztZQUVMLElBQUksWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7Z0JBQzNCLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQztvQkFDbkMsUUFBUSxFQUFFLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxXQUFXO29CQUNqRCxPQUFPLEVBQUUsWUFBWTtpQkFDdEIsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7YUFDZjtZQUVELElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUNyQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUM7b0JBQ2pDLFFBQVEsRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsV0FBVztvQkFDakQsSUFBSSxFQUFFLFNBQVM7aUJBQ2hCLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO2FBQ2Y7U0FDRjtRQUVELHFDQUFxQztRQUNyQyxPQUFPLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDakMsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSyxLQUFLLENBQUMsZ0NBQWdDLENBQUMsNEJBQThELEVBQUUsTUFBa0I7O1FBQy9ILE1BQU0sa0NBQWtDLEdBQUcsT0FBQSw0QkFBNEIsQ0FBQyxTQUFTLDBDQUFFLEtBQUs7WUFDcEYsNEJBQTRCLENBQUMsV0FBVyxLQUFLLE9BQU8sQ0FBQztRQUV6RCw4RUFBOEU7UUFDOUUsOEVBQThFO1FBQzlFLG1FQUFtRTtRQUNuRSxNQUFNLFlBQVksR0FBRyxrQ0FBa0MsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFaEUsd0VBQXdFO1FBQ3ZFLE1BQWMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLDBCQUEwQixHQUFHO1lBQ3ZELElBQUksRUFBRSw0QkFBNEI7WUFDbEMsU0FBUyxFQUFFLGFBQWE7WUFDeEIsd0RBQXdEO1lBQ3hELHlEQUF5RDtZQUN6RCxXQUFXLEVBQUUsRUFBRTtZQUNmLEtBQUssRUFBRSxZQUFZO1lBQ25CLFNBQVMsRUFBRTtnQkFDVDtvQkFDRSxPQUFPLEVBQUUsTUFBTTtvQkFDZixRQUFRLEVBQUUsbUZBQW1GO29CQUM3RixRQUFRLEVBQUUsSUFBSTtvQkFDZCxLQUFLLEVBQUUsU0FBUztpQkFDakI7Z0JBQ0Q7b0JBQ0UsT0FBTyxFQUFFLE1BQU07b0JBQ2YsUUFBUSxFQUFFLGdDQUFnQztvQkFDMUMsUUFBUSxFQUFFLFFBQVE7b0JBQ2xCLEtBQUssRUFBRSxTQUFTO2lCQUNqQjthQUNGO1NBQ0YsQ0FBQztRQUVGLE1BQU0sd0JBQXdCLEdBQUcsSUFBSyxHQUFXLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSw0QkFBNEIsQ0FBQyxDQUFDO1FBQ3ZHLE1BQU0sd0JBQXdCLENBQUMsSUFBSSxDQUFDO1lBQ2xDLFlBQVksRUFBRSxJQUFJLENBQUMsc0JBQXNCLENBQUMsWUFBWTtTQUN2RCxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLFNBQVMsQ0FBQyxRQUFnQixFQUFFLFNBQWlCO0lBQ3BELE9BQU8sSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLEVBQUU7UUFDckMsTUFBTSxPQUFPLEdBQWEsRUFBRSxDQUFDO1FBRTdCLE1BQU0sU0FBUyxHQUFHLElBQUksaUJBQVEsRUFBRSxDQUFDO1FBRWpDLFNBQVMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxLQUFhLEVBQUUsQ0FBUyxFQUFFLFFBQW9CLEVBQUUsRUFBRTtZQUNwRSxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQ3BCLE9BQU8sQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDN0IsQ0FBQyxDQUFDO1FBRUYsU0FBUyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFO1lBQzFCLE9BQU8sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7UUFDbEMsQ0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFaEMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUMxQixNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztRQUVILE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFFeEIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxTQUFTLEVBQUU7WUFDeEIsSUFBSSxFQUFFLFFBQVE7WUFDZCxJQUFJLEVBQUUsSUFBSSxJQUFJLENBQUMsMEJBQTBCLENBQUM7U0FDM0MsQ0FBQyxDQUFDO1FBRUgsS0FBSyxPQUFPLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDMUIsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBUywrQkFBK0IsQ0FBQyxPQUFlO0lBQ3RELElBQUksT0FBTyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUM5QixPQUFPLElBQUksQ0FBQztLQUNiO0lBQ0QsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQ2hDLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxtRkFBbUY7SUFDbkYseUpBQXlKO0lBQ3pKLE1BQU0sSUFBSSx5REFBc0IsQ0FBQyxXQUFXLE9BQU8sNEVBQTRFLENBQUMsQ0FBQztBQUNuSSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV3JpdGFibGUgfSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0ICogYXMgYXJjaGl2ZXIgZnJvbSAnYXJjaGl2ZXInO1xuaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgZmxhdE1hcCB9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcbmltcG9ydCB7IENmbkV2YWx1YXRpb25FeGNlcHRpb24sIEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSB9IGZyb20gJy4uL2V2YWx1YXRlLWNsb3VkZm9ybWF0aW9uLXRlbXBsYXRlJztcbmltcG9ydCB7IENoYW5nZUhvdHN3YXBJbXBhY3QsIENoYW5nZUhvdHN3YXBSZXN1bHQsIEhvdHN3YXBPcGVyYXRpb24sIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB9IGZyb20gJy4vY29tbW9uJztcblxuLyoqXG4gKiBSZXR1cm5zIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVGAgaWYgdGhlIGNoYW5nZSBjYW5ub3QgYmUgc2hvcnQtY2lyY3VpdGVkLFxuICogYENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVGAgaWYgdGhlIGNoYW5nZSBpcyBpcnJlbGV2YW50IGZyb20gYSBzaG9ydC1jaXJjdWl0IHBlcnNwZWN0aXZlXG4gKiAobGlrZSBhIGNoYW5nZSB0byBDREtNZXRhZGF0YSksXG4gKiBvciBhIExhbWJkYUZ1bmN0aW9uUmVzb3VyY2UgaWYgdGhlIGNoYW5nZSBjYW4gYmUgc2hvcnQtY2lyY3VpdGVkLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNIb3Rzd2FwcGFibGVMYW1iZGFGdW5jdGlvbkNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgLy8gaWYgdGhlIGNoYW5nZSBpcyBmb3IgYSBMYW1iZGEgVmVyc2lvbixcbiAgLy8gaWdub3JlIGl0IGJ5IHJldHVybmluZyBhbiBlbXB0eSBob3Rzd2FwIG9wZXJhdGlvbiAtXG4gIC8vIHdlIHdpbGwgcHVibGlzaCBhIG5ldyB2ZXJzaW9uIHdoZW4gd2UgZ2V0IHRvIGhvdHN3YXBwaW5nIHRoZSBhY3R1YWwgRnVuY3Rpb24gdGhpcyBWZXJzaW9uIHBvaW50cyB0bywgYmVsb3dcbiAgLy8gKFZlcnNpb25zIGNhbid0IGJlIGNoYW5nZWQgaW4gQ2xvdWRGb3JtYXRpb24gYW55d2F5LCB0aGV5J3JlIGltbXV0YWJsZSlcbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlID09PSAnQVdTOjpMYW1iZGE6OlZlcnNpb24nKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVDtcbiAgfVxuXG4gIC8vIHdlIGhhbmRsZSBBbGlhc2VzIHNwZWNpYWxseSB0b29cbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlID09PSAnQVdTOjpMYW1iZGE6OkFsaWFzJykge1xuICAgIHJldHVybiBjaGVja0FsaWFzSGFzVmVyc2lvbk9ubHlDaGFuZ2UoY2hhbmdlKTtcbiAgfVxuXG4gIGNvbnN0IGxhbWJkYUNvZGVDaGFuZ2UgPSBhd2FpdCBpc0xhbWJkYUZ1bmN0aW9uQ29kZU9ubHlDaGFuZ2UoY2hhbmdlLCBldmFsdWF0ZUNmblRlbXBsYXRlKTtcbiAgaWYgKHR5cGVvZiBsYW1iZGFDb2RlQ2hhbmdlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBsYW1iZGFDb2RlQ2hhbmdlO1xuICB9XG5cbiAgY29uc3QgZnVuY3Rpb25OYW1lID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5lc3RhYmxpc2hSZXNvdXJjZVBoeXNpY2FsTmFtZShsb2dpY2FsSWQsIGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzPy5GdW5jdGlvbk5hbWUpO1xuICBpZiAoIWZ1bmN0aW9uTmFtZSkge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIGNvbnN0IGZ1bmN0aW9uQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oe1xuICAgICdGbjo6U3ViJzogJ2Fybjoke0FXUzo6UGFydGl0aW9ufTpsYW1iZGE6JHtBV1M6OlJlZ2lvbn06JHtBV1M6OkFjY291bnRJZH06ZnVuY3Rpb246JyArIGZ1bmN0aW9uTmFtZSxcbiAgfSk7XG5cbiAgLy8gZmluZCBhbGwgTGFtYmRhIFZlcnNpb25zIHRoYXQgcmVmZXJlbmNlIHRoaXMgRnVuY3Rpb25cbiAgY29uc3QgdmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uID0gZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUmVmZXJlbmNlc1RvKGxvZ2ljYWxJZClcbiAgICAuZmlsdGVyKHIgPT4gci5UeXBlID09PSAnQVdTOjpMYW1iZGE6OlZlcnNpb24nKTtcbiAgLy8gZmluZCBhbGwgTGFtYmRhIEFsaWFzZXMgdGhhdCByZWZlcmVuY2UgdGhlIGFib3ZlIFZlcnNpb25zXG4gIGNvbnN0IGFsaWFzZXNSZWZlcmVuY2luZ1ZlcnNpb25zID0gZmxhdE1hcCh2ZXJzaW9uc1JlZmVyZW5jaW5nRnVuY3Rpb24sIHYgPT5cbiAgICBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRSZWZlcmVuY2VzVG8odi5Mb2dpY2FsSWQpKTtcbiAgY29uc3QgYWxpYXNlc05hbWVzID0gYXdhaXQgUHJvbWlzZS5hbGwoYWxpYXNlc1JlZmVyZW5jaW5nVmVyc2lvbnMubWFwKGEgPT5cbiAgICBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbihhLlByb3BlcnRpZXM/Lk5hbWUpKSk7XG5cbiAgcmV0dXJuIG5ldyBMYW1iZGFGdW5jdGlvbkhvdHN3YXBPcGVyYXRpb24oe1xuICAgIHBoeXNpY2FsTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgIGZ1bmN0aW9uQXJuOiBmdW5jdGlvbkFybixcbiAgICByZXNvdXJjZTogbGFtYmRhQ29kZUNoYW5nZSxcbiAgICBwdWJsaXNoVmVyc2lvbjogdmVyc2lvbnNSZWZlcmVuY2luZ0Z1bmN0aW9uLmxlbmd0aCA+IDAsXG4gICAgYWxpYXNlc05hbWVzLFxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zICBpcyBhIGdpdmVuIEFsaWFzIGNoYW5nZSBpcyBvbmx5IGluIHRoZSAnRnVuY3Rpb25WZXJzaW9uJyBwcm9wZXJ0eSxcbiAqIGFuZCBgQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlRgIGlzIHRoZSBjaGFuZ2UgaXMgZm9yIGFueSBvdGhlciBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gY2hlY2tBbGlhc0hhc1ZlcnNpb25Pbmx5Q2hhbmdlKGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlKTogQ2hhbmdlSG90c3dhcFJlc3VsdCB7XG4gIGZvciAoY29uc3QgdXBkYXRlZFByb3BOYW1lIGluIGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpIHtcbiAgICBpZiAodXBkYXRlZFByb3BOYW1lICE9PSAnRnVuY3Rpb25WZXJzaW9uJykge1xuICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UO1xufVxuXG4vKipcbiAqIFJldHVybnMgYENoYW5nZUhvdHN3YXBJbXBhY3QuSVJSRUxFVkFOVGAgaWYgdGhlIGNoYW5nZSBpcyBub3QgZm9yIGEgQVdTOjpMYW1iZGE6OkZ1bmN0aW9uLFxuICogYnV0IGRvZXNuJ3QgcHJldmVudCBzaG9ydC1jaXJjdWl0aW5nXG4gKiAobGlrZSBhIGNoYW5nZSB0byBDREtNZXRhZGF0YSByZXNvdXJjZSksXG4gKiBgQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlRgIGlmIHRoZSBjaGFuZ2UgaXMgdG8gYSBBV1M6OkxhbWJkYTo6RnVuY3Rpb24sXG4gKiBidXQgbm90IG9ubHkgdG8gaXRzIENvZGUgcHJvcGVydHksXG4gKiBvciBhIExhbWJkYUZ1bmN0aW9uQ29kZSBpZiB0aGUgY2hhbmdlIGlzIHRvIGEgQVdTOjpMYW1iZGE6OkZ1bmN0aW9uLFxuICogYW5kIG9ubHkgYWZmZWN0cyBpdHMgQ29kZSBwcm9wZXJ0eS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaXNMYW1iZGFGdW5jdGlvbkNvZGVPbmx5Q2hhbmdlKFxuICBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxMYW1iZGFGdW5jdGlvbkNoYW5nZSB8IENoYW5nZUhvdHN3YXBJbXBhY3Q+IHtcbiAgY29uc3QgbmV3UmVzb3VyY2VUeXBlID0gY2hhbmdlLm5ld1ZhbHVlLlR5cGU7XG4gIGlmIChuZXdSZXNvdXJjZVR5cGUgIT09ICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgLypcbiAgICogQXQgZmlyc3QgZ2xhbmNlLCB3ZSB3b3VsZCB3YW50IHRvIGluaXRpYWxpemUgdGhlc2UgdXNpbmcgdGhlIFwicHJldmlvdXNcIiB2YWx1ZXMgKGNoYW5nZS5vbGRWYWx1ZSksXG4gICAqIGluIGNhc2Ugb25seSBvbmUgb2YgdGhlbSBjaGFuZ2VkLCBsaWtlIHRoZSBrZXksIGFuZCB0aGUgQnVja2V0IHN0YXllZCB0aGUgc2FtZS5cbiAgICogSG93ZXZlciwgdGhhdCBhY3R1YWxseSBmYWlscyBmb3Igb2xkLXN0eWxlIHN5bnRoZXNpcywgd2hpY2ggdXNlcyBDRk4gUGFyYW1ldGVycyFcbiAgICogQmVjYXVzZSB0aGUgbmFtZXMgb2YgdGhlIFBhcmFtZXRlcnMgZGVwZW5kIG9uIHRoZSBoYXNoIG9mIHRoZSBBc3NldCxcbiAgICogdGhlIFBhcmFtZXRlcnMgdXNlZCBmb3IgdGhlIFwib2xkXCIgdmFsdWVzIG5vIGxvbmdlciBleGlzdCBpbiBgYXNzZXRQYXJhbXNgIGF0IHRoaXMgcG9pbnQsXG4gICAqIHdoaWNoIG1lYW5zIHdlIGRvbid0IGhhdmUgdGhlIGNvcnJlY3QgdmFsdWVzIGF2YWlsYWJsZSB0byBldmFsdWF0ZSB0aGUgQ0ZOIGV4cHJlc3Npb24gd2l0aC5cbiAgICogRm9ydHVuYXRlbHksIHRoZSBkaWZmIHdpbGwgYWx3YXlzIGluY2x1ZGUgYm90aCB0aGUgczNCdWNrZXQgYW5kIHMzS2V5IHBhcnRzIG9mIHRoZSBMYW1iZGEncyBDb2RlIHByb3BlcnR5LFxuICAgKiBldmVuIGlmIG9ubHkgb25lIG9mIHRoZW0gd2FzIGFjdHVhbGx5IGNoYW5nZWQsXG4gICAqIHdoaWNoIG1lYW5zIHdlIGRvbid0IG5lZWQgdGhlIFwib2xkXCIgdmFsdWVzIGF0IGFsbCwgYW5kIHdlIGNhbiBzYWZlbHkgaW5pdGlhbGl6ZSB0aGVzZSB3aXRoIGp1c3QgYCcnYC5cbiAgICovXG4gIGNvbnN0IHByb3BlcnR5VXBkYXRlcyA9IGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXM7XG4gIGxldCBjb2RlOiBMYW1iZGFGdW5jdGlvbkNvZGUgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGxldCB0YWdzOiBMYW1iZGFGdW5jdGlvblRhZ3MgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgZm9yIChjb25zdCB1cGRhdGVkUHJvcE5hbWUgaW4gcHJvcGVydHlVcGRhdGVzKSB7XG4gICAgY29uc3QgdXBkYXRlZFByb3AgPSBwcm9wZXJ0eVVwZGF0ZXNbdXBkYXRlZFByb3BOYW1lXTtcblxuICAgIHN3aXRjaCAodXBkYXRlZFByb3BOYW1lKSB7XG4gICAgICBjYXNlICdDb2RlJzpcbiAgICAgICAgbGV0IGZvdW5kQ29kZURpZmZlcmVuY2UgPSBmYWxzZTtcbiAgICAgICAgbGV0IHMzQnVja2V0LCBzM0tleSwgaW1hZ2VVcmksIGZ1bmN0aW9uQ29kZVppcDtcblxuICAgICAgICBmb3IgKGNvbnN0IG5ld1Byb3BOYW1lIGluIHVwZGF0ZWRQcm9wLm5ld1ZhbHVlKSB7XG4gICAgICAgICAgc3dpdGNoIChuZXdQcm9wTmFtZSkge1xuICAgICAgICAgICAgY2FzZSAnUzNCdWNrZXQnOlxuICAgICAgICAgICAgICBmb3VuZENvZGVEaWZmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgczNCdWNrZXQgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1MzS2V5JzpcbiAgICAgICAgICAgICAgZm91bmRDb2RlRGlmZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgIHMzS2V5ID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdJbWFnZVVyaSc6XG4gICAgICAgICAgICAgIGZvdW5kQ29kZURpZmZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICBpbWFnZVVyaSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnWmlwRmlsZSc6XG4gICAgICAgICAgICAgIGZvdW5kQ29kZURpZmZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAvLyBXZSBtdXN0IGNyZWF0ZSBhIHppcCBwYWNrYWdlIGNvbnRhaW5pbmcgYSBmaWxlIHdpdGggdGhlIGlubGluZSBjb2RlXG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ29kZSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uUnVudGltZSA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKGNoYW5nZS5uZXdWYWx1ZS5Qcm9wZXJ0aWVzPy5SdW50aW1lKTtcbiAgICAgICAgICAgICAgaWYgKCFmdW5jdGlvblJ1bnRpbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gZmlsZSBleHRlbnNpb24gbXVzdCBiZSBjaG9zZW4gZGVwZW5kaW5nIG9uIHRoZSBydW50aW1lXG4gICAgICAgICAgICAgIGNvbnN0IGNvZGVGaWxlRXh0ID0gZGV0ZXJtaW5lQ29kZUZpbGVFeHRGcm9tUnVudGltZShmdW5jdGlvblJ1bnRpbWUpO1xuICAgICAgICAgICAgICBmdW5jdGlvbkNvZGVaaXAgPSBhd2FpdCB6aXBTdHJpbmcoYGluZGV4LiR7Y29kZUZpbGVFeHR9YCwgZnVuY3Rpb25Db2RlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3VuZENvZGVEaWZmZXJlbmNlKSB7XG4gICAgICAgICAgY29kZSA9IHtcbiAgICAgICAgICAgIHMzQnVja2V0LFxuICAgICAgICAgICAgczNLZXksXG4gICAgICAgICAgICBpbWFnZVVyaSxcbiAgICAgICAgICAgIGZ1bmN0aW9uQ29kZVppcCxcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVGFncyc6XG4gICAgICAgIC8qXG4gICAgICAgICAqIFRhZyB1cGRhdGVzIGFyZSBhIGJpdCBvZGQ7IHRoZXkgbWFuaWZlc3QgYXMgdHdvIGxpc3RzLCBhcmUgZmxhZ2dlZCBvbmx5IGFzXG4gICAgICAgICAqIGBpc0RpZmZlcmVudGAsIGFuZCB3ZSBoYXZlIHRvIHJlY29uY2lsZSB0aGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdGFnVXBkYXRlczogeyBbdGFnOiBzdHJpbmddOiBzdHJpbmcgfCBUYWdEZWxldGlvbiB9ID0ge307XG4gICAgICAgIGlmICh1cGRhdGVkUHJvcD8uaXNEaWZmZXJlbnQpIHtcbiAgICAgICAgICB1cGRhdGVkUHJvcC5uZXdWYWx1ZS5mb3JFYWNoKCh0YWc6IENmbkRpZmZUYWdWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGFnVXBkYXRlc1t0YWcuS2V5XSA9IHRhZy5WYWx1ZTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHVwZGF0ZWRQcm9wLm9sZFZhbHVlLmZvckVhY2goKHRhZzogQ2ZuRGlmZlRhZ1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFnVXBkYXRlc1t0YWcuS2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRhZ1VwZGF0ZXNbdGFnLktleV0gPSBUYWdEZWxldGlvbi5ERUxFVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB0YWdzID0geyB0YWdVcGRhdGVzIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNvZGUgfHwgdGFncyA/IHsgY29kZSwgdGFncyB9IDogQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UO1xufVxuXG5pbnRlcmZhY2UgQ2ZuRGlmZlRhZ1ZhbHVlIHtcbiAgcmVhZG9ubHkgS2V5OiBzdHJpbmc7XG4gIHJlYWRvbmx5IFZhbHVlOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvbkNvZGUge1xuICByZWFkb25seSBzM0J1Y2tldD86IHN0cmluZztcbiAgcmVhZG9ubHkgczNLZXk/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGltYWdlVXJpPzogc3RyaW5nO1xuICByZWFkb25seSBmdW5jdGlvbkNvZGVaaXA/OiBCdWZmZXI7XG59XG5cbmVudW0gVGFnRGVsZXRpb24ge1xuICBERUxFVEUgPSAtMSxcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uVGFncyB7XG4gIHJlYWRvbmx5IHRhZ1VwZGF0ZXM6IHsgW3RhZyA6IHN0cmluZ10gOiBzdHJpbmcgfCBUYWdEZWxldGlvbiB9O1xufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25DaGFuZ2Uge1xuICByZWFkb25seSBjb2RlPzogTGFtYmRhRnVuY3Rpb25Db2RlO1xuICByZWFkb25seSB0YWdzPzogTGFtYmRhRnVuY3Rpb25UYWdzO1xufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25SZXNvdXJjZSB7XG4gIHJlYWRvbmx5IHBoeXNpY2FsTmFtZTogc3RyaW5nO1xuICByZWFkb25seSBmdW5jdGlvbkFybjogc3RyaW5nO1xuICByZWFkb25seSByZXNvdXJjZTogTGFtYmRhRnVuY3Rpb25DaGFuZ2U7XG4gIHJlYWRvbmx5IHB1Ymxpc2hWZXJzaW9uOiBib29sZWFuO1xuICByZWFkb25seSBhbGlhc2VzTmFtZXM6IHN0cmluZ1tdO1xufVxuXG5jbGFzcyBMYW1iZGFGdW5jdGlvbkhvdHN3YXBPcGVyYXRpb24gaW1wbGVtZW50cyBIb3Rzd2FwT3BlcmF0aW9uIHtcbiAgcHVibGljIHJlYWRvbmx5IHNlcnZpY2UgPSAnbGFtYmRhLWZ1bmN0aW9uJztcbiAgcHVibGljIHJlYWRvbmx5IHJlc291cmNlTmFtZXM6IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgbGFtYmRhRnVuY3Rpb25SZXNvdXJjZTogTGFtYmRhRnVuY3Rpb25SZXNvdXJjZSkge1xuICAgIHRoaXMucmVzb3VyY2VOYW1lcyA9IFtcbiAgICAgIGBMYW1iZGEgRnVuY3Rpb24gJyR7bGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWV9J2AsXG4gICAgICAvLyBhZGQgVmVyc2lvbiBoZXJlIGlmIHdlJ3JlIHB1Ymxpc2hpbmcgYSBuZXcgb25lXG4gICAgICAuLi4obGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5wdWJsaXNoVmVyc2lvbiA/IFtgTGFtYmRhIFZlcnNpb24gZm9yIEZ1bmN0aW9uICcke2xhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lfSdgXSA6IFtdKSxcbiAgICAgIC8vIGFkZCBhbnkgQWxpYXNlcyB0aGF0IHdlIGFyZSBob3Rzd2FwcGluZyBoZXJlXG4gICAgICAuLi5sYW1iZGFGdW5jdGlvblJlc291cmNlLmFsaWFzZXNOYW1lcy5tYXAoYWxpYXMgPT4gYExhbWJkYSBBbGlhcyAnJHthbGlhc30nIGZvciBGdW5jdGlvbiAnJHtsYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZX0nYCksXG4gICAgXTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBhcHBseShzZGs6IElTREspOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IGxhbWJkYSA9IHNkay5sYW1iZGEoKTtcbiAgICBjb25zdCByZXNvdXJjZSA9IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5yZXNvdXJjZTtcbiAgICBjb25zdCBvcGVyYXRpb25zOiBQcm9taXNlPGFueT5bXSA9IFtdO1xuXG4gICAgaWYgKHJlc291cmNlLmNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdXBkYXRlRnVuY3Rpb25Db2RlUmVzcG9uc2UgPSBhd2FpdCBsYW1iZGEudXBkYXRlRnVuY3Rpb25Db2RlKHtcbiAgICAgICAgRnVuY3Rpb25OYW1lOiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lLFxuICAgICAgICBTM0J1Y2tldDogcmVzb3VyY2UuY29kZS5zM0J1Y2tldCxcbiAgICAgICAgUzNLZXk6IHJlc291cmNlLmNvZGUuczNLZXksXG4gICAgICAgIEltYWdlVXJpOiByZXNvdXJjZS5jb2RlLmltYWdlVXJpLFxuICAgICAgICBaaXBGaWxlOiByZXNvdXJjZS5jb2RlLmZ1bmN0aW9uQ29kZVppcCxcbiAgICAgIH0pLnByb21pc2UoKTtcblxuICAgICAgYXdhaXQgdGhpcy53YWl0Rm9yTGFtYmRhc0NvZGVVcGRhdGVUb0ZpbmlzaCh1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSwgbGFtYmRhKTtcblxuICAgICAgLy8gb25seSBpZiB0aGUgY29kZSBjaGFuZ2VkIGlzIHRoZXJlIGFueSBwb2ludCBpbiBwdWJsaXNoaW5nIGEgbmV3IFZlcnNpb25cbiAgICAgIGlmICh0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucHVibGlzaFZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgcHVibGlzaFZlcnNpb25Qcm9taXNlID0gbGFtYmRhLnB1Ymxpc2hWZXJzaW9uKHtcbiAgICAgICAgICBGdW5jdGlvbk5hbWU6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWUsXG4gICAgICAgIH0pLnByb21pc2UoKTtcblxuICAgICAgICBpZiAodGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmFsaWFzZXNOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgVmVyc2lvbiB0byBmaW5pc2ggcHVibGlzaGluZ1xuICAgICAgICAgIGNvbnN0IHZlcnNpb25VcGRhdGUgPSBhd2FpdCBwdWJsaXNoVmVyc2lvblByb21pc2U7XG5cbiAgICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIG9mIHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5hbGlhc2VzTmFtZXMpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChsYW1iZGEudXBkYXRlQWxpYXMoe1xuICAgICAgICAgICAgICBGdW5jdGlvbk5hbWU6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWUsXG4gICAgICAgICAgICAgIE5hbWU6IGFsaWFzLFxuICAgICAgICAgICAgICBGdW5jdGlvblZlcnNpb246IHZlcnNpb25VcGRhdGUuVmVyc2lvbixcbiAgICAgICAgICAgIH0pLnByb21pc2UoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wZXJhdGlvbnMucHVzaChwdWJsaXNoVmVyc2lvblByb21pc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlc291cmNlLnRhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgdGFnc1RvRGVsZXRlOiBzdHJpbmdbXSA9IE9iamVjdC5lbnRyaWVzKHJlc291cmNlLnRhZ3MudGFnVXBkYXRlcylcbiAgICAgICAgLmZpbHRlcigoW19rZXksIHZhbF0pID0+IHZhbCA9PT0gVGFnRGVsZXRpb24uREVMRVRFKVxuICAgICAgICAubWFwKChba2V5LCBfdmFsXSkgPT4ga2V5KTtcblxuICAgICAgY29uc3QgdGFnc1RvU2V0OiB7IFt0YWc6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgICBPYmplY3QuZW50cmllcyhyZXNvdXJjZS50YWdzIS50YWdVcGRhdGVzKVxuICAgICAgICAuZmlsdGVyKChbX2tleSwgdmFsXSkgPT4gdmFsICE9PSBUYWdEZWxldGlvbi5ERUxFVEUpXG4gICAgICAgIC5mb3JFYWNoKChbdGFnTmFtZSwgdGFnVmFsdWVdKSA9PiB7XG4gICAgICAgICAgdGFnc1RvU2V0W3RhZ05hbWVdID0gdGFnVmFsdWUgYXMgc3RyaW5nO1xuICAgICAgICB9KTtcblxuICAgICAgaWYgKHRhZ3NUb0RlbGV0ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIG9wZXJhdGlvbnMucHVzaChsYW1iZGEudW50YWdSZXNvdXJjZSh7XG4gICAgICAgICAgUmVzb3VyY2U6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5mdW5jdGlvbkFybixcbiAgICAgICAgICBUYWdLZXlzOiB0YWdzVG9EZWxldGUsXG4gICAgICAgIH0pLnByb21pc2UoKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChPYmplY3Qua2V5cyh0YWdzVG9TZXQpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhbWJkYS50YWdSZXNvdXJjZSh7XG4gICAgICAgICAgUmVzb3VyY2U6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5mdW5jdGlvbkFybixcbiAgICAgICAgICBUYWdzOiB0YWdzVG9TZXQsXG4gICAgICAgIH0pLnByb21pc2UoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcnVuIGFsbCBvZiBvdXIgdXBkYXRlcyBpbiBwYXJhbGxlbFxuICAgIHJldHVybiBQcm9taXNlLmFsbChvcGVyYXRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZnRlciBhIExhbWJkYSBGdW5jdGlvbiBpcyB1cGRhdGVkLCBpdCBjYW5ub3QgYmUgdXBkYXRlZCBhZ2FpbiB1bnRpbCB0aGVcbiAgICogYFN0YXRlPUFjdGl2ZWAgYW5kIHRoZSBgTGFzdFVwZGF0ZVN0YXR1cz1TdWNjZXNzZnVsYC5cbiAgICpcbiAgICogRGVwZW5kaW5nIG9uIHRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBMYW1iZGEgRnVuY3Rpb24gdGhpcyBjb3VsZCBoYXBwZW4gcmVsYXRpdmVseSBxdWlja2x5XG4gICAqIG9yIHZlcnkgc2xvd2x5LiBGb3IgZXhhbXBsZSwgWmlwIGJhc2VkIGZ1bmN0aW9ucyBfbm90XyBpbiBhIFZQQyBjYW4gdGFrZSB+MSBzZWNvbmQgd2hlcmVhcyBWUENcbiAgICogb3IgQ29udGFpbmVyIGZ1bmN0aW9ucyBjYW4gdGFrZSB+MjUgc2Vjb25kcyAoYW5kICdpZGxlJyBWUEMgZnVuY3Rpb25zIGNhbiB0YWtlIG1pbnV0ZXMpLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB3YWl0Rm9yTGFtYmRhc0NvZGVVcGRhdGVUb0ZpbmlzaChjdXJyZW50RnVuY3Rpb25Db25maWd1cmF0aW9uOiBBV1MuTGFtYmRhLkZ1bmN0aW9uQ29uZmlndXJhdGlvbiwgbGFtYmRhOiBBV1MuTGFtYmRhKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgZnVuY3Rpb25Jc0luVnBjT3JVc2VzRG9ja2VyRm9yQ29kZSA9IGN1cnJlbnRGdW5jdGlvbkNvbmZpZ3VyYXRpb24uVnBjQ29uZmlnPy5WcGNJZCB8fFxuICAgICAgICBjdXJyZW50RnVuY3Rpb25Db25maWd1cmF0aW9uLlBhY2thZ2VUeXBlID09PSAnSW1hZ2UnO1xuXG4gICAgLy8gaWYgdGhlIGZ1bmN0aW9uIGlzIGRlcGxveWVkIGluIGEgVlBDIG9yIGlmIGl0IGlzIGEgY29udGFpbmVyIGltYWdlIGZ1bmN0aW9uXG4gICAgLy8gdGhlbiB0aGUgdXBkYXRlIHdpbGwgdGFrZSBtdWNoIGxvbmdlciBhbmQgd2UgY2FuIHdhaXQgbG9uZ2VyIGJldHdlZW4gY2hlY2tzXG4gICAgLy8gb3RoZXJ3aXNlLCB0aGUgdXBkYXRlIHdpbGwgYmUgcXVpY2ssIHNvIGEgMS1zZWNvbmQgZGVsYXkgaXMgZmluZVxuICAgIGNvbnN0IGRlbGF5U2Vjb25kcyA9IGZ1bmN0aW9uSXNJblZwY09yVXNlc0RvY2tlckZvckNvZGUgPyA1IDogMTtcblxuICAgIC8vIGNvbmZpZ3VyZSBhIGN1c3RvbSB3YWl0ZXIgdG8gd2FpdCBmb3IgdGhlIGZ1bmN0aW9uIHVwZGF0ZSB0byBjb21wbGV0ZVxuICAgIChsYW1iZGEgYXMgYW55KS5hcGkud2FpdGVycy51cGRhdGVGdW5jdGlvbkNvZGVUb0ZpbmlzaCA9IHtcbiAgICAgIG5hbWU6ICdVcGRhdGVGdW5jdGlvbkNvZGVUb0ZpbmlzaCcsXG4gICAgICBvcGVyYXRpb246ICdnZXRGdW5jdGlvbicsXG4gICAgICAvLyBlcXVhdGVzIHRvIDEgbWludXRlIGZvciB6aXAgZnVuY3Rpb24gbm90IGluIGEgVlBDIGFuZFxuICAgICAgLy8gNSBtaW51dGVzIGZvciBjb250YWluZXIgZnVuY3Rpb25zIG9yIGZ1bmN0aW9uIGluIGEgVlBDXG4gICAgICBtYXhBdHRlbXB0czogNjAsXG4gICAgICBkZWxheTogZGVsYXlTZWNvbmRzLFxuICAgICAgYWNjZXB0b3JzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVyOiAncGF0aCcsXG4gICAgICAgICAgYXJndW1lbnQ6IFwiQ29uZmlndXJhdGlvbi5MYXN0VXBkYXRlU3RhdHVzID09ICdTdWNjZXNzZnVsJyAmJiBDb25maWd1cmF0aW9uLlN0YXRlID09ICdBY3RpdmUnXCIsXG4gICAgICAgICAgZXhwZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgc3RhdGU6ICdzdWNjZXNzJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoJyxcbiAgICAgICAgICBhcmd1bWVudDogJ0NvbmZpZ3VyYXRpb24uTGFzdFVwZGF0ZVN0YXR1cycsXG4gICAgICAgICAgZXhwZWN0ZWQ6ICdGYWlsZWQnLFxuICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVGdW5jdGlvbkNvZGVXYWl0ZXIgPSBuZXcgKEFXUyBhcyBhbnkpLlJlc291cmNlV2FpdGVyKGxhbWJkYSwgJ3VwZGF0ZUZ1bmN0aW9uQ29kZVRvRmluaXNoJyk7XG4gICAgYXdhaXQgdXBkYXRlRnVuY3Rpb25Db2RlV2FpdGVyLndhaXQoe1xuICAgICAgRnVuY3Rpb25OYW1lOiB0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lLFxuICAgIH0pLnByb21pc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbXByZXNzIGEgc3RyaW5nIGFzIGEgZmlsZSwgcmV0dXJuaW5nIGEgcHJvbWlzZSBmb3IgdGhlIHppcCBidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9hcmNoaXZlcmpzL25vZGUtYXJjaGl2ZXIvaXNzdWVzLzM0MlxuICovXG5mdW5jdGlvbiB6aXBTdHJpbmcoZmlsZU5hbWU6IHN0cmluZywgcmF3U3RyaW5nOiBzdHJpbmcpOiBQcm9taXNlPEJ1ZmZlcj4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGJ1ZmZlcnM6IEJ1ZmZlcltdID0gW107XG5cbiAgICBjb25zdCBjb252ZXJ0ZXIgPSBuZXcgV3JpdGFibGUoKTtcblxuICAgIGNvbnZlcnRlci5fd3JpdGUgPSAoY2h1bms6IEJ1ZmZlciwgXzogc3RyaW5nLCBjYWxsYmFjazogKCkgPT4gdm9pZCkgPT4ge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICBjb252ZXJ0ZXIub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgIHJlc29sdmUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBhcmNoaXZlID0gYXJjaGl2ZXIoJ3ppcCcpO1xuXG4gICAgYXJjaGl2ZS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9KTtcblxuICAgIGFyY2hpdmUucGlwZShjb252ZXJ0ZXIpO1xuXG4gICAgYXJjaGl2ZS5hcHBlbmQocmF3U3RyaW5nLCB7XG4gICAgICBuYW1lOiBmaWxlTmFtZSxcbiAgICAgIGRhdGU6IG5ldyBEYXRlKCcxOTgwLTAxLTAxVDAwOjAwOjAwLjAwMFonKSwgLy8gQWRkIGRhdGUgdG8gbWFrZSByZXN1bHRpbmcgemlwIGZpbGUgZGV0ZXJtaW5pc3RpY1xuICAgIH0pO1xuXG4gICAgdm9pZCBhcmNoaXZlLmZpbmFsaXplKCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBmaWxlIGV4dGVuc2lvbiBmcm9tIExhbWJkYSBydW50aW1lIHN0cmluZy5cbiAqIFdlIHVzZSB0aGlzIGV4dGVuc2lvbiB0byBjcmVhdGUgYSBkZXBsb3ltZW50IHBhY2thZ2UgZnJvbSBMYW1iZGEgaW5saW5lIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluZUNvZGVGaWxlRXh0RnJvbVJ1bnRpbWUocnVudGltZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKHJ1bnRpbWUuc3RhcnRzV2l0aCgnbm9kZScpKSB7XG4gICAgcmV0dXJuICdqcyc7XG4gIH1cbiAgaWYgKHJ1bnRpbWUuc3RhcnRzV2l0aCgncHl0aG9uJykpIHtcbiAgICByZXR1cm4gJ3B5JztcbiAgfVxuICAvLyBDdXJyZW50bHkgaW5saW5lIGNvZGUgb25seSBzdXBwb3J0cyBOb2RlLmpzIGFuZCBQeXRob24sIGlnbm9yaW5nIG90aGVyIHJ1bnRpbWVzLlxuICAvLyBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vQVdTQ2xvdWRGb3JtYXRpb24vbGF0ZXN0L1VzZXJHdWlkZS9hd3MtcHJvcGVydGllcy1sYW1iZGEtZnVuY3Rpb24tY29kZS5odG1sI2F3cy1wcm9wZXJ0aWVzLWxhbWJkYS1mdW5jdGlvbi1jb2RlLXByb3BlcnRpZXNcbiAgdGhyb3cgbmV3IENmbkV2YWx1YXRpb25FeGNlcHRpb24oYHJ1bnRpbWUgJHtydW50aW1lfSBpcyB1bnN1cHBvcnRlZCwgb25seSBub2RlLmpzIGFuZCBweXRob24gcnVudGltZXMgYXJlIGN1cnJlbnRseSBzdXBwb3J0ZWQuYCk7XG59XG4iXX0=