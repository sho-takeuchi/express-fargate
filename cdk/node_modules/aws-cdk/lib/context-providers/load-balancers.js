"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.describeListenersByLoadBalancerArn = exports.tagsMatch = exports.describeTags = exports.describeLoadBalancers = exports.LoadBalancerListenerContextProviderPlugin = exports.LoadBalancerContextProviderPlugin = void 0;
const cxapi = require("@aws-cdk/cx-api");
const api_1 = require("../api");
/**
 * Provides load balancer context information.
 */
class LoadBalancerContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(query) {
        var _a;
        const options = { assumeRoleArn: query.lookupRoleArn };
        const elbv2 = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(query.account, query.region), api_1.Mode.ForReading, options)).sdk.elbv2();
        if (!query.loadBalancerArn && !query.loadBalancerTags) {
            throw new Error('The load balancer lookup query must specify either `loadBalancerArn` or `loadBalancerTags`');
        }
        const loadBalancers = await findLoadBalancers(elbv2, query);
        if (loadBalancers.length === 0) {
            throw new Error(`No load balancers found matching ${JSON.stringify(query)}`);
        }
        if (loadBalancers.length > 1) {
            throw new Error(`Multiple load balancers found matching ${JSON.stringify(query)} - please provide more specific criteria`);
        }
        const loadBalancer = loadBalancers[0];
        const ipAddressType = loadBalancer.IpAddressType === 'ipv4'
            ? cxapi.LoadBalancerIpAddressType.IPV4
            : cxapi.LoadBalancerIpAddressType.DUAL_STACK;
        return {
            loadBalancerArn: loadBalancer.LoadBalancerArn,
            loadBalancerCanonicalHostedZoneId: loadBalancer.CanonicalHostedZoneId,
            loadBalancerDnsName: loadBalancer.DNSName,
            vpcId: loadBalancer.VpcId,
            securityGroupIds: (_a = loadBalancer.SecurityGroups) !== null && _a !== void 0 ? _a : [],
            ipAddressType: ipAddressType,
        };
    }
}
exports.LoadBalancerContextProviderPlugin = LoadBalancerContextProviderPlugin;
/**
 * Provides load balancer listener context information
 */
class LoadBalancerListenerContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(query) {
        const options = { assumeRoleArn: query.lookupRoleArn };
        const elbv2 = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(query.account, query.region), api_1.Mode.ForReading, options)).sdk.elbv2();
        if (!query.listenerArn && !query.loadBalancerArn && !query.loadBalancerTags) {
            throw new Error('The load balancer listener query must specify at least one of: `listenerArn`, `loadBalancerArn` or `loadBalancerTags`');
        }
        return query.listenerArn ? this.getListenerByArn(elbv2, query) : this.getListenerByFilteringLoadBalancers(elbv2, query);
    }
    /**
     * Look up a listener by querying listeners for query's listener arn and then
     * resolve its load balancer for the security group information.
     */
    async getListenerByArn(elbv2, query) {
        var _a, _b;
        const listenerArn = query.listenerArn;
        const listenerResults = await elbv2.describeListeners({ ListenerArns: [listenerArn] }).promise();
        const listeners = ((_a = listenerResults.Listeners) !== null && _a !== void 0 ? _a : []);
        if (listeners.length === 0) {
            throw new Error(`No load balancer listeners found matching arn ${listenerArn}`);
        }
        const listener = listeners[0];
        const loadBalancers = await findLoadBalancers(elbv2, {
            ...query,
            loadBalancerArn: listener.LoadBalancerArn,
        });
        if (loadBalancers.length === 0) {
            throw new Error(`No associated load balancer found for listener arn ${listenerArn}`);
        }
        const loadBalancer = loadBalancers[0];
        return {
            listenerArn: listener.ListenerArn,
            listenerPort: listener.Port,
            securityGroupIds: (_b = loadBalancer.SecurityGroups) !== null && _b !== void 0 ? _b : [],
        };
    }
    /**
     * Look up a listener by starting from load balancers, filtering out
     * unmatching load balancers, and then by querying the listeners of each load
     * balancer and filtering out unmatching listeners.
     */
    async getListenerByFilteringLoadBalancers(elbv2, args) {
        // Find matching load balancers
        const loadBalancers = await findLoadBalancers(elbv2, args);
        if (loadBalancers.length === 0) {
            throw new Error(`No associated load balancers found for load balancer listener query ${JSON.stringify(args)}`);
        }
        return this.findMatchingListener(elbv2, loadBalancers, args);
    }
    /**
     * Finds the matching listener from the list of load balancers. This will
     * error unless there is exactly one match so that the user is prompted to
     * provide more specific criteria rather than us providing a nondeterministic
     * result.
     */
    async findMatchingListener(elbv2, loadBalancers, query) {
        var _a;
        const loadBalancersByArn = indexLoadBalancersByArn(loadBalancers);
        const loadBalancerArns = Object.keys(loadBalancersByArn);
        const matches = Array();
        for await (const listener of describeListenersByLoadBalancerArn(elbv2, loadBalancerArns)) {
            const loadBalancer = loadBalancersByArn[listener.LoadBalancerArn];
            if (listenerMatchesQueryFilter(listener, query) && loadBalancer) {
                matches.push({
                    listenerArn: listener.ListenerArn,
                    listenerPort: listener.Port,
                    securityGroupIds: (_a = loadBalancer.SecurityGroups) !== null && _a !== void 0 ? _a : [],
                });
            }
        }
        if (matches.length === 0) {
            throw new Error(`No load balancer listeners found matching ${JSON.stringify(query)}`);
        }
        if (matches.length > 1) {
            throw new Error(`Multiple load balancer listeners found matching ${JSON.stringify(query)} - please provide more specific criteria`);
        }
        return matches[0];
    }
}
exports.LoadBalancerListenerContextProviderPlugin = LoadBalancerListenerContextProviderPlugin;
/**
 * Find load balancers by the given filter args.
 */
async function findLoadBalancers(elbv2, args) {
    // List load balancers
    let loadBalancers = await describeLoadBalancers(elbv2, {
        LoadBalancerArns: args.loadBalancerArn ? [args.loadBalancerArn] : undefined,
    });
    // Filter by load balancer type
    loadBalancers = loadBalancers.filter(lb => lb.Type === args.loadBalancerType);
    // Filter by load balancer tags
    if (args.loadBalancerTags) {
        loadBalancers = await filterLoadBalancersByTags(elbv2, loadBalancers, args.loadBalancerTags);
    }
    return loadBalancers;
}
/**
 * Helper to paginate over describeLoadBalancers
 * @internal
 */
async function describeLoadBalancers(elbv2, request) {
    var _a;
    const loadBalancers = Array();
    let page;
    do {
        page = await elbv2.describeLoadBalancers({
            ...request,
            Marker: page === null || page === void 0 ? void 0 : page.NextMarker,
        }).promise();
        loadBalancers.push(...Array.from((_a = page.LoadBalancers) !== null && _a !== void 0 ? _a : []));
    } while (page.NextMarker);
    return loadBalancers;
}
exports.describeLoadBalancers = describeLoadBalancers;
/**
 * Describes the tags of each load balancer and returns the load balancers that
 * match the given tags.
 */
async function filterLoadBalancersByTags(elbv2, loadBalancers, loadBalancerTags) {
    const loadBalancersByArn = indexLoadBalancersByArn(loadBalancers);
    const loadBalancerArns = Object.keys(loadBalancersByArn);
    const matchingLoadBalancers = Array();
    // Consume the items of async generator.
    for await (const tags of describeTags(elbv2, loadBalancerArns)) {
        if (tagsMatch(tags, loadBalancerTags) && loadBalancersByArn[tags.ResourceArn]) {
            matchingLoadBalancers.push(loadBalancersByArn[tags.ResourceArn]);
        }
    }
    return matchingLoadBalancers;
}
/**
 * Generator function that yields `TagDescriptions`. The API doesn't support
 * pagination, so this generator breaks the resource list into chunks and issues
 * the appropriate requests, yielding each tag description as it receives it.
 * @internal
 */
async function* describeTags(elbv2, resourceArns) {
    var _a;
    // Max of 20 resource arns per request.
    const chunkSize = 20;
    for (let i = 0; i < resourceArns.length; i += chunkSize) {
        const chunk = resourceArns.slice(i, Math.min(i + chunkSize, resourceArns.length));
        const chunkTags = await elbv2.describeTags({
            ResourceArns: chunk,
        }).promise();
        for (const tag of (_a = chunkTags.TagDescriptions) !== null && _a !== void 0 ? _a : []) {
            yield tag;
        }
    }
}
exports.describeTags = describeTags;
/**
 * Determines if the given TagDescription matches the required tags.
 * @internal
 */
function tagsMatch(tagDescription, requiredTags) {
    var _a;
    const tagsByName = {};
    for (const tag of (_a = tagDescription.Tags) !== null && _a !== void 0 ? _a : []) {
        tagsByName[tag.Key] = tag.Value;
    }
    for (const tag of requiredTags) {
        if (tagsByName[tag.key] !== tag.value) {
            return false;
        }
    }
    return true;
}
exports.tagsMatch = tagsMatch;
/**
 * Async generator that produces listener descriptions by traversing the
 * pagination. Because describeListeners only lets you search by one load
 * balancer arn at a time, we request them individually and yield the listeners
 * as they come in.
 * @internal
 */
async function* describeListenersByLoadBalancerArn(elbv2, loadBalancerArns) {
    var _a;
    for (const loadBalancerArn of loadBalancerArns) {
        let page;
        do {
            page = await elbv2.describeListeners({
                LoadBalancerArn: loadBalancerArn,
                Marker: page === null || page === void 0 ? void 0 : page.NextMarker,
            }).promise();
            for (const listener of (_a = page.Listeners) !== null && _a !== void 0 ? _a : []) {
                yield listener;
            }
        } while (page.NextMarker);
    }
}
exports.describeListenersByLoadBalancerArn = describeListenersByLoadBalancerArn;
/**
 * Determines if a listener matches the query filters.
 */
function listenerMatchesQueryFilter(listener, args) {
    if (args.listenerPort && listener.Port !== args.listenerPort) {
        // No match.
        return false;
    }
    if (args.listenerProtocol && listener.Protocol !== args.listenerProtocol) {
        // No match.
        return false;
    }
    return true;
}
/**
 * Returns a record of load balancers indexed by their arns
 */
function indexLoadBalancersByArn(loadBalancers) {
    const loadBalancersByArn = {};
    for (const loadBalancer of loadBalancers) {
        loadBalancersByArn[loadBalancer.LoadBalancerArn] = loadBalancer;
    }
    return loadBalancersByArn;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9hZC1iYWxhbmNlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJsb2FkLWJhbGFuY2Vycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSx5Q0FBeUM7QUFFekMsZ0NBQTJDO0FBRzNDOztHQUVHO0FBQ0gsTUFBYSxpQ0FBaUM7SUFDNUMsWUFBNkIsR0FBZ0I7UUFBaEIsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUM3QyxDQUFDO0lBRUQsS0FBSyxDQUFDLFFBQVEsQ0FBQyxLQUF3Qzs7UUFDckQsTUFBTSxPQUFPLEdBQUcsRUFBRSxhQUFhLEVBQUUsS0FBSyxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBQ3ZELE1BQU0sS0FBSyxHQUFHLENBQUMsTUFBTSxJQUFJLENBQUMsR0FBRyxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLFVBQUksQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7UUFFOUksSUFBSSxDQUFDLEtBQUssQ0FBQyxlQUFlLElBQUksQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLEVBQUU7WUFDckQsTUFBTSxJQUFJLEtBQUssQ0FBQyw0RkFBNEYsQ0FBQyxDQUFDO1NBQy9HO1FBRUQsTUFBTSxhQUFhLEdBQUcsTUFBTSxpQkFBaUIsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7UUFFNUQsSUFBSSxhQUFhLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLG9DQUFvQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztTQUM5RTtRQUVELElBQUksYUFBYSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7WUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsSUFBSSxDQUFD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QUFFLENBQUM7SUFFdEUsS0FBSyxNQUFNLFlBQVksSUFBSSxhQUFhLEVBQUU7UUFDeEMsa0JBQWtCLENBQUMsWUFBWSxDQUFDLGVBQWdCLENBQUMsR0FBRyxZQUFZLENBQUM7S0FDbEU7SUFFRCxPQUFPLGtCQUFrQixDQUFDO0FBQzVCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IE1vZGUsIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi4vYXBpJztcbmltcG9ydCB7IENvbnRleHRQcm92aWRlclBsdWdpbiB9IGZyb20gJy4vcHJvdmlkZXInO1xuXG4vKipcbiAqIFByb3ZpZGVzIGxvYWQgYmFsYW5jZXIgY29udGV4dCBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIExvYWRCYWxhbmNlckNvbnRleHRQcm92aWRlclBsdWdpbiBpbXBsZW1lbnRzIENvbnRleHRQcm92aWRlclBsdWdpbiB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgYXdzOiBTZGtQcm92aWRlcikge1xuICB9XG5cbiAgYXN5bmMgZ2V0VmFsdWUocXVlcnk6IGN4c2NoZW1hLkxvYWRCYWxhbmNlckNvbnRleHRRdWVyeSk6IFByb21pc2U8Y3hhcGkuTG9hZEJhbGFuY2VyQ29udGV4dFJlc3BvbnNlPiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgYXNzdW1lUm9sZUFybjogcXVlcnkubG9va3VwUm9sZUFybiB9O1xuICAgIGNvbnN0IGVsYnYyID0gKGF3YWl0IHRoaXMuYXdzLmZvckVudmlyb25tZW50KGN4YXBpLkVudmlyb25tZW50VXRpbHMubWFrZShxdWVyeS5hY2NvdW50LCBxdWVyeS5yZWdpb24pLCBNb2RlLkZvclJlYWRpbmcsIG9wdGlvbnMpKS5zZGsuZWxidjIoKTtcblxuICAgIGlmICghcXVlcnkubG9hZEJhbGFuY2VyQXJuICYmICFxdWVyeS5sb2FkQmFsYW5jZXJUYWdzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsb2FkIGJhbGFuY2VyIGxvb2t1cCBxdWVyeSBtdXN0IHNwZWNpZnkgZWl0aGVyIGBsb2FkQmFsYW5jZXJBcm5gIG9yIGBsb2FkQmFsYW5jZXJUYWdzYCcpO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYWRCYWxhbmNlcnMgPSBhd2FpdCBmaW5kTG9hZEJhbGFuY2VycyhlbGJ2MiwgcXVlcnkpO1xuXG4gICAgaWYgKGxvYWRCYWxhbmNlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGxvYWQgYmFsYW5jZXJzIGZvdW5kIG1hdGNoaW5nICR7SlNPTi5zdHJpbmdpZnkocXVlcnkpfWApO1xuICAgIH1cblxuICAgIGlmIChsb2FkQmFsYW5jZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTXVsdGlwbGUgbG9hZCBiYWxhbmNlcnMgZm91bmQgbWF0Y2hpbmcgJHtKU09OLnN0cmluZ2lmeShxdWVyeSl9IC0gcGxlYXNlIHByb3ZpZGUgbW9yZSBzcGVjaWZpYyBjcml0ZXJpYWApO1xuICAgIH1cblxuICAgIGNvbnN0IGxvYWRCYWxhbmNlciA9IGxvYWRCYWxhbmNlcnNbMF07XG5cbiAgICBjb25zdCBpcEFkZHJlc3NUeXBlID0gbG9hZEJhbGFuY2VyLklwQWRkcmVzc1R5cGUgPT09ICdpcHY0J1xuICAgICAgPyBjeGFwaS5Mb2FkQmFsYW5jZXJJcEFkZHJlc3NUeXBlLklQVjRcbiAgICAgIDogY3hhcGkuTG9hZEJhbGFuY2VySXBBZGRyZXNzVHlwZS5EVUFMX1NUQUNLO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWRCYWxhbmNlckFybjogbG9hZEJhbGFuY2VyLkxvYWRCYWxhbmNlckFybiEsXG4gICAgICBsb2FkQmFsYW5jZXJDYW5vbmljYWxIb3N0ZWRab25lSWQ6IGxvYWRCYWxhbmNlci5DYW5vbmljYWxIb3N0ZWRab25lSWQhLFxuICAgICAgbG9hZEJhbGFuY2VyRG5zTmFtZTogbG9hZEJhbGFuY2VyLkROU05hbWUhLFxuICAgICAgdnBjSWQ6IGxvYWRCYWxhbmNlci5WcGNJZCEsXG4gICAgICBzZWN1cml0eUdyb3VwSWRzOiBsb2FkQmFsYW5jZXIuU2VjdXJpdHlHcm91cHMgPz8gW10sXG4gICAgICBpcEFkZHJlc3NUeXBlOiBpcEFkZHJlc3NUeXBlLFxuICAgIH07XG4gIH1cbn1cblxuLy8gRGVjcmVhc2VzIGxpbmUgbGVuZ3RoXG50eXBlIExvYWRCYWxhbmNlckxpc3RlbmVyUXVlcnkgPSBjeHNjaGVtYS5Mb2FkQmFsYW5jZXJMaXN0ZW5lckNvbnRleHRRdWVyeTtcbnR5cGUgTG9hZEJhbGFuY2VyTGlzdGVuZXJSZXNwb25zZSA9IGN4YXBpLkxvYWRCYWxhbmNlckxpc3RlbmVyQ29udGV4dFJlc3BvbnNlO1xuXG4vKipcbiAqIFByb3ZpZGVzIGxvYWQgYmFsYW5jZXIgbGlzdGVuZXIgY29udGV4dCBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgY2xhc3MgTG9hZEJhbGFuY2VyTGlzdGVuZXJDb250ZXh0UHJvdmlkZXJQbHVnaW4gaW1wbGVtZW50cyBDb250ZXh0UHJvdmlkZXJQbHVnaW4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGF3czogU2RrUHJvdmlkZXIpIHtcbiAgfVxuXG4gIGFzeW5jIGdldFZhbHVlKHF1ZXJ5OiBMb2FkQmFsYW5jZXJMaXN0ZW5lclF1ZXJ5KTogUHJvbWlzZTxMb2FkQmFsYW5jZXJMaXN0ZW5lclJlc3BvbnNlPiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHsgYXNzdW1lUm9sZUFybjogcXVlcnkubG9va3VwUm9sZUFybiB9O1xuICAgIGNvbnN0IGVsYnYyID0gKGF3YWl0IHRoaXMuYXdzLmZvckVudmlyb25tZW50KGN4YXBpLkVudmlyb25tZW50VXRpbHMubWFrZShxdWVyeS5hY2NvdW50LCBxdWVyeS5yZWdpb24pLCBNb2RlLkZvclJlYWRpbmcsIG9wdGlvbnMpKS5zZGsuZWxidjIoKTtcblxuICAgIGlmICghcXVlcnkubGlzdGVuZXJBcm4gJiYgIXF1ZXJ5LmxvYWRCYWxhbmNlckFybiAmJiAhcXVlcnkubG9hZEJhbGFuY2VyVGFncykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbG9hZCBiYWxhbmNlciBsaXN0ZW5lciBxdWVyeSBtdXN0IHNwZWNpZnkgYXQgbGVhc3Qgb25lIG9mOiBgbGlzdGVuZXJBcm5gLCBgbG9hZEJhbGFuY2VyQXJuYCBvciBgbG9hZEJhbGFuY2VyVGFnc2AnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVlcnkubGlzdGVuZXJBcm4gPyB0aGlzLmdldExpc3RlbmVyQnlBcm4oZWxidjIsIHF1ZXJ5KSA6IHRoaXMuZ2V0TGlzdGVuZXJCeUZpbHRlcmluZ0xvYWRCYWxhbmNlcnMoZWxidjIsIHF1ZXJ5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb29rIHVwIGEgbGlzdGVuZXIgYnkgcXVlcnlpbmcgbGlzdGVuZXJzIGZvciBxdWVyeSdzIGxpc3RlbmVyIGFybiBhbmQgdGhlblxuICAgKiByZXNvbHZlIGl0cyBsb2FkIGJhbGFuY2VyIGZvciB0aGUgc2VjdXJpdHkgZ3JvdXAgaW5mb3JtYXRpb24uXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldExpc3RlbmVyQnlBcm4oZWxidjI6IEFXUy5FTEJ2MiwgcXVlcnk6IExvYWRCYWxhbmNlckxpc3RlbmVyUXVlcnkpIHtcbiAgICBjb25zdCBsaXN0ZW5lckFybiA9IHF1ZXJ5Lmxpc3RlbmVyQXJuITtcbiAgICBjb25zdCBsaXN0ZW5lclJlc3VsdHMgPSBhd2FpdCBlbGJ2Mi5kZXNjcmliZUxpc3RlbmVycyh7IExpc3RlbmVyQXJuczogW2xpc3RlbmVyQXJuXSB9KS5wcm9taXNlKCk7XG4gICAgY29uc3QgbGlzdGVuZXJzID0gKGxpc3RlbmVyUmVzdWx0cy5MaXN0ZW5lcnMgPz8gW10pO1xuXG4gICAgaWYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbG9hZCBiYWxhbmNlciBsaXN0ZW5lcnMgZm91bmQgbWF0Y2hpbmcgYXJuICR7bGlzdGVuZXJBcm59YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbMF07XG5cbiAgICBjb25zdCBsb2FkQmFsYW5jZXJzID0gYXdhaXQgZmluZExvYWRCYWxhbmNlcnMoZWxidjIsIHtcbiAgICAgIC4uLnF1ZXJ5LFxuICAgICAgbG9hZEJhbGFuY2VyQXJuOiBsaXN0ZW5lci5Mb2FkQmFsYW5jZXJBcm4hLFxuICAgIH0pO1xuXG4gICAgaWYgKGxvYWRCYWxhbmNlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGFzc29jaWF0ZWQgbG9hZCBiYWxhbmNlciBmb3VuZCBmb3IgbGlzdGVuZXIgYXJuICR7bGlzdGVuZXJBcm59YCk7XG4gICAgfVxuXG4gICAgY29uc3QgbG9hZEJhbGFuY2VyID0gbG9hZEJhbGFuY2Vyc1swXTtcblxuICAgIHJldHVybiB7XG4gICAgICBsaXN0ZW5lckFybjogbGlzdGVuZXIuTGlzdGVuZXJBcm4hLFxuICAgICAgbGlzdGVuZXJQb3J0OiBsaXN0ZW5lci5Qb3J0ISxcbiAgICAgIHNlY3VyaXR5R3JvdXBJZHM6IGxvYWRCYWxhbmNlci5TZWN1cml0eUdyb3VwcyA/PyBbXSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIExvb2sgdXAgYSBsaXN0ZW5lciBieSBzdGFydGluZyBmcm9tIGxvYWQgYmFsYW5jZXJzLCBmaWx0ZXJpbmcgb3V0XG4gICAqIHVubWF0Y2hpbmcgbG9hZCBiYWxhbmNlcnMsIGFuZCB0aGVuIGJ5IHF1ZXJ5aW5nIHRoZSBsaXN0ZW5lcnMgb2YgZWFjaCBsb2FkXG4gICAqIGJhbGFuY2VyIGFuZCBmaWx0ZXJpbmcgb3V0IHVubWF0Y2hpbmcgbGlzdGVuZXJzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBnZXRMaXN0ZW5lckJ5RmlsdGVyaW5nTG9hZEJhbGFuY2VycyhlbGJ2MjogQVdTLkVMQnYyLCBhcmdzOiBMb2FkQmFsYW5jZXJMaXN0ZW5lclF1ZXJ5KSB7XG4gICAgLy8gRmluZCBtYXRjaGluZyBsb2FkIGJhbGFuY2Vyc1xuICAgIGNvbnN0IGxvYWRCYWxhbmNlcnMgPSBhd2FpdCBmaW5kTG9hZEJhbGFuY2VycyhlbGJ2MiwgYXJncyk7XG5cbiAgICBpZiAobG9hZEJhbGFuY2Vycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gYXNzb2NpYXRlZCBsb2FkIGJhbGFuY2VycyBmb3VuZCBmb3IgbG9hZCBiYWxhbmNlciBsaXN0ZW5lciBxdWVyeSAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfWApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmZpbmRNYXRjaGluZ0xpc3RlbmVyKGVsYnYyLCBsb2FkQmFsYW5jZXJzLCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgbWF0Y2hpbmcgbGlzdGVuZXIgZnJvbSB0aGUgbGlzdCBvZiBsb2FkIGJhbGFuY2Vycy4gVGhpcyB3aWxsXG4gICAqIGVycm9yIHVubGVzcyB0aGVyZSBpcyBleGFjdGx5IG9uZSBtYXRjaCBzbyB0aGF0IHRoZSB1c2VyIGlzIHByb21wdGVkIHRvXG4gICAqIHByb3ZpZGUgbW9yZSBzcGVjaWZpYyBjcml0ZXJpYSByYXRoZXIgdGhhbiB1cyBwcm92aWRpbmcgYSBub25kZXRlcm1pbmlzdGljXG4gICAqIHJlc3VsdC5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmluZE1hdGNoaW5nTGlzdGVuZXIoZWxidjI6IEFXUy5FTEJ2MiwgbG9hZEJhbGFuY2VyczogQVdTLkVMQnYyLkxvYWRCYWxhbmNlcnMsIHF1ZXJ5OiBMb2FkQmFsYW5jZXJMaXN0ZW5lclF1ZXJ5KSB7XG4gICAgY29uc3QgbG9hZEJhbGFuY2Vyc0J5QXJuID0gaW5kZXhMb2FkQmFsYW5jZXJzQnlBcm4obG9hZEJhbGFuY2Vycyk7XG4gICAgY29uc3QgbG9hZEJhbGFuY2VyQXJucyA9IE9iamVjdC5rZXlzKGxvYWRCYWxhbmNlcnNCeUFybik7XG5cbiAgICBjb25zdCBtYXRjaGVzID0gQXJyYXk8Y3hhcGkuTG9hZEJhbGFuY2VyTGlzdGVuZXJDb250ZXh0UmVzcG9uc2U+KCk7XG5cbiAgICBmb3IgYXdhaXQgKGNvbnN0IGxpc3RlbmVyIG9mIGRlc2NyaWJlTGlzdGVuZXJzQnlMb2FkQmFsYW5jZXJBcm4oZWxidjIsIGxvYWRCYWxhbmNlckFybnMpKSB7XG4gICAgICBjb25zdCBsb2FkQmFsYW5jZXIgPSBsb2FkQmFsYW5jZXJzQnlBcm5bbGlzdGVuZXIuTG9hZEJhbGFuY2VyQXJuIV07XG4gICAgICBpZiAobGlzdGVuZXJNYXRjaGVzUXVlcnlGaWx0ZXIobGlzdGVuZXIsIHF1ZXJ5KSAmJiBsb2FkQmFsYW5jZXIpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKHtcbiAgICAgICAgICBsaXN0ZW5lckFybjogbGlzdGVuZXIuTGlzdGVuZXJBcm4hLFxuICAgICAgICAgIGxpc3RlbmVyUG9ydDogbGlzdGVuZXIuUG9ydCEsXG4gICAgICAgICAgc2VjdXJpdHlHcm91cElkczogbG9hZEJhbGFuY2VyLlNlY3VyaXR5R3JvdXBzID8/IFtdLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWF0Y2hlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gbG9hZCBiYWxhbmNlciBsaXN0ZW5lcnMgZm91bmQgbWF0Y2hpbmcgJHtKU09OLnN0cmluZ2lmeShxdWVyeSl9YCk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBsb2FkIGJhbGFuY2VyIGxpc3RlbmVycyBmb3VuZCBtYXRjaGluZyAke0pTT04uc3RyaW5naWZ5KHF1ZXJ5KX0gLSBwbGVhc2UgcHJvdmlkZSBtb3JlIHNwZWNpZmljIGNyaXRlcmlhYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoZXNbMF07XG4gIH1cbn1cblxuLyoqXG4gKiBGaW5kIGxvYWQgYmFsYW5jZXJzIGJ5IHRoZSBnaXZlbiBmaWx0ZXIgYXJncy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZmluZExvYWRCYWxhbmNlcnMoZWxidjI6IEFXUy5FTEJ2MiwgYXJnczogY3hzY2hlbWEuTG9hZEJhbGFuY2VyRmlsdGVyKSB7XG4gIC8vIExpc3QgbG9hZCBiYWxhbmNlcnNcbiAgbGV0IGxvYWRCYWxhbmNlcnMgPSBhd2FpdCBkZXNjcmliZUxvYWRCYWxhbmNlcnMoZWxidjIsIHtcbiAgICBMb2FkQmFsYW5jZXJBcm5zOiBhcmdzLmxvYWRCYWxhbmNlckFybiA/IFthcmdzLmxvYWRCYWxhbmNlckFybl0gOiB1bmRlZmluZWQsXG4gIH0pO1xuXG4gIC8vIEZpbHRlciBieSBsb2FkIGJhbGFuY2VyIHR5cGVcbiAgbG9hZEJhbGFuY2VycyA9IGxvYWRCYWxhbmNlcnMuZmlsdGVyKGxiID0+IGxiLlR5cGUgPT09IGFyZ3MubG9hZEJhbGFuY2VyVHlwZSk7XG5cbiAgLy8gRmlsdGVyIGJ5IGxvYWQgYmFsYW5jZXIgdGFnc1xuICBpZiAoYXJncy5sb2FkQmFsYW5jZXJUYWdzKSB7XG4gICAgbG9hZEJhbGFuY2VycyA9IGF3YWl0IGZpbHRlckxvYWRCYWxhbmNlcnNCeVRhZ3MoZWxidjIsIGxvYWRCYWxhbmNlcnMsIGFyZ3MubG9hZEJhbGFuY2VyVGFncyk7XG4gIH1cblxuICByZXR1cm4gbG9hZEJhbGFuY2Vycztcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gcGFnaW5hdGUgb3ZlciBkZXNjcmliZUxvYWRCYWxhbmNlcnNcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVzY3JpYmVMb2FkQmFsYW5jZXJzKGVsYnYyOiBBV1MuRUxCdjIsIHJlcXVlc3Q6IEFXUy5FTEJ2Mi5EZXNjcmliZUxvYWRCYWxhbmNlcnNJbnB1dCkge1xuICBjb25zdCBsb2FkQmFsYW5jZXJzID0gQXJyYXk8QVdTLkVMQnYyLkxvYWRCYWxhbmNlcj4oKTtcbiAgbGV0IHBhZ2U6IEFXUy5FTEJ2Mi5EZXNjcmliZUxvYWRCYWxhbmNlcnNPdXRwdXQgfCB1bmRlZmluZWQ7XG4gIGRvIHtcbiAgICBwYWdlID0gYXdhaXQgZWxidjIuZGVzY3JpYmVMb2FkQmFsYW5jZXJzKHtcbiAgICAgIC4uLnJlcXVlc3QsXG4gICAgICBNYXJrZXI6IHBhZ2U/Lk5leHRNYXJrZXIsXG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgbG9hZEJhbGFuY2Vycy5wdXNoKC4uLkFycmF5LmZyb20ocGFnZS5Mb2FkQmFsYW5jZXJzID8/IFtdKSk7XG4gIH0gd2hpbGUgKHBhZ2UuTmV4dE1hcmtlcik7XG5cbiAgcmV0dXJuIGxvYWRCYWxhbmNlcnM7XG59XG5cbi8qKlxuICogRGVzY3JpYmVzIHRoZSB0YWdzIG9mIGVhY2ggbG9hZCBiYWxhbmNlciBhbmQgcmV0dXJucyB0aGUgbG9hZCBiYWxhbmNlcnMgdGhhdFxuICogbWF0Y2ggdGhlIGdpdmVuIHRhZ3MuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbHRlckxvYWRCYWxhbmNlcnNCeVRhZ3MoZWxidjI6IEFXUy5FTEJ2MiwgbG9hZEJhbGFuY2VyczogQVdTLkVMQnYyLkxvYWRCYWxhbmNlcnMsIGxvYWRCYWxhbmNlclRhZ3M6IGN4c2NoZW1hLlRhZ1tdKSB7XG4gIGNvbnN0IGxvYWRCYWxhbmNlcnNCeUFybiA9IGluZGV4TG9hZEJhbGFuY2Vyc0J5QXJuKGxvYWRCYWxhbmNlcnMpO1xuICBjb25zdCBsb2FkQmFsYW5jZXJBcm5zID0gT2JqZWN0LmtleXMobG9hZEJhbGFuY2Vyc0J5QXJuKTtcbiAgY29uc3QgbWF0Y2hpbmdMb2FkQmFsYW5jZXJzID0gQXJyYXk8QVdTLkVMQnYyLkxvYWRCYWxhbmNlcj4oKTtcblxuICAvLyBDb25zdW1lIHRoZSBpdGVtcyBvZiBhc3luYyBnZW5lcmF0b3IuXG4gIGZvciBhd2FpdCAoY29uc3QgdGFncyBvZiBkZXNjcmliZVRhZ3MoZWxidjIsIGxvYWRCYWxhbmNlckFybnMpKSB7XG4gICAgaWYgKHRhZ3NNYXRjaCh0YWdzLCBsb2FkQmFsYW5jZXJUYWdzKSAmJiBsb2FkQmFsYW5jZXJzQnlBcm5bdGFncy5SZXNvdXJjZUFybiFdKSB7XG4gICAgICBtYXRjaGluZ0xvYWRCYWxhbmNlcnMucHVzaChsb2FkQmFsYW5jZXJzQnlBcm5bdGFncy5SZXNvdXJjZUFybiFdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hpbmdMb2FkQmFsYW5jZXJzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRvciBmdW5jdGlvbiB0aGF0IHlpZWxkcyBgVGFnRGVzY3JpcHRpb25zYC4gVGhlIEFQSSBkb2Vzbid0IHN1cHBvcnRcbiAqIHBhZ2luYXRpb24sIHNvIHRoaXMgZ2VuZXJhdG9yIGJyZWFrcyB0aGUgcmVzb3VyY2UgbGlzdCBpbnRvIGNodW5rcyBhbmQgaXNzdWVzXG4gKiB0aGUgYXBwcm9wcmlhdGUgcmVxdWVzdHMsIHlpZWxkaW5nIGVhY2ggdGFnIGRlc2NyaXB0aW9uIGFzIGl0IHJlY2VpdmVzIGl0LlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiogZGVzY3JpYmVUYWdzKGVsYnYyOiBBV1MuRUxCdjIsIHJlc291cmNlQXJuczogc3RyaW5nW10pIHtcbiAgLy8gTWF4IG9mIDIwIHJlc291cmNlIGFybnMgcGVyIHJlcXVlc3QuXG4gIGNvbnN0IGNodW5rU2l6ZSA9IDIwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc291cmNlQXJucy5sZW5ndGg7IGkgKz0gY2h1bmtTaXplKSB7XG4gICAgY29uc3QgY2h1bmsgPSByZXNvdXJjZUFybnMuc2xpY2UoaSwgTWF0aC5taW4oaSArIGNodW5rU2l6ZSwgcmVzb3VyY2VBcm5zLmxlbmd0aCkpO1xuICAgIGNvbnN0IGNodW5rVGFncyA9IGF3YWl0IGVsYnYyLmRlc2NyaWJlVGFncyh7XG4gICAgICBSZXNvdXJjZUFybnM6IGNodW5rLFxuICAgIH0pLnByb21pc2UoKTtcblxuICAgIGZvciAoY29uc3QgdGFnIG9mIGNodW5rVGFncy5UYWdEZXNjcmlwdGlvbnMgPz8gW10pIHtcbiAgICAgIHlpZWxkIHRhZztcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBUYWdEZXNjcmlwdGlvbiBtYXRjaGVzIHRoZSByZXF1aXJlZCB0YWdzLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0YWdzTWF0Y2godGFnRGVzY3JpcHRpb246IEFXUy5FTEJ2Mi5UYWdEZXNjcmlwdGlvbiwgcmVxdWlyZWRUYWdzOiBjeHNjaGVtYS5UYWdbXSkge1xuICBjb25zdCB0YWdzQnlOYW1lOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0ge307XG4gIGZvciAoY29uc3QgdGFnIG9mIHRhZ0Rlc2NyaXB0aW9uLlRhZ3MgPz8gW10pIHtcbiAgICB0YWdzQnlOYW1lW3RhZy5LZXkhXSA9IHRhZy5WYWx1ZTtcbiAgfVxuXG4gIGZvciAoY29uc3QgdGFnIG9mIHJlcXVpcmVkVGFncykge1xuICAgIGlmICh0YWdzQnlOYW1lW3RhZy5rZXldICE9PSB0YWcudmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBBc3luYyBnZW5lcmF0b3IgdGhhdCBwcm9kdWNlcyBsaXN0ZW5lciBkZXNjcmlwdGlvbnMgYnkgdHJhdmVyc2luZyB0aGVcbiAqIHBhZ2luYXRpb24uIEJlY2F1c2UgZGVzY3JpYmVMaXN0ZW5lcnMgb25seSBsZXRzIHlvdSBzZWFyY2ggYnkgb25lIGxvYWRcbiAqIGJhbGFuY2VyIGFybiBhdCBhIHRpbWUsIHdlIHJlcXVlc3QgdGhlbSBpbmRpdmlkdWFsbHkgYW5kIHlpZWxkIHRoZSBsaXN0ZW5lcnNcbiAqIGFzIHRoZXkgY29tZSBpbi5cbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24qIGRlc2NyaWJlTGlzdGVuZXJzQnlMb2FkQmFsYW5jZXJBcm4oZWxidjI6IEFXUy5FTEJ2MiwgbG9hZEJhbGFuY2VyQXJuczogc3RyaW5nW10pIHtcbiAgZm9yIChjb25zdCBsb2FkQmFsYW5jZXJBcm4gb2YgbG9hZEJhbGFuY2VyQXJucykge1xuICAgIGxldCBwYWdlOiBBV1MuRUxCdjIuRGVzY3JpYmVMaXN0ZW5lcnNPdXRwdXQgfCB1bmRlZmluZWQ7XG4gICAgZG8ge1xuICAgICAgcGFnZSA9IGF3YWl0IGVsYnYyLmRlc2NyaWJlTGlzdGVuZXJzKHtcbiAgICAgICAgTG9hZEJhbGFuY2VyQXJuOiBsb2FkQmFsYW5jZXJBcm4sXG4gICAgICAgIE1hcmtlcjogcGFnZT8uTmV4dE1hcmtlcixcbiAgICAgIH0pLnByb21pc2UoKTtcblxuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBwYWdlLkxpc3RlbmVycyA/PyBbXSkge1xuICAgICAgICB5aWVsZCBsaXN0ZW5lcjtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwYWdlLk5leHRNYXJrZXIpO1xuICB9XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGxpc3RlbmVyIG1hdGNoZXMgdGhlIHF1ZXJ5IGZpbHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyTWF0Y2hlc1F1ZXJ5RmlsdGVyKGxpc3RlbmVyOiBBV1MuRUxCdjIuTGlzdGVuZXIsIGFyZ3M6IGN4c2NoZW1hLkxvYWRCYWxhbmNlckxpc3RlbmVyQ29udGV4dFF1ZXJ5KTogYm9vbGVhbiB7XG4gIGlmIChhcmdzLmxpc3RlbmVyUG9ydCAmJiBsaXN0ZW5lci5Qb3J0ICE9PSBhcmdzLmxpc3RlbmVyUG9ydCkge1xuICAgIC8vIE5vIG1hdGNoLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcmdzLmxpc3RlbmVyUHJvdG9jb2wgJiYgbGlzdGVuZXIuUHJvdG9jb2wgIT09IGFyZ3MubGlzdGVuZXJQcm90b2NvbCkge1xuICAgIC8vIE5vIG1hdGNoLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByZWNvcmQgb2YgbG9hZCBiYWxhbmNlcnMgaW5kZXhlZCBieSB0aGVpciBhcm5zXG4gKi9cbmZ1bmN0aW9uIGluZGV4TG9hZEJhbGFuY2Vyc0J5QXJuKGxvYWRCYWxhbmNlcnM6IEFXUy5FTEJ2Mi5Mb2FkQmFsYW5jZXJbXSk6IFJlY29yZDxzdHJpbmcsIEFXUy5FTEJ2Mi5Mb2FkQmFsYW5jZXI+IHtcbiAgY29uc3QgbG9hZEJhbGFuY2Vyc0J5QXJuOiBSZWNvcmQ8c3RyaW5nLCBBV1MuRUxCdjIuTG9hZEJhbGFuY2VyPiA9IHt9O1xuXG4gIGZvciAoY29uc3QgbG9hZEJhbGFuY2VyIG9mIGxvYWRCYWxhbmNlcnMpIHtcbiAgICBsb2FkQmFsYW5jZXJzQnlBcm5bbG9hZEJhbGFuY2VyLkxvYWRCYWxhbmNlckFybiFdID0gbG9hZEJhbGFuY2VyO1xuICB9XG5cbiAgcmV0dXJuIGxvYWRCYWxhbmNlcnNCeUFybjtcbn1cbiJdfQ==