"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileAssetHandler = void 0;
const fs_1 = require("fs");
const path = require("path");
const cloud_assembly_schema_1 = require("@aws-cdk/cloud-assembly-schema");
const mime = require("mime");
const progress_1 = require("../../progress");
const archive_1 = require("../archive");
const fs_extra_1 = require("../fs-extra");
const placeholders_1 = require("../placeholders");
const shell_1 = require("../shell");
/**
 * The size of an empty zip file is 22 bytes
 *
 * Ref: https://en.wikipedia.org/wiki/ZIP_(file_format)
 */
const EMPTY_ZIP_FILE_SIZE = 22;
class FileAssetHandler {
    constructor(workDir, asset, host) {
        this.workDir = workDir;
        this.asset = asset;
        this.host = host;
        this.fileCacheRoot = path.join(workDir, '.cache');
    }
    async publish() {
        const destination = await placeholders_1.replaceAwsPlaceholders(this.asset.destination, this.host.aws);
        const s3Url = `s3://${destination.bucketName}/${destination.objectKey}`;
        const s3 = await this.host.aws.s3Client(destination);
        this.host.emitMessage(progress_1.EventType.CHECK, `Check ${s3Url}`);
        const bucketInfo = BucketInformation.for(this.host);
        // A thunk for describing the current account. Used when we need to format an error
        // message, not in the success case.
        const account = async () => { var _a; return (_a = (await this.host.aws.discoverTargetAccount(destination))) === null || _a === void 0 ? void 0 : _a.accountId; };
        switch (await bucketInfo.bucketOwnership(s3, destination.bucketName)) {
            case BucketOwnership.MINE:
                break;
            case BucketOwnership.DOES_NOT_EXIST:
                throw new Error(`No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
            case BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS:
                throw new Error(`Bucket named '${destination.bucketName}' exists, but not in account ${await account()}. Wrong account?`);
        }
        if (await objectExists(s3, destination.bucketName, destination.objectKey)) {
            this.host.emitMessage(progress_1.EventType.FOUND, `Found ${s3Url}`);
            return;
        }
        // Identify the the bucket encryption type to set the header on upload
        // required for SCP rules denying uploads without encryption header
        let paramsEncryption = {};
        const encryption2 = await bucketInfo.bucketEncryption(s3, destination.bucketName);
        switch (encryption2.type) {
            case 'no_encryption':
                break;
            case 'aes256':
                paramsEncryption = { ServerSideEncryption: 'AES256' };
                break;
            case 'kms':
                // We must include the key ID otherwise S3 will encrypt with the default key
                paramsEncryption = {
                    ServerSideEncryption: 'aws:kms',
                    SSEKMSKeyId: encryption2.kmsKeyId,
                };
                break;
            case 'does_not_exist':
                this.host.emitMessage(progress_1.EventType.DEBUG, `No bucket named '${destination.bucketName}'. Is account ${await account()} bootstrapped?`);
                break;
            case 'access_denied':
                this.host.emitMessage(progress_1.EventType.DEBUG, `Could not read encryption settings of bucket '${destination.bucketName}': uploading with default settings ("cdk bootstrap" to version 9 if your organization's policies prevent a successful upload or to get rid of this message).`);
                break;
        }
        if (this.host.aborted) {
            return;
        }
        const publishFile = this.asset.source.executable ?
            await this.externalPackageFile(this.asset.source.executable) : await this.packageFile(this.asset.source);
        // Add a validation to catch the cases where we're accidentally producing an empty ZIP file (or worse,
        // an empty file)
        if (publishFile.contentType === 'application/zip') {
            const fileSize = (await fs_1.promises.stat(publishFile.packagedPath)).size;
            if (fileSize <= EMPTY_ZIP_FILE_SIZE) {
                const message = [
                    'ðŸš¨ WARNING: EMPTY ZIP FILE ðŸš¨',
                    '',
                    'Zipping this asset produced an empty zip file. We do not know the root cause for this yet, and we need your help tracking it down.',
                    '',
                    'Please visit https://github.com/aws/aws-cdk/issues/18459 and tell us:',
                    'Your OS version, Nodejs version, CLI version, package manager, what the asset is supposed to contain, whether',
                    'or not this error is reproducible, what files are in your cdk.out directory, if you recently changed anything,',
                    'and anything else you think might be relevant.',
                    '',
                    'The deployment will continue, but it may fail. You can try removing the cdk.out directory and running the command',
                    'again; let us know if that resolves it.',
                    '',
                    'If you meant to produce an empty asset file on purpose, you can add an empty dotfile to the asset for now',
                    'to disable this notice.',
                ];
                for (const line of message) {
                    this.host.emitMessage(progress_1.EventType.FAIL, line);
                }
            }
        }
        this.host.emitMessage(progress_1.EventType.UPLOAD, `Upload ${s3Url}`);
        const params = Object.assign({}, {
            Bucket: destination.bucketName,
            Key: destination.objectKey,
            Body: fs_1.createReadStream(publishFile.packagedPath),
            ContentType: publishFile.contentType,
        }, paramsEncryption);
        await s3.upload(params).promise();
    }
    async packageFile(source) {
        var _a;
        if (!source.path) {
            throw new Error(`'path' is expected in the File asset source, got: ${JSON.stringify(source)}`);
        }
        const fullPath = path.resolve(this.workDir, source.path);
        if (source.packaging === cloud_assembly_schema_1.FileAssetPackaging.ZIP_DIRECTORY) {
            const contentType = 'application/zip';
            await fs_1.promises.mkdir(this.fileCacheRoot, { recursive: true });
            const packagedPath = path.join(this.fileCacheRoot, `${this.asset.id.assetId}.zip`);
            if (await fs_extra_1.pathExists(packagedPath)) {
                this.host.emitMessage(progress_1.EventType.CACHED, `From cache ${packagedPath}`);
                return { packagedPath, contentType };
            }
            this.host.emitMessage(progress_1.EventType.BUILD, `Zip ${fullPath} -> ${packagedPath}`);
            await archive_1.zipDirectory(fullPath, packagedPath);
            return { packagedPath, contentType };
        }
        else {
            const contentType = (_a = mime.getType(fullPath)) !== null && _a !== void 0 ? _a : 'application/octet-stream';
            return { packagedPath: fullPath, contentType };
        }
    }
    async externalPackageFile(executable) {
        this.host.emitMessage(progress_1.EventType.BUILD, `Building asset source using command: '${executable}'`);
        return {
            packagedPath: (await shell_1.shell(executable, { quiet: true })).trim(),
            contentType: 'application/zip',
        };
    }
}
exports.FileAssetHandler = FileAssetHandler;
var BucketOwnership;
(function (BucketOwnership) {
    BucketOwnership[BucketOwnership["DOES_NOT_EXIST"] = 0] = "DOES_NOT_EXIST";
    BucketOwnership[BucketOwnership["MINE"] = 1] = "MINE";
    BucketOwnership[BucketOwnership["SOMEONE_ELSES_OR_NO_ACCESS"] = 2] = "SOMEONE_ELSES_OR_NO_ACCESS";
})(BucketOwnership || (BucketOwnership = {}));
async function objectExists(s3, bucket, key) {
    /*
     * The object existence check here refrains from using the `headObject` operation because this
     * would create a negative cache entry, making GET-after-PUT eventually consistent. This has been
     * observed to result in CloudFormation issuing "ValidationError: S3 error: Access Denied", for
     * example in https://github.com/aws/aws-cdk/issues/6430.
     *
     * To prevent this, we are instead using the listObjectsV2 call, using the looked up key as the
     * prefix, and limiting results to 1. Since the list operation returns keys ordered by binary
     * UTF-8 representation, the key we are looking for is guaranteed to always be the first match
     * returned if it exists.
     *
     * If the file is too small, we discount it as a cache hit. There is an issue
     * somewhere that sometimes produces empty zip files, and we would otherwise
     * never retry building those assets without users having to manually clear
     * their bucket, which is a bad experience.
     */
    const response = await s3.listObjectsV2({ Bucket: bucket, Prefix: key, MaxKeys: 1 }).promise();
    return (response.Contents != null &&
        response.Contents.some((object) => object.Key === key && (object.Size == null || object.Size > EMPTY_ZIP_FILE_SIZE)));
}
/**
 * Cache for bucket information, so we don't have to keep doing the same calls again and again
 *
 * We scope the lifetime of the cache to the lifetime of the host, so that we don't have to do
 * anything special for tests and yet the cache will live for the entire lifetime of the asset
 * upload session when used by the CLI.
 */
class BucketInformation {
    constructor() {
        this.ownerships = new Map();
        this.encryptions = new Map();
    }
    static for(host) {
        const existing = BucketInformation.caches.get(host);
        if (existing) {
            return existing;
        }
        const fresh = new BucketInformation();
        BucketInformation.caches.set(host, fresh);
        return fresh;
    }
    async bucketOwnership(s3, bucket) {
        return cached(this.ownerships, bucket, () => this._bucketOwnership(s3, bucket));
    }
    async bucketEncryption(s3, bucket) {
        return cached(this.encryptions, bucket, () => this._bucketEncryption(s3, bucket));
    }
    async _bucketOwnership(s3, bucket) {
        try {
            await s3.getBucketLocation({ Bucket: bucket }).promise();
            return BucketOwnership.MINE;
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return BucketOwnership.DOES_NOT_EXIST;
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return BucketOwnership.SOMEONE_ELSES_OR_NO_ACCESS;
            }
            throw e;
        }
    }
    async _bucketEncryption(s3, bucket) {
        var _a, _b, _c, _d, _e;
        try {
            const encryption = await s3.getBucketEncryption({ Bucket: bucket }).promise();
            const l = (_c = (_b = (_a = encryption === null || encryption === void 0 ? void 0 : encryption.ServerSideEncryptionConfiguration) === null || _a === void 0 ? void 0 : _a.Rules) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
            if (l > 0) {
                const apply = (_e = (_d = encryption === null || encryption === void 0 ? void 0 : encryption.ServerSideEncryptionConfiguration) === null || _d === void 0 ? void 0 : _d.Rules[0]) === null || _e === void 0 ? void 0 : _e.ApplyServerSideEncryptionByDefault;
                let ssealgo = apply === null || apply === void 0 ? void 0 : apply.SSEAlgorithm;
                if (ssealgo === 'AES256')
                    return { type: 'aes256' };
                if (ssealgo === 'aws:kms')
                    return { type: 'kms', kmsKeyId: apply === null || apply === void 0 ? void 0 : apply.KMSMasterKeyID };
            }
            return { type: 'no_encryption' };
        }
        catch (e) {
            if (e.code === 'NoSuchBucket') {
                return { type: 'does_not_exist' };
            }
            if (e.code === 'ServerSideEncryptionConfigurationNotFoundError') {
                return { type: 'no_encryption' };
            }
            if (['AccessDenied', 'AllAccessDisabled'].includes(e.code)) {
                return { type: 'access_denied' };
            }
            return { type: 'no_encryption' };
        }
    }
}
BucketInformation.caches = new WeakMap();
async function cached(cache, key, factory) {
    if (cache.has(key)) {
        return cache.get(key);
    }
    const fresh = await factory(key);
    cache.set(key, fresh);
    return fresh;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsZXMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmaWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSwyQkFBc0Q7QUFDdEQsNkJBQTZCO0FBQzdCLDBFQUFnRjtBQUNoRiw2QkFBNkI7QUFFN0IsNkNBQTJDO0FBQzNDLHdDQUEwQztBQUUxQywwQ0FBeUM7QUFDekMsa0RBQXlEO0FBQ3pELG9DQUFpQztBQUVqQzs7OztHQUlHO0FBQ0gsTUFBTSxtQkFBbUIsR0FBRyxFQUFFLENBQUM7QUFFL0IsTUFBYSxnQkFBZ0I7SUFHM0IsWUFDbUIsT0FBZSxFQUNmLEtBQXdCLEVBQ3hCLElBQWtCO1FBRmxCLFlBQU8sR0FBUCxPQUFPLENBQVE7UUFDZixVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQUN4QixTQUFJLEdBQUosSUFBSSxDQUFjO1FBQ25DLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDcEQsQ0FBQztJQUVNLEtBQUssQ0FBQyxPQUFPO1FBQ2xCLE1BQU0sV0FBVyxHQUFHLE1BQU0scUNBQXNCLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUN4RixNQUFNLEtBQUssR0FBRyxRQUFRLFdBQVcsQ0FBQyxVQUFVLElBQUksV0FBVyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3hFLE1BQU0sRUFBRSxHQUFHLE1BQU0sSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3JELElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLG9CQUFTLENBQUMsS0FBSyxFQUFFLFNBQVMsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUV6RCxNQUFNLFVBQVUsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFD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LEVBQUU7Z0JBQzdCLE9BQU8sRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQzthQUNuQztZQUNELElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxnREFBZ0QsRUFBRTtnQkFDL0QsT0FBTyxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsQ0FBQzthQUNsQztZQUVELElBQUksQ0FBQyxjQUFjLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFO2dCQUMxRCxPQUFPLEVBQUUsSUFBSSxFQUFFLGVBQWUsRUFBRSxDQUFDO2FBQ2xDO1lBQ0QsT0FBTyxFQUFFLElBQUksRUFBRSxlQUFlLEVBQUUsQ0FBQztTQUNsQztJQUNILENBQUM7O0FBbkR1Qix3QkFBTSxHQUFHLElBQUksT0FBTyxFQUFtQyxDQUFDO0FBc0RsRixLQUFLLFVBQVUsTUFBTSxDQUFPLEtBQWdCLEVBQUUsR0FBTSxFQUFFLE9BQTZCO0lBQ2pGLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNsQixPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFFLENBQUM7S0FDeEI7SUFFRCxNQUFNLEtBQUssR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUNqQyxLQUFLLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN0QixPQUFPLEtBQUssQ0FBQztBQUNmLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjcmVhdGVSZWFkU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBGaWxlQXNzZXRQYWNrYWdpbmcsIEZpbGVTb3VyY2UgfSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgbWltZSBmcm9tICdtaW1lJztcbmltcG9ydCB7IEZpbGVNYW5pZmVzdEVudHJ5IH0gZnJvbSAnLi4vLi4vYXNzZXQtbWFuaWZlc3QnO1xuaW1wb3J0IHsgRXZlbnRUeXBlIH0gZnJvbSAnLi4vLi4vcHJvZ3Jlc3MnO1xuaW1wb3J0IHsgemlwRGlyZWN0b3J5IH0gZnJvbSAnLi4vYXJjaGl2ZSc7XG5pbXBvcnQgeyBJQXNzZXRIYW5kbGVyLCBJSGFuZGxlckhvc3QgfSBmcm9tICcuLi9hc3NldC1oYW5kbGVyJztcbmltcG9ydCB7IHBhdGhFeGlzdHMgfSBmcm9tICcuLi9mcy1leHRyYSc7XG5pbXBvcnQgeyByZXBsYWNlQXdzUGxhY2Vob2xkZXJzIH0gZnJvbSAnLi4vcGxhY2Vob2xkZXJzJztcbmltcG9ydCB7IHNoZWxsIH0gZnJvbSAnLi4vc2hlbGwnO1xuXG4vKipcbiAqIFRoZSBzaXplIG9mIGFuIGVtcHR5IHppcCBmaWxlIGlzIDIyIGJ5dGVzXG4gKlxuICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9aSVBfKGZpbGVfZm9ybWF0KVxuICovXG5jb25zdCBFTVBUWV9aSVBfRklMRV9TSVpFID0gMjI7XG5cbmV4cG9ydCBjbGFzcyBGaWxlQXNzZXRIYW5kbGVyIGltcGxlbWVudHMgSUFzc2V0SGFuZGxlciB7XG4gIHByaXZhdGUgcmVhZG9ubHkgZmlsZUNhY2hlUm9vdDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgd29ya0Rpcjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYXNzZXQ6IEZpbGVNYW5pZmVzdEVudHJ5LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgaG9zdDogSUhhbmRsZXJIb3N0KSB7XG4gICAgdGhpcy5maWxlQ2FjaGVSb290ID0gcGF0aC5qb2luKHdvcmtEaXIsICcuY2FjaGUnKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwdWJsaXNoKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGRlc3RpbmF0aW9uID0gYXdhaXQgcmVwbGFjZUF3c1BsYWNlaG9sZGVycyh0aGlzLmFzc2V0LmRlc3RpbmF0aW9uLCB0aGlzLmhvc3QuYXdzKTtcbiAgICBjb25zdCBzM1VybCA9IGBzMzovLyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0vJHtkZXN0aW5hdGlvbi5vYmplY3RLZXl9YDtcbiAgICBjb25zdCBzMyA9IGF3YWl0IHRoaXMuaG9zdC5hd3MuczNDbGllbnQoZGVzdGluYXRpb24pO1xuICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuQ0hFQ0ssIGBDaGVjayAke3MzVXJsfWApO1xuXG4gICAgY29uc3QgYnVja2V0SW5mbyA9IEJ1Y2tldEluZm9ybWF0aW9uLmZvcih0aGlzLmhvc3QpO1xuXG4gICAgLy8gQSB0aHVuayBmb3IgZGVzY3JpYmluZyB0aGUgY3VycmVudCBhY2NvdW50LiBVc2VkIHdoZW4gd2UgbmVlZCB0byBmb3JtYXQgYW4gZXJyb3JcbiAgICAvLyBtZXNzYWdlLCBub3QgaW4gdGhlIHN1Y2Nlc3MgY2FzZS5cbiAgICBjb25zdCBhY2NvdW50ID0gYXN5bmMgKCkgPT4gKGF3YWl0IHRoaXMuaG9zdC5hd3MuZGlzY292ZXJUYXJnZXRBY2NvdW50KGRlc3RpbmF0aW9uKSk/LmFjY291bnRJZDtcbiAgICBzd2l0Y2ggKGF3YWl0IGJ1Y2tldEluZm8uYnVja2V0T3duZXJzaGlwKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKSkge1xuICAgICAgY2FzZSBCdWNrZXRPd25lcnNoaXAuTUlORTpcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5ET0VTX05PVF9FWElTVDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBidWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nLiBJcyBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfSBib290c3RyYXBwZWQ/YCk7XG4gICAgICBjYXNlIEJ1Y2tldE93bmVyc2hpcC5TT01FT05FX0VMU0VTX09SX05PX0FDQ0VTUzpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCdWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nIGV4aXN0cywgYnV0IG5vdCBpbiBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfS4gV3JvbmcgYWNjb3VudD9gKTtcbiAgICB9XG5cbiAgICBpZiAoYXdhaXQgb2JqZWN0RXhpc3RzKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lLCBkZXN0aW5hdGlvbi5vYmplY3RLZXkpKSB7XG4gICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkZPVU5ELCBgRm91bmQgJHtzM1VybH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZGVudGlmeSB0aGUgdGhlIGJ1Y2tldCBlbmNyeXB0aW9uIHR5cGUgdG8gc2V0IHRoZSBoZWFkZXIgb24gdXBsb2FkXG4gICAgLy8gcmVxdWlyZWQgZm9yIFNDUCBydWxlcyBkZW55aW5nIHVwbG9hZHMgd2l0aG91dCBlbmNyeXB0aW9uIGhlYWRlclxuICAgIGxldCBwYXJhbXNFbmNyeXB0aW9uOiB7W2luZGV4OiBzdHJpbmddOmFueX09IHt9O1xuICAgIGNvbnN0IGVuY3J5cHRpb24yID0gYXdhaXQgYnVja2V0SW5mby5idWNrZXRFbmNyeXB0aW9uKHMzLCBkZXN0aW5hdGlvbi5idWNrZXROYW1lKTtcbiAgICBzd2l0Y2ggKGVuY3J5cHRpb24yLnR5cGUpIHtcbiAgICAgIGNhc2UgJ25vX2VuY3J5cHRpb24nOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FlczI1Nic6XG4gICAgICAgIHBhcmFtc0VuY3J5cHRpb24gPSB7IFNlcnZlclNpZGVFbmNyeXB0aW9uOiAnQUVTMjU2JyB9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ttcyc6XG4gICAgICAgIC8vIFdlIG11c3QgaW5jbHVkZSB0aGUga2V5IElEIG90aGVyd2lzZSBTMyB3aWxsIGVuY3J5cHQgd2l0aCB0aGUgZGVmYXVsdCBrZXlcbiAgICAgICAgcGFyYW1zRW5jcnlwdGlvbiA9IHtcbiAgICAgICAgICBTZXJ2ZXJTaWRlRW5jcnlwdGlvbjogJ2F3czprbXMnLFxuICAgICAgICAgIFNTRUtNU0tleUlkOiBlbmNyeXB0aW9uMi5rbXNLZXlJZCxcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkb2VzX25vdF9leGlzdCc6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuREVCVUcsIGBObyBidWNrZXQgbmFtZWQgJyR7ZGVzdGluYXRpb24uYnVja2V0TmFtZX0nLiBJcyBhY2NvdW50ICR7YXdhaXQgYWNjb3VudCgpfSBib290c3RyYXBwZWQ/YCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYWNjZXNzX2RlbmllZCc6XG4gICAgICAgIHRoaXMuaG9zdC5lbWl0TWVzc2FnZShFdmVudFR5cGUuREVCVUcsIGBDb3VsZCBub3QgcmVhZCBlbmNyeXB0aW9uIHNldHRpbmdzIG9mIGJ1Y2tldCAnJHtkZXN0aW5hdGlvbi5idWNrZXROYW1lfSc6IHVwbG9hZGluZyB3aXRoIGRlZmF1bHQgc2V0dGluZ3MgKFwiY2RrIGJvb3RzdHJhcFwiIHRvIHZlcnNpb24gOSBpZiB5b3VyIG9yZ2FuaXphdGlvbidzIHBvbGljaWVzIHByZXZlbnQgYSBzdWNjZXNzZnVsIHVwbG9hZCBvciB0byBnZXQgcmlkIG9mIHRoaXMgbWVzc2FnZSkuYCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3QuYWJvcnRlZCkgeyByZXR1cm47IH1cbiAgICBjb25zdCBwdWJsaXNoRmlsZSA9IHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUgP1xuICAgICAgYXdhaXQgdGhpcy5leHRlcm5hbFBhY2thZ2VGaWxlKHRoaXMuYXNzZXQuc291cmNlLmV4ZWN1dGFibGUpIDogYXdhaXQgdGhpcy5wYWNrYWdlRmlsZSh0aGlzLmFzc2V0LnNvdXJjZSk7XG5cbiAgICAvLyBBZGQgYSB2YWxpZGF0aW9uIHRvIGNhdGNoIHRoZSBjYXNlcyB3aGVyZSB3ZSdyZSBhY2NpZGVudGFsbHkgcHJvZHVjaW5nIGFuIGVtcHR5IFpJUCBmaWxlIChvciB3b3JzZSxcbiAgICAvLyBhbiBlbXB0eSBmaWxlKVxuICAgIGlmIChwdWJsaXNoRmlsZS5jb250ZW50VHlwZSA9PT0gJ2FwcGxpY2F0aW9uL3ppcCcpIHtcbiAgICAgIGNvbnN0IGZpbGVTaXplID0gKGF3YWl0IGZzLnN0YXQocHVibGlzaEZpbGUucGFja2FnZWRQYXRoKSkuc2l6ZTtcbiAgICAgIGlmIChmaWxlU2l6ZSA8PSBFTVBUWV9aSVBfRklMRV9TSVpFKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgJ/CfmqggV0FSTklORzogRU1QVFkgWklQIEZJTEUg8J+aqCcsXG4gICAgICAgICAgJycsXG4gICAgICAgICAgJ1ppcHBpbmcgdGhpcyBhc3NldCBwcm9kdWNlZCBhbiBlbXB0eSB6aXAgZmlsZS4gV2UgZG8gbm90IGtub3cgdGhlIHJvb3QgY2F1c2UgZm9yIHRoaXMgeWV0LCBhbmQgd2UgbmVlZCB5b3VyIGhlbHAgdHJhY2tpbmcgaXQgZG93bi4nLFxuICAgICAgICAgICcnLFxuICAgICAgICAgICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL2F3cy9hd3MtY2RrL2lzc3Vlcy8xODQ1OSBhbmQgdGVsbCB1czonLFxuICAgICAgICAgICdZb3VyIE9TIHZlcnNpb24sIE5vZGVqcyB2ZXJzaW9uLCBDTEkgdmVyc2lvbiwgcGFja2FnZSBtYW5hZ2VyLCB3aGF0IHRoZSBhc3NldCBpcyBzdXBwb3NlZCB0byBjb250YWluLCB3aGV0aGVyJyxcbiAgICAgICAgICAnb3Igbm90IHRoaXMgZXJyb3IgaXMgcmVwcm9kdWNpYmxlLCB3aGF0IGZpbGVzIGFyZSBpbiB5b3VyIGNkay5vdXQgZGlyZWN0b3J5LCBpZiB5b3UgcmVjZW50bHkgY2hhbmdlZCBhbnl0aGluZywnLFxuICAgICAgICAgICdhbmQgYW55dGhpbmcgZWxzZSB5b3UgdGhpbmsgbWlnaHQgYmUgcmVsZXZhbnQuJyxcbiAgICAgICAgICAnJyxcbiAgICAgICAgICAnVGhlIGRlcGxveW1lbnQgd2lsbCBjb250aW51ZSwgYnV0IGl0IG1heSBmYWlsLiBZb3UgY2FuIHRyeSByZW1vdmluZyB0aGUgY2RrLm91dCBkaXJlY3RvcnkgYW5kIHJ1bm5pbmcgdGhlIGNvbW1hbmQnLFxuICAgICAgICAgICdhZ2FpbjsgbGV0IHVzIGtub3cgaWYgdGhhdCByZXNvbHZlcyBpdC4nLFxuICAgICAgICAgICcnLFxuICAgICAgICAgICdJZiB5b3UgbWVhbnQgdG8gcHJvZHVjZSBhbiBlbXB0eSBhc3NldCBmaWxlIG9uIHB1cnBvc2UsIHlvdSBjYW4gYWRkIGFuIGVtcHR5IGRvdGZpbGUgdG8gdGhlIGFzc2V0IGZvciBub3cnLFxuICAgICAgICAgICd0byBkaXNhYmxlIHRoaXMgbm90aWNlLicsXG4gICAgICAgIF07XG5cbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIG1lc3NhZ2UpIHtcbiAgICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkZBSUwsIGxpbmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5VUExPQUQsIGBVcGxvYWQgJHtzM1VybH1gKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgIEJ1Y2tldDogZGVzdGluYXRpb24uYnVja2V0TmFtZSxcbiAgICAgIEtleTogZGVzdGluYXRpb24ub2JqZWN0S2V5LFxuICAgICAgQm9keTogY3JlYXRlUmVhZFN0cmVhbShwdWJsaXNoRmlsZS5wYWNrYWdlZFBhdGgpLFxuICAgICAgQ29udGVudFR5cGU6IHB1Ymxpc2hGaWxlLmNvbnRlbnRUeXBlLFxuICAgIH0sXG4gICAgcGFyYW1zRW5jcnlwdGlvbik7XG5cbiAgICBhd2FpdCBzMy51cGxvYWQocGFyYW1zKS5wcm9taXNlKCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHBhY2thZ2VGaWxlKHNvdXJjZTogRmlsZVNvdXJjZSk6IFByb21pc2U8UGFja2FnZWRGaWxlQXNzZXQ+IHtcbiAgICBpZiAoIXNvdXJjZS5wYXRoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCdwYXRoJyBpcyBleHBlY3RlZCBpbiB0aGUgRmlsZSBhc3NldCBzb3VyY2UsIGdvdDogJHtKU09OLnN0cmluZ2lmeShzb3VyY2UpfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKHRoaXMud29ya0Rpciwgc291cmNlLnBhdGgpO1xuXG4gICAgaWYgKHNvdXJjZS5wYWNrYWdpbmcgPT09IEZpbGVBc3NldFBhY2thZ2luZy5aSVBfRElSRUNUT1JZKSB7XG4gICAgICBjb25zdCBjb250ZW50VHlwZSA9ICdhcHBsaWNhdGlvbi96aXAnO1xuXG4gICAgICBhd2FpdCBmcy5ta2Rpcih0aGlzLmZpbGVDYWNoZVJvb3QsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgICAgY29uc3QgcGFja2FnZWRQYXRoID0gcGF0aC5qb2luKHRoaXMuZmlsZUNhY2hlUm9vdCwgYCR7dGhpcy5hc3NldC5pZC5hc3NldElkfS56aXBgKTtcblxuICAgICAgaWYgKGF3YWl0IHBhdGhFeGlzdHMocGFja2FnZWRQYXRoKSkge1xuICAgICAgICB0aGlzLmhvc3QuZW1pdE1lc3NhZ2UoRXZlbnRUeXBlLkNBQ0hFRCwgYEZyb20gY2FjaGUgJHtwYWNrYWdlZFBhdGh9YCk7XG4gICAgICAgIHJldHVybiB7IHBhY2thZ2VkUGF0aCwgY29udGVudFR5cGUgfTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5CVUlMRCwgYFppcCAke2Z1bGxQYXRofSAtPiAke3BhY2thZ2VkUGF0aH1gKTtcbiAgICAgIGF3YWl0IHppcERpcmVjdG9yeShmdWxsUGF0aCwgcGFja2FnZWRQYXRoKTtcbiAgICAgIHJldHVybiB7IHBhY2thZ2VkUGF0aCwgY29udGVudFR5cGUgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudFR5cGUgPSBtaW1lLmdldFR5cGUoZnVsbFBhdGgpID8/ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nO1xuICAgICAgcmV0dXJuIHsgcGFja2FnZWRQYXRoOiBmdWxsUGF0aCwgY29udGVudFR5cGUgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGV4dGVybmFsUGFja2FnZUZpbGUoZXhlY3V0YWJsZTogc3RyaW5nW10pOiBQcm9taXNlPFBhY2thZ2VkRmlsZUFzc2V0PiB7XG4gICAgdGhpcy5ob3N0LmVtaXRNZXNzYWdlKEV2ZW50VHlwZS5CVUlMRCwgYEJ1aWxkaW5nIGFzc2V0IHNvdXJjZSB1c2luZyBjb21tYW5kOiAnJHtleGVjdXRhYmxlfSdgKTtcblxuICAgIHJldHVybiB7XG4gICAgICBwYWNrYWdlZFBhdGg6IChhd2FpdCBzaGVsbChleGVjdXRhYmxlLCB7IHF1aWV0OiB0cnVlIH0pKS50cmltKCksXG4gICAgICBjb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL3ppcCcsXG4gICAgfTtcbiAgfVxufVxuXG5lbnVtIEJ1Y2tldE93bmVyc2hpcCB7XG4gIERPRVNfTk9UX0VYSVNULFxuICBNSU5FLFxuICBTT01FT05FX0VMU0VTX09SX05PX0FDQ0VTU1xufVxuXG50eXBlIEJ1Y2tldEVuY3J5cHRpb24gPVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ25vX2VuY3J5cHRpb24nIH1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdhZXMyNTYnIH1cbiAgfCB7IHJlYWRvbmx5IHR5cGU6ICdrbXMnOyByZWFkb25seSBrbXNLZXlJZD86IHN0cmluZyB9XG4gIHwgeyByZWFkb25seSB0eXBlOiAnYWNjZXNzX2RlbmllZCcgfVxuICB8IHsgcmVhZG9ubHkgdHlwZTogJ2RvZXNfbm90X2V4aXN0JyB9XG4gIDtcblxuYXN5bmMgZnVuY3Rpb24gb2JqZWN0RXhpc3RzKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nLCBrZXk6IHN0cmluZykge1xuICAvKlxuICAgKiBUaGUgb2JqZWN0IGV4aXN0ZW5jZSBjaGVjayBoZXJlIHJlZnJhaW5zIGZyb20gdXNpbmcgdGhlIGBoZWFkT2JqZWN0YCBvcGVyYXRpb24gYmVjYXVzZSB0aGlzXG4gICAqIHdvdWxkIGNyZWF0ZSBhIG5lZ2F0aXZlIGNhY2hlIGVudHJ5LCBtYWtpbmcgR0VULWFmdGVyLVBVVCBldmVudHVhbGx5IGNvbnNpc3RlbnQuIFRoaXMgaGFzIGJlZW5cbiAgICogb2JzZXJ2ZWQgdG8gcmVzdWx0IGluIENsb3VkRm9ybWF0aW9uIGlzc3VpbmcgXCJWYWxpZGF0aW9uRXJyb3I6IFMzIGVycm9yOiBBY2Nlc3MgRGVuaWVkXCIsIGZvclxuICAgKiBleGFtcGxlIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9hd3MvYXdzLWNkay9pc3N1ZXMvNjQzMC5cbiAgICpcbiAgICogVG8gcHJldmVudCB0aGlzLCB3ZSBhcmUgaW5zdGVhZCB1c2luZyB0aGUgbGlzdE9iamVjdHNWMiBjYWxsLCB1c2luZyB0aGUgbG9va2VkIHVwIGtleSBhcyB0aGVcbiAgICogcHJlZml4LCBhbmQgbGltaXRpbmcgcmVzdWx0cyB0byAxLiBTaW5jZSB0aGUgbGlzdCBvcGVyYXRpb24gcmV0dXJucyBrZXlzIG9yZGVyZWQgYnkgYmluYXJ5XG4gICAqIFVURi04IHJlcHJlc2VudGF0aW9uLCB0aGUga2V5IHdlIGFyZSBsb29raW5nIGZvciBpcyBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSB0aGUgZmlyc3QgbWF0Y2hcbiAgICogcmV0dXJuZWQgaWYgaXQgZXhpc3RzLlxuICAgKlxuICAgKiBJZiB0aGUgZmlsZSBpcyB0b28gc21hbGwsIHdlIGRpc2NvdW50IGl0IGFzIGEgY2FjaGUgaGl0LiBUaGVyZSBpcyBhbiBpc3N1ZVxuICAgKiBzb21ld2hlcmUgdGhhdCBzb21ldGltZXMgcHJvZHVjZXMgZW1wdHkgemlwIGZpbGVzLCBhbmQgd2Ugd291bGQgb3RoZXJ3aXNlXG4gICAqIG5ldmVyIHJldHJ5IGJ1aWxkaW5nIHRob3NlIGFzc2V0cyB3aXRob3V0IHVzZXJzIGhhdmluZyB0byBtYW51YWxseSBjbGVhclxuICAgKiB0aGVpciBidWNrZXQsIHdoaWNoIGlzIGEgYmFkIGV4cGVyaWVuY2UuXG4gICAqL1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHMzLmxpc3RPYmplY3RzVjIoeyBCdWNrZXQ6IGJ1Y2tldCwgUHJlZml4OiBrZXksIE1heEtleXM6IDEgfSkucHJvbWlzZSgpO1xuICByZXR1cm4gKFxuICAgIHJlc3BvbnNlLkNvbnRlbnRzICE9IG51bGwgJiZcbiAgICByZXNwb25zZS5Db250ZW50cy5zb21lKFxuICAgICAgKG9iamVjdCkgPT4gb2JqZWN0LktleSA9PT0ga2V5ICYmIChvYmplY3QuU2l6ZSA9PSBudWxsIHx8IG9iamVjdC5TaXplID4gRU1QVFlfWklQX0ZJTEVfU0laRSksXG4gICAgKVxuICApO1xufVxuXG5cbi8qKlxuICogQSBwYWNrYWdlZCBhc3NldCB3aGljaCBjYW4gYmUgdXBsb2FkZWQgKGVpdGhlciBhIHNpbmdsZSBmaWxlIG9yIGRpcmVjdG9yeSlcbiAqL1xuaW50ZXJmYWNlIFBhY2thZ2VkRmlsZUFzc2V0IHtcbiAgLyoqXG4gICAqIFBhdGggb2YgdGhlIGZpbGUgb3IgZGlyZWN0b3J5XG4gICAqL1xuICByZWFkb25seSBwYWNrYWdlZFBhdGg6IHN0cmluZztcblxuICAvKipcbiAgICogQ29udGVudCB0eXBlIHRvIGJlIGFkZGVkIGluIHRoZSBTMyB1cGxvYWQgYWN0aW9uXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gY29udGVudCB0eXBlXG4gICAqL1xuICByZWFkb25seSBjb250ZW50VHlwZT86IHN0cmluZztcbn1cblxuXG4vKipcbiAqIENhY2hlIGZvciBidWNrZXQgaW5mb3JtYXRpb24sIHNvIHdlIGRvbid0IGhhdmUgdG8ga2VlcCBkb2luZyB0aGUgc2FtZSBjYWxscyBhZ2FpbiBhbmQgYWdhaW5cbiAqXG4gKiBXZSBzY29wZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGNhY2hlIHRvIHRoZSBsaWZldGltZSBvZiB0aGUgaG9zdCwgc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGRvXG4gKiBhbnl0aGluZyBzcGVjaWFsIGZvciB0ZXN0cyBhbmQgeWV0IHRoZSBjYWNoZSB3aWxsIGxpdmUgZm9yIHRoZSBlbnRpcmUgbGlmZXRpbWUgb2YgdGhlIGFzc2V0XG4gKiB1cGxvYWQgc2Vzc2lvbiB3aGVuIHVzZWQgYnkgdGhlIENMSS5cbiAqL1xuY2xhc3MgQnVja2V0SW5mb3JtYXRpb24ge1xuICBwdWJsaWMgc3RhdGljIGZvcihob3N0OiBJSGFuZGxlckhvc3QpIHtcbiAgICBjb25zdCBleGlzdGluZyA9IEJ1Y2tldEluZm9ybWF0aW9uLmNhY2hlcy5nZXQoaG9zdCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7IHJldHVybiBleGlzdGluZzsgfVxuXG4gICAgY29uc3QgZnJlc2ggPSBuZXcgQnVja2V0SW5mb3JtYXRpb24oKTtcbiAgICBCdWNrZXRJbmZvcm1hdGlvbi5jYWNoZXMuc2V0KGhvc3QsIGZyZXNoKTtcbiAgICByZXR1cm4gZnJlc2g7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBjYWNoZXMgPSBuZXcgV2Vha01hcDxJSGFuZGxlckhvc3QsIEJ1Y2tldEluZm9ybWF0aW9uPigpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgb3duZXJzaGlwcyA9IG5ldyBNYXA8c3RyaW5nLCBCdWNrZXRPd25lcnNoaXA+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW5jcnlwdGlvbnMgPSBuZXcgTWFwPHN0cmluZywgQnVja2V0RW5jcnlwdGlvbj4oKTtcblxuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGJ1Y2tldE93bmVyc2hpcChzMzogQVdTLlMzLCBidWNrZXQ6IHN0cmluZyk6IFByb21pc2U8QnVja2V0T3duZXJzaGlwPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLm93bmVyc2hpcHMsIGJ1Y2tldCwgKCkgPT4gdGhpcy5fYnVja2V0T3duZXJzaGlwKHMzLCBidWNrZXQpKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBidWNrZXRFbmNyeXB0aW9uKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRFbmNyeXB0aW9uPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLmVuY3J5cHRpb25zLCBidWNrZXQsICgpID0+IHRoaXMuX2J1Y2tldEVuY3J5cHRpb24oczMsIGJ1Y2tldCkpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBfYnVja2V0T3duZXJzaGlwKHMzOiBBV1MuUzMsIGJ1Y2tldDogc3RyaW5nKTogUHJvbWlzZTxCdWNrZXRPd25lcnNoaXA+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgczMuZ2V0QnVja2V0TG9jYXRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KS5wcm9taXNlKCk7XG4gICAgICByZXR1cm4gQnVja2V0T3duZXJzaGlwLk1JTkU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ05vU3VjaEJ1Y2tldCcpIHsgcmV0dXJuIEJ1Y2tldE93bmVyc2hpcC5ET0VTX05PVF9FWElTVDsgfVxuICAgICAgaWYgKFsnQWNjZXNzRGVuaWVkJywgJ0FsbEFjY2Vzc0Rpc2FibGVkJ10uaW5jbHVkZXMoZS5jb2RlKSkgeyByZXR1cm4gQnVja2V0T3duZXJzaGlwLlNPTUVPTkVfRUxTRVNfT1JfTk9fQUNDRVNTOyB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgX2J1Y2tldEVuY3J5cHRpb24oczM6IEFXUy5TMywgYnVja2V0OiBzdHJpbmcpOiBQcm9taXNlPEJ1Y2tldEVuY3J5cHRpb24+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZW5jcnlwdGlvbiA9IGF3YWl0IHMzLmdldEJ1Y2tldEVuY3J5cHRpb24oeyBCdWNrZXQ6IGJ1Y2tldCB9KS5wcm9taXNlKCk7XG4gICAgICBjb25zdCBsID0gZW5jcnlwdGlvbj8uU2VydmVyU2lkZUVuY3J5cHRpb25Db25maWd1cmF0aW9uPy5SdWxlcz8ubGVuZ3RoID8/IDA7XG4gICAgICBpZiAobCA+IDApIHtcbiAgICAgICAgY29uc3QgYXBwbHkgPSBlbmNyeXB0aW9uPy5TZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb24/LlJ1bGVzWzBdPy5BcHBseVNlcnZlclNpZGVFbmNyeXB0aW9uQnlEZWZhdWx0O1xuICAgICAgICBsZXQgc3NlYWxnbyA9IGFwcGx5Py5TU0VBbGdvcml0aG07XG4gICAgICAgIGlmIChzc2VhbGdvID09PSAnQUVTMjU2JykgcmV0dXJuIHsgdHlwZTogJ2FlczI1NicgfTtcbiAgICAgICAgaWYgKHNzZWFsZ28gPT09ICdhd3M6a21zJykgcmV0dXJuIHsgdHlwZTogJ2ttcycsIGttc0tleUlkOiBhcHBseT8uS01TTWFzdGVyS2V5SUQgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6ICdub19lbmNyeXB0aW9uJyB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLmNvZGUgPT09ICdOb1N1Y2hCdWNrZXQnKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6ICdkb2VzX25vdF9leGlzdCcgfTtcbiAgICAgIH1cbiAgICAgIGlmIChlLmNvZGUgPT09ICdTZXJ2ZXJTaWRlRW5jcnlwdGlvbkNvbmZpZ3VyYXRpb25Ob3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnbm9fZW5jcnlwdGlvbicgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKFsnQWNjZXNzRGVuaWVkJywgJ0FsbEFjY2Vzc0Rpc2FibGVkJ10uaW5jbHVkZXMoZS5jb2RlKSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiAnYWNjZXNzX2RlbmllZCcgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHR5cGU6ICdub19lbmNyeXB0aW9uJyB9O1xuICAgIH1cbiAgfVxufVxuXG5hc3luYyBmdW5jdGlvbiBjYWNoZWQ8QSwgQj4oY2FjaGU6IE1hcDxBLCBCPiwga2V5OiBBLCBmYWN0b3J5OiAoeDogQSkgPT4gUHJvbWlzZTxCPik6IFByb21pc2U8Qj4ge1xuICBpZiAoY2FjaGUuaGFzKGtleSkpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSkhO1xuICB9XG5cbiAgY29uc3QgZnJlc2ggPSBhd2FpdCBmYWN0b3J5KGtleSk7XG4gIGNhY2hlLnNldChrZXksIGZyZXNoKTtcbiAgcmV0dXJuIGZyZXNoO1xufSJdfQ==